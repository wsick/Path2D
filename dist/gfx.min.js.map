{"version":3,"sources":["_version.ts","polyfills/CanvasRenderingContext2D_drawPath.ts","polyfills/CanvasRenderingContext2D_ellipse.ts","polyfills/CanvasRenderingContext2D_exts.ts","polyfills/TextEncoder.ts","ellipticalArc/generate.ts","parse/IParser.ts","parse/ParseTypes.ts","segments/arc.ts","segments/lineTo.ts","segments/ArcTo.ts","segments/bezierCurveTo.ts","segments/ClosePath.ts","segments/Ellipse.ts","segments/moveTo.ts","segments/quadraticCurveTo.ts","segments/Rect.ts","segments/segments.ts","parse/buffer/parser.ts","parse/matching/parser.ts","Enums.ts","Path.ts"],"names":["gfx","this","beginPath","path","draw","save","translate","x","y","rotate","rotation","scale","radiusX","radiusY","arc","startAngle","endAngle","antiClockwise","restore","arg","Path","drawPath","_fill","apply","Array","prototype","slice","call","arguments","_stroke","_clip","global","TextEncoder","Object","defineProperty","value","writable","encode","str","gfx.ellipticalArc","gfx.ellipticalArc.generate","gfx.parse","gfx.parse.getParser","gfx.parse.ParseStyles","gfx.segments","gfx.segments.arcContainsPoint","gfx.segments.getCapSpread","gfx.segments.normalizeVector","gfx.segments.perpendicularVector","gfx.segments.Arc","gfx.segments.Arc.draw","gfx.segments.Arc.init","gfx.segments.Arc.extendFillBox","gfx.segments.Arc.extendStrokeBox","gfx.segments.Arc.getStartVector","gfx.segments.Arc.getEndVector","gfx.segments.LineTo","gfx.segments.LineTo.draw","gfx.segments.LineTo.extendFillBox","gfx.segments.LineTo.extendStrokeBox","gfx.segments.LineTo.getStartVector","gfx.segments.LineTo.getEndVector","gfx.segments.createArc","gfx.segments.getTangentPoint","gfx.segments.getPerpendicularIntersections","gfx.segments.ArcTo","gfx.segments.ArcTo.draw","gfx.segments.ArcTo.init","gfx.segments.ArcTo.extendFillBox","gfx.segments.ArcTo.extendStrokeBox","gfx.segments.ArcTo.getStartVector","gfx.segments.ArcTo.getEndVector","gfx.segments.getMaxima","gfx.segments.cod","gfx.segments.BezierCurveTo","gfx.segments.BezierCurveTo.draw","gfx.segments.BezierCurveTo.extendFillBox","gfx.segments.BezierCurveTo.extendStrokeBox","gfx.segments.BezierCurveTo.getStartVector","gfx.segments.BezierCurveTo.getEndVector","gfx.segments.ClosePath","gfx.segments.ClosePath.draw","gfx.segments.Ellipse","gfx.segments.Ellipse.draw","gfx.segments.Ellipse.extendFillBox","gfx.segments.Ellipse.extendStrokeBox","gfx.segments.Ellipse.getStartVector","gfx.segments.Ellipse.getEndVector","gfx.segments.MoveTo","gfx.segments.MoveTo.draw","gfx.segments.MoveTo.extendFillBox","gfx.segments.MoveTo.extendStrokeBox","gfx.segments.QuadraticCurveTo","gfx.segments.QuadraticCurveTo.draw","gfx.segments.QuadraticCurveTo.extendFillBox","gfx.segments.QuadraticCurveTo.extendStrokeBox","gfx.segments.QuadraticCurveTo.getStartVector","gfx.segments.QuadraticCurveTo.getEndVector","gfx.segments.Rect","gfx.segments.Rect.draw","gfx.segments.Rect.extendFillBox","gfx.segments.Rect.extendStrokeBox","gfx.parse.buffer","gfx.parse.buffer.parseNumber","gfx.parse.buffer.toBuffer","gfx.parse.buffer.isNaN","gfx.parse.buffer.isInfinity","gfx.parse.buffer.parseInteger","gfx.parse.buffer.parseMantissa","gfx.parse.buffer.parseSignificand","gfx.parse.buffer.getSlice","gfx.parse.buffer.Parser","gfx.parse.buffer.Parser.parse","gfx.parse.matching","gfx.parse.matching.parse","gfx.parse.matching.parse.go","gfx.parse.matching.parse.parsePoint","gfx.parse.matching.parse.parseDouble","gfx.parse.matching.parse.advance","gfx.parse.matching.parse.match","gfx.parse.matching.parse.morePointsAvailable","gfx.parse.matching.Parser","gfx.parse.matching.Parser.parse","gfx.FillRule","gfx.SweepDirection","gfx.PenLineCap","gfx.PenLineJoin","gfx.PathOpType","gfx.Path","gfx.Path.constructor","gfx.Path.addPath","gfx.Path.closePath","gfx.Path.moveTo","gfx.Path.lineTo","gfx.Path.bezierCurveTo","gfx.Path.quadraticCurveTo","gfx.Path.arc","gfx.Path.arcTo","gfx.Path.ellipse","gfx.Path.rect","gfx.Path.draw","gfx.Path.parse"],"mappings":"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","file":"gfx.min.js","sourcesContent":["namespace gfx {\r\n    export var version = '0.1.0';\r\n}",null,null,null,null,"namespace gfx.ellipticalArc {\n    var NO_DRAW_EPSILON = 0.000002;\n    var ZERO_EPSILON = 0.000019;\n    var SMALL_EPSILON = 0.000117;\n\n    export function generate(path: Path, sx: number, sy: number, rx: number, ry: number, rotationAngle: number, isLargeArcFlag: boolean, sweepDirectionFlag: SweepDirection, ex: number, ey: number) {\n        // from tests it seems that Silverlight closely follows SVG arc\n        // behavior (which is very different from the model used with GDI+)\n        // some helpful stuff is available here:\n        // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\n        // get start point from the existing path\n        var sx = sx,\n            sy = sy,\n            ex = ex,\n            ey = ey,\n            rx = rx,\n            ry = ry;\n\n        // if start and end points are identical, then no arc is drawn\n        // FIXME: what's the logic (if any) to compare points\n        // e.g. 60 and 60.000002 are drawn while 80 and 80.000003 aren't\n        if (Math.abs(ex - sx) < NO_DRAW_EPSILON && Math.abs(ey - sy) < NO_DRAW_EPSILON)\n            return;\n\n        // Correction of out-of-range radii, see F6.6 (step 1)\n        if (Math.abs(rx) < ZERO_EPSILON || Math.abs(ry) < ZERO_EPSILON) {\n            // treat this as a straight line (to end point)\n            path.lineTo(ex, ey);\n            return;\n        }\n\n        // Silverlight \"too small to be useful\"\n        if (Math.abs(rx) < SMALL_EPSILON || Math.abs(ry) < SMALL_EPSILON) {\n            // yes it does mean there's a hole between \"normal\" FP values and \"zero\" FP values\n            // and SL doesn't render anything in this twilight sonze\n            return;\n        }\n\n        // Correction of out-of-range radii, see F6.6.1 (step 2)\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n\n        // convert angle into radians\n        var angle = rotationAngle * Math.PI / 180.0;\n\n        // variables required for F6.3.1\n        var cos_phi = Math.cos(angle);\n        var sin_phi = Math.sin(angle);\n        var dx2 = (sx - ex) / 2.0;\n        var dy2 = (sy - ey) / 2.0;\n        var x1p = cos_phi * dx2 + sin_phi * dy2;\n        var y1p = cos_phi * dy2 - sin_phi * dx2;\n        var x1p2 = x1p * x1p;\n        var y1p2 = y1p * y1p;\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n\n        // Correction of out-of-range radii, see F6.6.2 (step 4)\n        var lambda = (x1p2 / rx2) + (y1p2 / ry2);\n        if (lambda > 1.0) {\n            // see F6.6.3\n            var lambda_root = Math.sqrt(lambda);\n            rx *= lambda_root;\n            ry *= lambda_root;\n            // update rx2 and ry2\n            rx2 = rx * rx;\n            ry2 = ry * ry;\n        }\n\n        var cxp, cyp, cx, cy;\n        var c = (rx2 * ry2) - (rx2 * y1p2) - (ry2 * x1p2);\n\n        var large = isLargeArcFlag === true;\n        var sweep = sweepDirectionFlag === SweepDirection.Clockwise;\n        // check if there is no possible solution (i.e. we can't do a square root of a negative value)\n        if (c < 0.0) {\n            // scale uniformly until we have a single solution (see F6.2) i.e. when c == 0.0\n            var scale = Math.sqrt(1.0 - c / (rx2 * ry2));\n            rx *= scale;\n            ry *= scale;\n            // update rx2 and ry2\n            rx2 = rx * rx;\n            ry2 = ry * ry;\n\n            // step 2 (F6.5.2) - simplified since c == 0.0\n            cxp = 0.0;\n            cyp = 0.0;\n\n            // step 3 (F6.5.3 first part) - simplified since cxp and cyp == 0.0\n            cx = 0.0;\n            cy = 0.0;\n        } else {\n            // complete c calculation\n            c = Math.sqrt(c / ((rx2 * y1p2) + (ry2 * x1p2)));\n\n            // inverse sign if Fa == Fs\n            if (large === sweep)\n                c = -c;\n\n            // step 2 (F6.5.2)\n            cxp = c * ( rx * y1p / ry);\n            cyp = c * (-ry * x1p / rx);\n\n            // step 3 (F6.5.3 first part)\n            cx = cos_phi * cxp - sin_phi * cyp;\n            cy = sin_phi * cxp + cos_phi * cyp;\n        }\n\n        // step 3 (F6.5.3 second part) we now have the center point of the ellipse\n        cx += (sx + ex) / 2.0;\n        cy += (sy + ey) / 2.0;\n\n        // step 4 (F6.5.4)\n        // we dont' use arccos (as per w3c doc), see http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm\n        // note: atan2 (0.0, 1.0) == 0.0\n        var at = Math.atan2(((y1p - cyp) / ry), ((x1p - cxp) / rx));\n        var theta1 = (at < 0.0) ? 2.0 * Math.PI + at : at;\n\n        var nat = Math.atan2(((-y1p - cyp) / ry), ((-x1p - cxp) / rx));\n        var delta_theta = (nat < at) ? 2.0 * Math.PI - at + nat : nat - at;\n\n        if (sweep) {\n            // ensure delta theta < 0 or else add 360 degrees\n            if (delta_theta < 0.0)\n                delta_theta += 2.0 * Math.PI;\n        } else {\n            // ensure delta theta > 0 or else substract 360 degrees\n            if (delta_theta > 0.0)\n                delta_theta -= 2.0 * Math.PI;\n        }\n\n        // add several cubic bezier to approximate the arc (smaller than 90 degrees)\n        // we add one extra segment because we want something smaller than 90deg (i.e. not 90 itself)\n        var segment_count = Math.floor(Math.abs(delta_theta / (Math.PI / 2))) + 1;\n        var delta = delta_theta / segment_count;\n\n        // http://www.stillhq.com/ctpfaq/2001/comp.text.pdf-faq-2001-04.txt (section 2.13)\n        var bcp = 4.0 / 3 * (1 - Math.cos(delta / 2)) / Math.sin(delta / 2);\n\n        var cos_phi_rx = cos_phi * rx;\n        var cos_phi_ry = cos_phi * ry;\n        var sin_phi_rx = sin_phi * rx;\n        var sin_phi_ry = sin_phi * ry;\n\n        var cos_theta1 = Math.cos(theta1);\n        var sin_theta1 = Math.sin(theta1);\n\n        for (var i = 0; i < segment_count; ++i) {\n            // end angle (for this segment) = current + delta\n            var theta2 = theta1 + delta;\n            var cos_theta2 = Math.cos(theta2);\n            var sin_theta2 = Math.sin(theta2);\n\n            // first control point (based on start point sx,sy)\n            var c1x = sx - bcp * (cos_phi_rx * sin_theta1 + sin_phi_ry * cos_theta1);\n            var c1y = sy + bcp * (cos_phi_ry * cos_theta1 - sin_phi_rx * sin_theta1);\n\n            // end point (for this segment)\n            var cur_ex = cx + (cos_phi_rx * cos_theta2 - sin_phi_ry * sin_theta2);\n            var cur_ey = cy + (sin_phi_rx * cos_theta2 + cos_phi_ry * sin_theta2);\n\n            // second control point (based on end point ex,ey)\n            var c2x = cur_ex + bcp * (cos_phi_rx * sin_theta2 + sin_phi_ry * cos_theta2);\n            var c2y = cur_ey + bcp * (sin_phi_rx * sin_theta2 - cos_phi_ry * cos_theta2);\n\n            path.bezierCurveTo(c1x, c1y, c2x, c2y, cur_ex, cur_ey);\n\n            // next start point is the current end point (same for angle)\n            sx = cur_ex;\n            sy = cur_ey;\n            theta1 = theta2;\n            // avoid recomputations\n            cos_theta1 = cos_theta2;\n            sin_theta1 = sin_theta2;\n        }\n    }\n}","namespace gfx.parse {\n    export interface IParser {\n        parse(path: IPath, data: string|Uint8Array): IPath;\n    }\n\n    export var style = ParseStyles.CharMatching;\n\n    export function getParser(): IParser {\n        if (style === ParseStyles.Buffer)\n            return new buffer.Parser();\n        return new matching.Parser();\n    }\n}","namespace gfx.parse {\n    export enum ParseStyles {\n        CharMatching = 2,\n        Buffer = 1,\n    }\n}","namespace gfx.segments {\n    export interface IArcMetrics {\n        inited: boolean;\n        sx: number;\n        sy: number;\n        ex: number;\n        ey: number;\n        l: number;\n        cl: boolean;\n        r: number;\n        cr: boolean;\n        t: number;\n        ct: boolean;\n        b: number;\n        cb: boolean;\n    }\n\n    export class Arc implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n            ctx.arc(x, y, radius, sa, ea, cc);\n        }\n\n        init(metrics: IArcMetrics, x: number, y: number, radius: number, sa: number, ea: number, cc: boolean) {\n            if (metrics.inited)\n                return;\n\n            var sx = metrics.sx = x + (radius * Math.cos(sa));\n            var sy = metrics.sy = y + (radius * Math.sin(sa));\n            var ex = metrics.ex = x + (radius * Math.cos(ea));\n            var ey = metrics.ey = y + (radius * Math.sin(ea));\n\n            var l = metrics.l = x - radius;\n            metrics.cl = arcContainsPoint(sx, sy, ex, ey, l, y, cc);\n\n            var r = metrics.r = x + radius;\n            metrics.cr = arcContainsPoint(sx, sy, ex, ey, r, y, cc);\n\n            var t = metrics.t = y - radius;\n            metrics.ct = arcContainsPoint(sx, sy, ex, ey, x, t, cc);\n\n            var b = metrics.b = y + radius;\n            metrics.cb = arcContainsPoint(sx, sy, ex, ey, x, b, cc);\n\n            metrics.inited = true;\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics?: any) {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n\n            if (ea === sa)\n                return;\n\n            this.init(metrics, x, y, radius, sa, ea, cc);\n\n            box.l = Math.min(box.l, sx, metrics.ex);\n            box.r = Math.max(box.r, sx, metrics.ex);\n            box.t = Math.min(box.t, sy, metrics.ey);\n            box.b = Math.max(box.b, sy, metrics.ey);\n\n            if (metrics.cl)\n                box.l = Math.min(box.l, metrics.l);\n            if (metrics.cr)\n                box.r = Math.max(box.r, metrics.r);\n            if (metrics.ct)\n                box.t = Math.min(box.t, metrics.t);\n            if (metrics.cb)\n                box.b = Math.max(box.b, metrics.b);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters, metrics?: any) {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n\n            if (ea === sa)\n                return;\n            this.init(metrics, x, y, radius, sa, ea, cc);\n\n            box.l = Math.min(box.l, sx, metrics.ex);\n            box.r = Math.max(box.r, sx, metrics.ex);\n            box.t = Math.min(box.t, sy, metrics.ey);\n            box.b = Math.max(box.b, sy, metrics.ey);\n\n            var hs = pars.strokeThickness / 2.0;\n            if (metrics.cl)\n                box.l = Math.min(box.l, metrics.l - hs);\n            if (metrics.cr)\n                box.r = Math.max(box.r, metrics.r + hs);\n            if (metrics.ct)\n                box.t = Math.min(box.t, metrics.t - hs);\n            if (metrics.cb)\n                box.b = Math.max(box.b, metrics.b + hs);\n\n            var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0; //HTML5 doesn't support start and end cap\n            var sv = this.getStartVector(metrics.sx, metrics.sy, args, metrics);\n            sv[0] = -sv[0];\n            sv[1] = -sv[1];\n            var ss = getCapSpread(sx, sy, pars.strokeThickness, cap, sv);\n            var ev = this.getEndVector(metrics.sx, metrics.sy, args, metrics);\n            var es = getCapSpread(metrics.ex, metrics.ey, pars.strokeThickness, cap, ev);\n\n            box.l = Math.min(box.l, ss.x1, ss.x2, es.x1, es.x2);\n            box.r = Math.max(box.r, ss.x1, ss.x2, es.x1, es.x2);\n            box.t = Math.min(box.t, ss.y1, ss.y2, es.y1, es.y2);\n            box.b = Math.max(box.b, ss.y1, ss.y2, es.y1, es.y2);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n            this.init(metrics, x, y, radius, sa, ea, cc);\n\n            var rv = [\n                sx - x,\n                sy - y\n            ];\n            if (cc)\n                return [rv[1], -rv[0]];\n            return [-rv[1], rv[0]];\n        }\n\n        getEndVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n            this.init(metrics, x, y, radius, sa, ea, cc);\n\n            var rv = [\n                metrics.ex - x,\n                metrics.ey - y\n            ];\n            if (cc)\n                return [rv[1], -rv[0]];\n            return [-rv[1], rv[0]];\n        }\n    }\n\n    function arcContainsPoint(sx: number, sy: number, ex: number, ey: number, cpx: number, cpy: number, cc: boolean): boolean {\n        // var a = ex - sx;\n        // var b = cpx - sx;\n        // var c = ey - sy;\n        // var d = cpy - sy;\n        // det = ad - bc;\n        var n = (ex - sx) * (cpy - sy) - (cpx - sx) * (ey - sy);\n        if (n === 0)\n            return true;\n        if (n > 0 && cc)\n            return true;\n        if (n < 0 && !cc)\n            return true;\n        return false;\n    }\n\n    function getCapSpread(x: number, y: number, thickness: number, cap: PenLineCap, vector: number[]) {\n        var hs = thickness / 2.0;\n        switch (cap) {\n            case PenLineCap.Round:\n                return {\n                    x1: x - hs,\n                    x2: x + hs,\n                    y1: y - hs,\n                    y2: y + hs\n                };\n                break;\n            case PenLineCap.Square:\n                var ed = normalizeVector(vector);\n                var edo = perpendicularVector(ed);\n                return {\n                    x1: x + hs * (ed[0] + edo[0]),\n                    x2: x + hs * (ed[0] - edo[0]),\n                    y1: y + hs * (ed[1] + edo[1]),\n                    y2: y + hs * (ed[1] - edo[1])\n                };\n                break;\n            case PenLineCap.Flat:\n            default:\n                var ed = normalizeVector(vector);\n                var edo = perpendicularVector(ed);\n                return {\n                    x1: x + hs * edo[0],\n                    x2: x + hs * -edo[0],\n                    y1: y + hs * edo[1],\n                    y2: y + hs * -edo[1]\n                };\n                break;\n        }\n    }\n\n    function normalizeVector(v: number[]): number[] {\n        var len = Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n        return [\n            v[0] / len,\n            v[1] / len\n        ];\n    }\n\n    function perpendicularVector(v: number[]): number[] {\n        return [\n            -v[1],\n            v[0]\n        ];\n    }\n}","namespace gfx.segments {\n    export class LineTo implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var x = args[0];\n            var y = args[1];\n            ctx.lineTo(x, y);\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[]) {\n            var x = args[0];\n            var y = args[1];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters) {\n            this.extendFillBox(box, sx, sy, args);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[]): number[] {\n            return [\n                args[0] - sx,\n                args[1] - sy\n            ];\n        }\n\n        getEndVector(sx: number, sy: number, args: any[]): number[] {\n            return [\n                args[0] - sx,\n                args[1] - sy\n            ];\n        }\n    }\n}","/// <reference path=\"LineTo\" />\n/// <reference path=\"Arc\" />\n\nnamespace gfx.segments {\n    export interface IArcToMetrics {\n        inited: boolean;\n        sx: number;\n        sy: number;\n        line: {\n            args: any[];\n        };\n        arc: {\n            sx: number;\n            sy: number;\n            args: any[];\n            metrics?: IArcMetrics;\n        };\n    }\n\n    var _arc = new Arc();\n    var _lineTo = new LineTo();\n\n    export class ArcTo implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var x1: number = args[0];\n            var y1: number = args[1];\n            var x2: number = args[2];\n            var y2: number = args[3];\n            var radius: number = args[4];\n            ctx.arcTo(x1, y1, x2, y2, radius);\n        }\n\n        init(metrics: IArcToMetrics, sx: number, sy: number, args: any[]) {\n            if (metrics.inited || sx !== metrics.sx || sy !== metrics.sy)\n                return;\n            metrics.sx = sx;\n            metrics.sy = sy;\n\n            var x1: number = args[0];\n            var y1: number = args[1];\n            var x2: number = args[2];\n            var y2: number = args[3];\n            var radius: number = args[4];\n\n            var v1 = la.vec2.create(x1 - sx, y1 - sy);\n            var v2 = la.vec2.create(x2 - x1, y2 - y1);\n            var inner_theta = Math.PI - la.vec2.angleBetween(v1, v2);\n            //find 2 points tangent to imaginary circle along guide lines\n            var a = getTangentPoint(inner_theta, radius, la.vec2.create(sx, sy), v1, true);\n            var b = getTangentPoint(inner_theta, radius, la.vec2.create(x1, y1), v2, false);\n            metrics.line = {\n                args: [a[0], a[1]]\n            };\n\n            metrics.arc = createArc(a, v1, b, v2, radius);\n\n            metrics.inited = true;\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics?: any) {\n            this.init(metrics, sx, sy, args);\n\n            box.l = Math.min(box.l, sx);\n            box.r = Math.max(box.r, sx);\n            box.t = Math.min(box.t, sy);\n            box.b = Math.max(box.b, sy);\n\n            var mline = metrics.line,\n                marc = metrics.arc;\n            _lineTo.extendFillBox(box, mline.sx, mline.sy, mline.args);\n            _arc.extendFillBox(box, marc.sx, marc.sy, marc.args, marc.metrics);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters, metrics?: any) {\n            this.init(metrics, sx, sy, args);\n\n            var hs = pars.strokeThickness / 2;\n            box.l = Math.min(box.l, sx - hs);\n            box.r = Math.max(box.r, sx + hs);\n            box.t = Math.min(box.t, sy - hs);\n            box.b = Math.max(box.b, sy + hs);\n\n            var mline = metrics.line,\n                marc = metrics.arc;\n            _lineTo.extendStrokeBox(box, mline.sx, mline.sy, mline.args, pars);\n            _arc.extendStrokeBox(box, marc.sx, marc.sy, marc.args, marc.metrics, pars);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            this.init(metrics, sx, sy, args);\n            return _lineTo.getStartVector(sx, sy, metrics.line.args);\n        }\n\n        getEndVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            this.init(metrics, sx, sy, args);\n            var marc = metrics.arc;\n            return _arc.getEndVector(marc.sx, marc.sy, marc.args, marc.metrics);\n        }\n    }\n\n    function createArc(a: Float32Array, v1: Float32Array, b: Float32Array, v2: Float32Array, radius: number) {\n        //find center point\n        var c = getPerpendicularIntersections(a, v1, b, v2);\n        //counter clockwise test\n        var cc = !la.vec2.isClockwiseTo(v1, v2);\n        //find starting angle -- [1,0] is origin direction of 0rad\n        var sa = Math.atan2(a[1] - c[1], a[0] - c[0]);\n        if (sa < 0)\n            sa = (2 * Math.PI) + sa;\n        var ea = Math.atan2(b[1] - c[1], b[0] - c[0]);\n        if (ea < 0)\n            ea = (2 * Math.PI) + ea;\n        return {\n            sx: a[0],\n            sy: a[1],\n            args: [c[0], c[1], radius, sa, ea, cc],\n            metrics: <IArcMetrics>{}\n        };\n    }\n\n    function getTangentPoint(theta: number, radius: number, s: Float32Array, d: Float32Array, invert: boolean): Float32Array {\n        var len = Math.sqrt(d[0] * d[0] + d[1] * d[1]);\n        var f = radius / Math.tan(theta / 2);\n        var t = f / len;\n        if (invert)\n            t = 1 - t;\n        return la.vec2.create(s[0] + t * d[0], s[1] + t * d[1]);\n    }\n\n    function getPerpendicularIntersections(s1: Float32Array, d1: Float32Array, s2: Float32Array, d2: Float32Array): Float32Array {\n        var p1 = la.vec2.orthogonal(la.vec2.create(d1[0], d1[2]));\n        var p2 = la.vec2.orthogonal(la.vec2.create(d2[0], d2[2]));\n        return la.vec2.intersection(s1, p1, s2, p2);\n    }\n}","namespace gfx.segments {\n    export class BezierCurveTo implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[]) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n\n            var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n            if (m.x[0] != null) {\n                box.l = Math.min(box.l, m.x[0]);\n                box.r = Math.max(box.r, m.x[0]);\n            }\n            if (m.x[1] != null) {\n                box.l = Math.min(box.l, m.x[1]);\n                box.r = Math.max(box.r, m.x[1]);\n            }\n            if (m.y[0] != null) {\n                box.t = Math.min(box.t, m.y[0]);\n                box.b = Math.max(box.b, m.y[0]);\n            }\n            if (m.y[1] != null) {\n                box.t = Math.min(box.t, m.y[1]);\n                box.b = Math.max(box.b, m.y[1]);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n            var hs = pars.strokeThickness / 2.0;\n\n            var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n            if (m.x[0] != null) {\n                box.l = Math.min(box.l, m.x[0] - hs);\n                box.r = Math.max(box.r, m.x[0] + hs);\n            }\n            if (m.x[1] != null) {\n                box.l = Math.min(box.l, m.x[1] - hs);\n                box.r = Math.max(box.r, m.x[1] + hs);\n            }\n            if (m.y[0] != null) {\n                box.t = Math.min(box.t, m.y[0] - hs);\n                box.b = Math.max(box.b, m.y[0] + hs);\n            }\n            if (m.y[1] != null) {\n                box.t = Math.min(box.t, m.y[1] - hs);\n                box.b = Math.max(box.b, m.y[1] + hs);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[]): number[] {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            //[F(0)'x, F(0)'y]\n            return [\n                3 * (cp1x - sx),\n                3 * (cp1y - sy)\n            ];\n        }\n\n        getEndVector(sx: number, sy: number, args: any[]): number[] {\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n            //[F(1)'x, F(1)'y]\n            return [\n                3 * (x - cp2x),\n                3 * (y - cp2y)\n            ];\n        }\n    }\n\n    //http://pomax.nihongoresources.com/pages/bezier/\n    /* Cubic Bezier curve is defined by parameteric curve:\n     * F(t)x =\n     * F(t)y =\n     * where\n     *  s = start point\n     *  cp1 = control point 1\n     *  cp2 = control point 2\n     *  e = end point\n     *\n     * We find the coordinates (4) where F(t)x/dt = 0, F(t)y/dt = 0\n     * (within the constraints of the curve (0 <= t <= 1)\n     * These points will expand the bounding box\n     */\n\n    interface IMaxima {\n        x: number[];\n        y: number[];\n    }\n    function getMaxima(x1: number, x2: number, x3: number, x4: number, y1: number, y2: number, y3: number, y4: number): IMaxima {\n        return {\n            x: cod(x1, x2, x3, x4),\n            y: cod(y1, y2, y3, y4)\n        };\n    }\n\n    function cod(a: number, b: number, c: number, d: number): number[] {\n        var u = 2 * a - 4 * b + 2 * c;\n        var v = b - a;\n        var w = -a + 3 * b + d - 3 * c;\n        var rt = Math.sqrt(u * u - 4 * v * w);\n\n        var cods: number[] = [null, null];\n        if (isNaN(rt))\n            return cods;\n\n        var t: number,\n            ot: number;\n\n        t = (-u + rt) / (2 * w);\n        if (t >= 0 && t <= 1) {\n            ot = 1 - t;\n            cods[0] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n        }\n\n        t = (-u - rt) / (2 * w);\n        if (t >= 0 && t <= 1) {\n            ot = 1 - t;\n            cods[1] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n        }\n\n        return cods;\n    }\n}","namespace gfx.segments {\n    export class ClosePath implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            ctx.closePath();\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[]) {\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters) {\n        }\n\n        getStartVector(sx: number, sy: number, args: any[]): number[] {\n            return undefined;\n        }\n\n        getEndVector(sx: number, sy: number, args: any[]): number[] {\n            return undefined;\n        }\n\n    }\n}","namespace gfx.segments {\n    export class Ellipse implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var x: number = args[0];\n            var y: number = args[1];\n            var rx: number = args[2];\n            var ry: number = args[3];\n            var rotation: number = args[4];\n            var sa: number = args[5];\n            var ea: number = args[6];\n            var ac: boolean = args[7];\n            ctx.ellipse(x, y, rx, ry, rotation, sa, ea, ac);\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics?: any) {\n            var x: number = args[0];\n            var y: number = args[1];\n            var rx: number = args[2];\n            var ry: number = args[3];\n            var rotation: number = args[4];\n            var sa: number = args[5];\n            var ea: number = args[6];\n            var ac: boolean = args[7] === true;\n\n            console.warn(\"extendFillBox\", \"Currently not accounting for rotation or start/end angle.\");\n            //TODO: Account for rotation, start angle, end angle (anticlockwise)\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x + rx + rx);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y + ry + ry);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters, metrics?: any) {\n            var x: number = args[0];\n            var y: number = args[1];\n            var rx: number = args[2];\n            var ry: number = args[3];\n            var rotation: number = args[4];\n            var sa: number = args[5];\n            var ea: number = args[6];\n            var ac: boolean = args[7] === true;\n\n            console.warn(\"extendStrokeBox\", \"Currently not accounting for rotation or start/end angle.\");\n            //TODO: Account for rotation, start angle, end angle (anticlockwise)\n\n            var hs = pars.strokeThickness / 2.0;\n            box.l = Math.min(box.l, x - hs);\n            box.r = Math.max(box.r, x + rx + rx + hs);\n            box.t = Math.min(box.t, y - hs);\n            box.b = Math.max(box.b, y + ry + ry + hs);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            console.warn(\"getStartVector\", \"Currently not accounting for rotation or start/end angle.\");\n            return undefined;\n        }\n\n        getEndVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            console.warn(\"getEndVector\", \"Currently not accounting for rotation or start/end angle.\");\n            return undefined;\n        }\n    }\n}","namespace gfx.segments {\n    export class MoveTo implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var x = args[0];\n            var y = args[1];\n            ctx.moveTo(x, y);\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[]) {\n            var x = args[0];\n            var y = args[1];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters) {\n            this.extendFillBox(box, sx, sy, args);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[]): number[] {\n            return undefined;\n        }\n\n        getEndVector(sx: number, sy: number, args: any[]): number[] {\n            return undefined;\n        }\n    }\n}","namespace gfx.segments {\n    export class QuadraticCurveTo implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n            ctx.quadraticCurveTo(cpx, cpy, x, y);\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[]) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n\n            var m = getMaxima(sx, cpx, x, sy, cpy, y);\n            if (m.x != null) {\n                box.l = Math.min(box.l, m.x);\n                box.r = Math.max(box.r, m.x);\n            }\n            if (m.y != null) {\n                box.t = Math.min(box.t, m.y);\n                box.b = Math.max(box.b, m.y);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n            var hs = pars.strokeThickness / 2.0;\n\n            var m = getMaxima(sx, cpx, x, sy, cpy, y);\n            if (m.x) {\n                box.l = Math.min(box.l, m.x - hs);\n                box.r = Math.max(box.r, m.x + hs);\n            }\n            if (m.y) {\n                box.t = Math.min(box.t, m.y - hs);\n                box.b = Math.max(box.b, m.y + hs);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[]): number[] {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            //[F(0)'x, F(0)'y]\n            return [\n                2 * (cpx - sx),\n                2 * (cpy - sy)\n            ];\n        }\n\n        getEndVector(sx: number, sy: number, args: any[]): number[] {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n            //[F(1)'x, F(1)'y]\n            return [\n                2 * (x - cpx),\n                2 * (y - cpy)\n            ];\n        }\n    }\n\n    //http://pomax.nihongoresources.com/pages/bezier/\n    /* Quadratic Bezier curve is defined by parametric curve:\n     *  F(t)x = s.x(1-t)^2 + cp.x(1-t)t + e.x(t^2)\n     *  F(t)x = s.y(1-t)^2 + cp.y(1-t)t + e.y(t^2)\n     * where\n     *  s = start point\n     *  cp = control point\n     *  e = end point\n     *\n     * We find the coordinates (2) where F(t)x/dt = 0, F(t)y/dt = 0\n     * (within the constraints of the curve (0 <= t <= 1)\n     * These points will expand the bounding box\n     */\n\n    interface IMaxima {\n        x: number;\n        y: number;\n    }\n    function getMaxima(x1: number, x2: number, x3: number, y1: number, y2: number, y3: number): IMaxima {\n        return {\n            x: cod(x1, x2, x3),\n            y: cod(y1, y2, y3)\n        };\n    }\n\n    function cod(a: number, b: number, c: number): number {\n        var t = (a - b) / (a - 2 * b + c);\n        if (t < 0 || t > 1)\n            return null;\n        return (a * Math.pow(1 - t, 2)) + (2 * b * (1 - t) * t) + (c * Math.pow(t, 2));\n    }\n}","namespace gfx.segments {\n    export class Rect implements ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]) {\n            var x: number = args[0];\n            var y: number = args[1];\n            var w: number = args[2];\n            var h: number = args[3];\n            ctx.rect(x, y, w, h);\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics?: any) {\n            var x: number = args[0];\n            var y: number = args[1];\n            var w: number = args[2];\n            var h: number = args[3];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x + w);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y + h);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters, metrics?: any) {\n            var x: number = args[0];\n            var y: number = args[1];\n            var w: number = args[2];\n            var h: number = args[3];\n            var hs = pars.strokeThickness / 2.0;\n            box.l = Math.min(box.l, x - hs);\n            box.r = Math.max(box.r, x + w + hs);\n            box.t = Math.min(box.t, y - hs);\n            box.b = Math.max(box.b, y + h + hs);\n        }\n\n        getStartVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            return undefined;\n        }\n\n        getEndVector(sx: number, sy: number, args: any[], metrics?: any): number[] {\n            return undefined;\n        }\n    }\n}","/// <reference path=\"ClosePath\" />\n/// <reference path=\"MoveTo\" />\n/// <reference path=\"LineTo\" />\n/// <reference path=\"BezierCurveTo\" />\n/// <reference path=\"QuadraticCurveTo\" />\n/// <reference path=\"Arc\" />\n/// <reference path=\"ArcTo\" />\n/// <reference path=\"Ellipse\" />\n/// <reference path=\"Rect\" />\n\nnamespace gfx.segments {\n    export interface ISegment {\n        draw(ctx: CanvasRenderingContext2D, args: any[]);\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics?: any);\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], pars: IStrokeParameters, metrics?: any);\n        getStartVector(sx: number, sy: number, args: any[], metrics?: any): number[];\n        getEndVector(sx: number, sy: number, args: any[], metrics?: any): number[];\n    }\n\n    export var all = [];\n    all[PathOpType.closePath] = new ClosePath();\n    all[PathOpType.moveTo] = new MoveTo();\n    all[PathOpType.lineTo] = new LineTo();\n    all[PathOpType.bezierCurveTo] = new BezierCurveTo();\n    all[PathOpType.quadraticCurveTo] = new QuadraticCurveTo();\n    all[PathOpType.arc] = new Arc();\n    all[PathOpType.arcTo] = new ArcTo();\n    all[PathOpType.ellipse] = new Ellipse();\n    all[PathOpType.rect] = new Rect();\n}","namespace gfx.parse.buffer {\n    export class Parser implements IParser {\n        parse(path: IPath, data: string|Uint8Array): IPath {\n            var buffer = toBuffer(data);\n            //TODO: Implement\n            return undefined;\n        }\n    }\n\n    export function parseNumber(tracker: IParseTracker): number {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var len = data.length;\n        //NaN\n        if (isNaN(data, tracker.offset)) {\n            tracker.offset += 3;\n            return NaN;\n        }\n\n        //Check - or +\n        var negate = false;\n        if (data[tracker.offset] === 0x2D) {\n            negate = true;\n            tracker.offset++;\n        } else if (data[tracker.offset] === 0x2B) {\n            tracker.offset++;\n        }\n\n        //Infinity\n        if (isInfinity(data, tracker.offset)) {\n            tracker.offset += 8;\n            return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n        }\n\n        //(characteristic)[.(mantissa)][Ee[+-](significand)]\n        parseInteger(tracker);\n        var cur = data[tracker.offset];\n        if (cur === 0x2E) { // '.'\n            tracker.offset++;\n            if (!parseMantissa(tracker))\n                throw new Error(\"Invalid number\");\n        }\n\n        if (!parseSignificand(tracker))\n            throw new Error(\"Invalid number\");\n\n        return parseFloat(getSlice(data, start, tracker.offset - start));\n    }\n\n    function toBuffer(data: string|Uint8Array): Uint8Array {\n        if (data instanceof Uint8Array)\n            return data;\n        if (typeof TextEncoder === \"function\")\n            return new TextEncoder().encode(<string>data);\n    }\n\n    function isNaN(data: Uint8Array, i: number): boolean {\n        return data[i + 0] === 0x4E //N\n            && data[i + 1] === 0x61 //a\n            && data[i + 2] === 0x4E //N\n            ;\n    }\n\n    function isInfinity(data: Uint8Array, i: number): boolean {\n        return data[i + 0] === 0x49 //I\n            && data[i + 1] === 0x6E //n\n            && data[i + 2] === 0x66 //f\n            && data[i + 3] === 0x69 //i\n            && data[i + 4] === 0x6E //n\n            && data[i + 5] === 0x69 //i\n            && data[i + 6] === 0x74 //t\n            && data[i + 7] === 0x79 //y\n            ;\n    }\n\n    function parseInteger(tracker: IParseTracker): boolean {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var cur: number;\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n            tracker.offset++;\n        }\n        return tracker.offset !== start;\n    }\n\n    function parseMantissa(tracker: IParseTracker): boolean {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var cur: number;\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n            tracker.offset++;\n        }\n        return tracker.offset !== start;\n    }\n\n    function parseSignificand(tracker: IParseTracker): boolean {\n        var data = tracker.data;\n        if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\n            return true;\n        tracker.offset++;\n\n        var cur = data[tracker.offset];\n        if (cur === 0x2D || cur === 0x2B) // '-' '+'\n            tracker.offset++;\n        return parseInteger(tracker);\n    }\n\n    function getSlice(data: Uint8Array, offset: number, length: number): string {\n        var buf = new Array(length);\n        for (var i = 0; i < length; i++) {\n            buf[i] = data[offset + i];\n        }\n        return String.fromCharCode.apply(null, buf);\n    }\n}","// Path Markup Syntax: http://msdn.microsoft.com/en-us/library/cc189041(v=vs.95).aspx\n\n//FigureDescription Syntax\n// MoveCommand DrawCommands [CloseCommand]\n\n//Double Syntax\n// digits\n// digits.digits\n// 'Infinity'\n// '-Infinity'\n// 'NaN'\n\n//Point Syntax\n// x,y\n// x y\n\n//Loop until exhausted\n//  Parse FigureDescription\n//      Find \"M\" or \"m\"? - Parse MoveCommand (start point)\n//          <point>\n//\n//      Find \"L\" or \"l\"? - Parse LineCommand (end point)\n//          <point>\n//      Find \"H\" or \"h\"? - Parse HorizontalLineCommand (x)\n//          <double>\n//      Find \"V\" or \"v\"? - Parse VerticalLineCommand (y)\n//          <double>\n//      Find \"C\" or \"c\"? - Parse CubicBezierCurveCommand (control point 1, control point 2, end point)\n//          <point> <point> <point>\n//      Find \"Q\" or \"q\"? - Parse QuadraticBezierCurveCommand (control point, end point)\n//          <point> <point>\n//      Find \"S\" or \"s\"? - Parse SmoothCubicBezierCurveCommand (control point 2, end point)\n//          <point> <point>\n//      Find \"T\" or \"t\"? - Parse SmoothQuadraticBezierCurveCommand (control point, end point)\n//          <point> <point>\n//      Find \"A\" or \"a\"? - Parse EllipticalArcCommand (size, rotationAngle, isLargeArcFlag, sweepDirectionFlag, endPoint)\n//          <point> <double> <1,0> <1,0> <point>\n//\n//      Find \"Z\" or \"z\"? - CloseCommand\n\nnamespace gfx.parse.matching {\n    export class Parser implements IParser {\n        parse(path: IPath, data: string|Uint8Array): IPath {\n            if (typeof data === \"string\")\n                parse(path, data, data.length);\n            console.warn(\"Input parse data was not a string.\", data);\n            return path;\n        }\n    }\n\n    interface IPoint {\n        x: number;\n        y: number;\n    }\n\n    function parse(path: IPath, str: string, len: number) {\n        var index = 0;\n        var fillRule = FillRule.EvenOdd;\n        go();\n        path.fillRule = fillRule || FillRule.EvenOdd;\n\n        function go() {\n            var cp = {x: 0, y: 0};\n            var cp1: IPoint, cp2: IPoint, cp3: IPoint;\n            var start = {x: 0, y: 0};\n            var cbz = false; // last figure is a cubic bezier curve\n            var qbz = false; // last figure is a quadratic bezier curve\n            var cbzp = {x: 0, y: 0}; // points needed to create \"smooth\" beziers\n            var qbzp = {x: 0, y: 0}; // points needed to create \"smooth\" beziers\n\n            while (index < len) {\n                var c;\n                while (index < len && (c = str.charAt(index)) === ' ') {\n                    index++;\n                }\n                index++;\n                var relative = false;\n                switch (c) {\n                    case 'f':\n                    case 'F':\n                        c = str.charAt(index);\n                        if (c === '0')\n                            fillRule = FillRule.EvenOdd;\n                        else if (c === '1')\n                            fillRule = FillRule.NonZero;\n                        else\n                            return null;\n                        index++;\n                        c = str.charAt(index);\n                        break;\n                    case 'm':\n                        relative = true;\n                    case 'M':\n                        cp1 = parsePoint();\n                        if (cp1 == null)\n                            break;\n                        if (relative) {\n                            cp1.x += cp.x;\n                            cp1.y += cp.y;\n                        }\n                        path.moveTo(cp1.x, cp1.y);\n                        start.x = cp.x = cp1.x;\n                        start.y = cp.y = cp1.y;\n                        advance();\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            path.lineTo(cp1.x, cp1.y);\n                        }\n                        cp.x = cp1.x;\n                        cp.y = cp1.y;\n                        cbz = qbz = false;\n                        break;\n                    case 'l':\n                        relative = true;\n                    case 'L':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n\n                            path.lineTo(cp1.x, cp1.y);\n\n                            cp.x = cp1.x;\n                            cp.y = cp1.y;\n                            advance();\n                        }\n                        cbz = qbz = false;\n                        break;\n                    case 'h':\n                        relative = true;\n                    case 'H':\n                        var x = parseDouble();\n                        if (x == null)\n                            break;\n\n                        if (relative)\n                            x += cp.x;\n                        cp = {x: x, y: cp.y};\n\n                        path.lineTo(cp.x, cp.y);\n                        cbz = qbz = false;\n                        break;\n                    case 'v':\n                        relative = true;\n                    case 'V':\n                        var y = parseDouble();\n                        if (y == null)\n                            break;\n\n                        if (relative)\n                            y += cp.y;\n                        cp = {x: cp.x, y: y};\n\n                        path.lineTo(cp.x, cp.y);\n                        cbz = qbz = false;\n                        break;\n                    case 'c':\n                        relative = true;\n                    case 'C':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            advance();\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n                            if ((cp3 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp3.x += cp.x;\n                                cp3.y += cp.y;\n                            }\n                            advance();\n\n                            path.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n\n                            cp1.x = cp3.x;\n                            cp1.y = cp3.y;\n                        }\n                        cp.x = cp3.x;\n                        cp.y = cp3.y;\n                        cbz = true;\n                        cbzp.x = cp2.x;\n                        cbzp.y = cp2.y;\n                        qbz = false;\n                        break;\n                    case 's':\n                        relative = true;\n                    case 'S':\n                        while (morePointsAvailable()) {\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n                            if ((cp3 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp3.x += cp.x;\n                                cp3.y += cp.y;\n                            }\n\n                            if (cbz) {\n                                cp1.x = 2 * cp.x - cbzp.x;\n                                cp1.y = 2 * cp.y - cbzp.y;\n                            } else\n                                cp1 = cp;\n\n                            path.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n\n                            cbz = true;\n                            cbzp.x = cp2.x;\n                            cbzp.y = cp2.y;\n\n                            cp.x = cp3.x;\n                            cp.y = cp3.y;\n\n                            advance();\n                        }\n                        qbz = false;\n                        break;\n                    case 'q':\n                        relative = true;\n                    case 'Q':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            advance();\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n\n                            path.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n                        }\n                        qbz = true;\n                        qbzp.x = cp1.x;\n                        qbzp.y = cp1.y;\n                        cbz = false;\n                        break;\n                    case 't':\n                        relative = true;\n                    case 'T':\n                        while (morePointsAvailable()) {\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n\n                            if (qbz) {\n                                cp1.x = 2 * cp.x - qbzp.x;\n                                cp1.y = 2 * cp.y - qbzp.y;\n                            } else\n                                cp1 = cp;\n\n                            path.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n\n                            qbz = true;\n                            qbzp.x = cp1.x;\n                            qbzp.y = cp1.y;\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n\n                            advance();\n                        }\n                        cbz = false;\n                        break;\n                    case 'a':\n                        relative = true;\n                    case 'A':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n\n                            var angle = parseDouble();\n                            var is_large = parseDouble() !== 0;\n                            var sweep = SweepDirection.Counterclockwise;\n                            if (parseDouble() !== 0) sweep = SweepDirection.Clockwise;\n\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n\n                            console.warn(\"ellipticalArc not implemented\");\n                            //path.ellipticalArc(cp1.x, cp1.y, angle, is_large, sweep, cp2.x, cp2.y);\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n\n                            advance();\n                        }\n                        cbz = qbz = false;\n                        break;\n                    case 'z':\n                    case 'Z':\n                        path.closePath();\n\n                        cp.x = start.x;\n                        cp.y = start.y;\n                        cbz = qbz = false;\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        function parsePoint(): IPoint {\n            var x = parseDouble();\n            if (x == null)\n                return null;\n\n            var c;\n            while (index < len && ((c = str.charAt(index)) === ' ' || c === ',')) {\n                index++;\n            }\n            if (index >= len)\n                return null;\n\n            var y = parseDouble();\n            if (y == null)\n                return null;\n\n            return {x: x, y: y};\n        }\n\n        function parseDouble(): number {\n            advance();\n            var isNegative = false;\n            if (match('-')) {\n                isNegative = true;\n                index++;\n            } else if (match('+')) {\n                index++;\n            }\n            if (match('Infinity')) {\n                index += 8;\n                return isNegative ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n            }\n            if (match('NaN'))\n                return NaN;\n\n            var temp = '';\n            while (index < len) {\n                var code = str.charCodeAt(index);\n                var c = str[index];\n                //0-9, ., E, e, E-, e-\n                if (code >= 48 && code <= 57)\n                    temp += c;\n                else if (code === 46)\n                    temp += c;\n                else if (c === 'E' || c === 'e') {\n                    temp += c;\n                    if (str[index + 1] === '-') {\n                        temp += '-';\n                        index++;\n                    }\n                }\n                else\n                    break;\n                index++;\n            }\n            if (temp.length === 0)\n                return null;\n            var f = parseFloat(temp);\n            return isNegative ? -f : f;\n        }\n\n        function advance() {\n            var code: number;\n            var c: string;\n            while (index < len) {\n                code = str.charCodeAt(index);\n                //alphanum\n                if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122) || (code >= 48 && code <= 57))\n                    break;\n                c = String.fromCharCode(code);\n                if (c === '.')\n                    break;\n                if (c === '-')\n                    break;\n                if (c === '+')\n                    break;\n                index++;\n            }\n        }\n\n        function match(matchStr: string): boolean {\n            var c1: string;\n            var c2: string;\n            for (var i = 0; i < matchStr.length && (index + i) < len; i++) {\n                c1 = matchStr.charAt(i);\n                c2 = str.charAt(index + i);\n                if (c1 !== c2)\n                    return false;\n            }\n            return true;\n        }\n\n        function morePointsAvailable(): boolean {\n            var c;\n            while (index < len && ((c = str.charAt(index)) === ',' || c === ' ')) {\n                index++;\n            }\n            if (index >= len)\n                return false;\n            if (c === '.' || c === '-' || c === '+')\n                return true;\n            var code = str.charCodeAt(index);\n            return code >= 48 && code <= 57;\n        }\n    }\n}","namespace gfx {\n    export enum FillRule {\n        EvenOdd = 0,\n        NonZero = 1\n    }\n    export enum SweepDirection {\n        Counterclockwise = 0,\n        Clockwise = 1,\n    }\n    export enum PenLineCap {\n        Flat = 0,\n        Square = 1,\n        Round = 2,\n        Triangle = 3,\n    }\n    export enum PenLineJoin {\n        Miter = 0,\n        Bevel = 1,\n        Round = 2,\n    }\n}","namespace gfx {\n    interface IPathOp {\n        type: PathOpType;\n        args: any[];\n        metrics?: any;\n    }\n\n    export enum PathOpType {\n        closePath,\n        moveTo,\n        lineTo,\n        bezierCurveTo,\n        quadraticCurveTo,\n        arc,\n        arcTo,\n        ellipse,\n        rect,\n    }\n\n    export class Path implements IPath {\n        private $ops: IPathOp[];\n\n        fillRule: FillRule;\n\n        constructor();\n        constructor(path: Path);\n        constructor(d: string);\n        constructor(arg0?: string|Path) {\n            if (arg0 instanceof Path) {\n                this.$ops = JSON.parse(JSON.stringify(this.$ops));\n            } else if (typeof arg0 === \"string\") {\n                this.$ops = [];\n                Path.parse.call(this, arg0);\n            } else {\n                this.$ops = [];\n            }\n        }\n\n        addPath(path: Path, transform?: SVGMatrix) {\n            console.warn(\"addPath\", \"Not implemented\");\n        }\n\n        closePath() {\n            this.$ops.push({\n                type: PathOpType.closePath,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        moveTo(x: number, y: number) {\n            this.$ops.push({\n                type: PathOpType.moveTo,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        lineTo(x: number, y: number) {\n            this.$ops.push({\n                type: PathOpType.lineTo,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.$ops.push({\n                type: PathOpType.bezierCurveTo,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.$ops.push({\n                type: PathOpType.quadraticCurveTo,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.$ops.push({\n                type: PathOpType.arc,\n                args: Array.prototype.slice.call(arguments, 0),\n                metrics: {}\n            });\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.$ops.push({\n                type: PathOpType.arcTo,\n                args: Array.prototype.slice.call(arguments, 0),\n                metrics: {}\n            });\n        }\n\n        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.$ops.push({\n                type: PathOpType.ellipse,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        rect(x: number, y: number, width: number, height: number) {\n            this.$ops.push({\n                type: PathOpType.rect,\n                args: Array.prototype.slice.call(arguments, 0)\n            });\n        }\n\n        draw(ctx: CanvasRenderingContext2D) {\n            for (var i = 0, ops = this.$ops, len = ops.length; i < len; i++) {\n                let op = ops[i];\n                let name: string = PathOpType[op.type];\n                let func = ctx[name];\n                if (!func)\n                    throw new Error(`Invalid path operation type. [${op.type}]`);\n                func.apply(this, op.args);\n            }\n        }\n\n        static parse(d: string): IPath {\n            var parser = parse.getParser();\n            var _this = <Path><any>this;\n            var inst = _this instanceof Path ? _this : new Path();\n            return parser.parse(inst, d);\n        }\n    }\n}"],"sourceRoot":"/source/"}