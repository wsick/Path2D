{"version":3,"sources":["_version.ts","polyfills/CanvasRenderingContext2D_drawPath.ts","polyfills/CanvasRenderingContext2D_ellipse.ts","polyfills/CanvasRenderingContext2D_exts.ts","polyfills/TextEncoder.ts","MediaParser.ts","Path2DEx.ts","Path2D_parse.ts","parseNumber.ts","parser.ts"],"names":["path2d","this","beginPath","i","ops","path","$ops","len","length","op","name_1","PathOpType","type","func","CanvasRenderingContext2D","prototype","Error","apply","args","save","translate","x","y","rotate","rotation","scale","radiusX","radiusY","arc","startAngle","endAngle","antiClockwise","restore","arg","Path2D","drawPath","_fill","Array","slice","call","arguments","_stroke","_clip","global","TextEncoder","Object","defineProperty","value","writable","encode","str","path2d.MediaParser","path2d.MediaParser.constructor","path2d.MediaParser.ParseDouble","path2d.MediaParser.Match","path2d.MediaParser.Advance","path2d.MediaParser.MorePointsAvailable","path2d.PathOpType","path2d.Path2DEx","path2d.Path2DEx.constructor","path2d.Path2DEx.closePath","path2d.Path2DEx.moveTo","path2d.Path2DEx.lineTo","path2d.Path2DEx.bezierCurveTo","path2d.Path2DEx.quadraticCurveTo","path2d.Path2DEx.arc","path2d.Path2DEx.arcTo","path2d.Path2DEx.ellipse","path2d.Path2DEx.rect","path2d.Path2DEx.parse","parse","Path2DEx","path2d.parseNumber","path2d.isNaN","path2d.isInfinity","path2d.parseInteger","path2d.parseMantissa","path2d.parseSignificand","path2d.getSlice","path2d.doParse","path2d.toBuffer","doParse","d"],"mappings":"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","file":"path2d.min.js","sourcesContent":["namespace path2d {\r\n    export var version = '0.1.0';\r\n}",null,null,null,null,"// Path Markup Syntax: http://msdn.microsoft.com/en-us/library/cc189041(v=vs.95).aspx\r\n\r\n//FigureDescription Syntax\r\n// MoveCommand DrawCommands [CloseCommand]\r\n\r\n//Double Syntax\r\n// digits\r\n// digits.digits\r\n// 'Infinity'\r\n// '-Infinity'\r\n// 'NaN'\r\n\r\n//Point Syntax\r\n// x,y\r\n// x y\r\n\r\n//Loop until exhausted\r\n//  Parse FigureDescription\r\n//      Find \"M\" or \"m\"? - Parse MoveCommand (start point)\r\n//          <point>\r\n//\r\n//      Find \"L\" or \"l\"? - Parse LineCommand (end point)\r\n//          <point>\r\n//      Find \"H\" or \"h\"? - Parse HorizontalLineCommand (x)\r\n//          <double>\r\n//      Find \"V\" or \"v\"? - Parse VerticalLineCommand (y)\r\n//          <double>\r\n//      Find \"C\" or \"c\"? - Parse CubicBezierCurveCommand (control point 1, control point 2, end point)\r\n//          <point> <point> <point>\r\n//      Find \"Q\" or \"q\"? - Parse QuadraticBezierCurveCommand (control point, end point)\r\n//          <point> <point>\r\n//      Find \"S\" or \"s\"? - Parse SmoothCubicBezierCurveCommand (control point 2, end point)\r\n//          <point> <point>\r\n//      Find \"T\" or \"t\"? - Parse SmoothQuadraticBezierCurveCommand (control point, end point)\r\n//          <point> <point>\r\n//      Find \"A\" or \"a\"? - Parse EllipticalArcCommand (size, rotationAngle, isLargeArcFlag, sweepDirectionFlag, endPoint)\r\n//          <point> <double> <1,0> <1,0> <point>\r\n//\r\n//      Find \"Z\" or \"z\"? - CloseCommand\r\n\r\nmodule path2d {\r\n    export class MediaParser {\r\n        private str: string;\r\n        private len: number;\r\n        private index: number = 0;\r\n\r\n        constructor (str: string) {\r\n            this.str = str;\r\n            this.len = str.length;\r\n        }\r\n\r\n        /*\r\n        ParseGeometryImpl (): Geometry {\r\n            var cp = new Point();\r\n            var cp1: Point, cp2: Point, cp3: Point;\r\n            var start = new Point();\r\n            var fillRule = Shapes.FillRule.EvenOdd;\r\n            var cbz = false; // last figure is a cubic bezier curve\r\n            var qbz = false; // last figure is a quadratic bezier curve\r\n            var cbzp = new Point(); // points needed to create \"smooth\" beziers\r\n            var qbzp = new Point(); // points needed to create \"smooth\" beziers\r\n\r\n            var path = new minerva.path.Path();\r\n            while (this.index < this.len) {\r\n                var c;\r\n                while (this.index < this.len && (c = this.str.charAt(this.index)) === ' ') {\r\n                    this.index++;\r\n                }\r\n                this.index++;\r\n                var relative = false;\r\n                switch (c) {\r\n                    case 'f':\r\n                    case 'F':\r\n                        c = this.str.charAt(this.index);\r\n                        if (c === '0')\r\n                            fillRule = Shapes.FillRule.EvenOdd;\r\n                        else if (c === '1')\r\n                            fillRule = Shapes.FillRule.NonZero;\r\n                        else\r\n                            return null;\r\n                        this.index++;\r\n                        c = this.str.charAt(this.index);\r\n                        break;\r\n                    case 'm':\r\n                        relative = true;\r\n                    case 'M':\r\n                        cp1 = this.ParsePoint();\r\n                        if (cp1 == null)\r\n                            break;\r\n                        if (relative) {\r\n                            cp1.x += cp.x;\r\n                            cp1.y += cp.y;\r\n                        }\r\n                        path.move(cp1.x, cp1.y);\r\n                        start.x = cp.x = cp1.x;\r\n                        start.y = cp.y = cp1.y;\r\n                        this.Advance();\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n                            path.line(cp1.x, cp1.y);\r\n                        }\r\n                        cp.x = cp1.x;\r\n                        cp.y = cp1.y;\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'l':\r\n                        relative = true;\r\n                    case 'L':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n\r\n                            path.line(cp1.x, cp1.y);\r\n\r\n                            cp.x = cp1.x;\r\n                            cp.y = cp1.y;\r\n                            this.Advance();\r\n                        }\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'h':\r\n                        relative = true;\r\n                    case 'H':\r\n                        var x = this.ParseDouble();\r\n                        if (x == null)\r\n                            break;\r\n\r\n                        if (relative)\r\n                            x += cp.x;\r\n                        cp = new Point(x, cp.y);\r\n\r\n                        path.line(cp.x, cp.y);\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'v':\r\n                        relative = true;\r\n                    case 'V':\r\n                        var y = this.ParseDouble();\r\n                        if (y == null)\r\n                            break;\r\n\r\n                        if (relative)\r\n                            y += cp.y;\r\n                        cp = new Point(cp.x, y);\r\n\r\n                        path.line(cp.x, cp.y);\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'c':\r\n                        relative = true;\r\n                    case 'C':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp3 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp3.x += cp.x;\r\n                                cp3.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n\r\n                            path.cubicBezier(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\r\n\r\n                            cp1.x = cp3.x;\r\n                            cp1.y = cp3.y;\r\n                        }\r\n                        cp.x = cp3.x;\r\n                        cp.y = cp3.y;\r\n                        cbz = true;\r\n                        cbzp.x = cp2.x;\r\n                        cbzp.y = cp2.y;\r\n                        qbz = false;\r\n                        break;\r\n                    case 's':\r\n                        relative = true;\r\n                    case 'S':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp3 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp3.x += cp.x;\r\n                                cp3.y += cp.y;\r\n                            }\r\n\r\n                            if (cbz) {\r\n                                cp1.x = 2 * cp.x - cbzp.x;\r\n                                cp1.y = 2 * cp.y - cbzp.y;\r\n                            } else\r\n                                cp1 = cp;\r\n\r\n                            path.cubicBezier(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\r\n\r\n                            cbz = true;\r\n                            cbzp.x = cp2.x;\r\n                            cbzp.y = cp2.y;\r\n\r\n                            cp.x = cp3.x;\r\n                            cp.y = cp3.y;\r\n\r\n                            this.Advance();\r\n                        }\r\n                        qbz = false;\r\n                        break;\r\n                    case 'q':\r\n                        relative = true;\r\n                    case 'Q':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n\r\n                            path.quadraticBezier(cp1.x, cp1.y, cp2.x, cp2.y);\r\n\r\n                            cp.x = cp2.x;\r\n                            cp.y = cp2.y;\r\n                        }\r\n                        qbz = true;\r\n                        qbzp.x = cp1.x;\r\n                        qbzp.y = cp1.y;\r\n                        cbz = false;\r\n                        break;\r\n                    case 't':\r\n                        relative = true;\r\n                    case 'T':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n\r\n                            if (qbz) {\r\n                                cp1.x = 2 * cp.x - qbzp.x;\r\n                                cp1.y = 2 * cp.y - qbzp.y;\r\n                            } else\r\n                                cp1 = cp;\r\n\r\n                            path.quadraticBezier(cp1.x, cp1.y, cp2.x, cp2.y);\r\n\r\n                            qbz = true;\r\n                            qbzp.x = cp1.x;\r\n                            qbzp.y = cp1.y;\r\n\r\n                            cp.x = cp2.x;\r\n                            cp.y = cp2.y;\r\n\r\n                            this.Advance();\r\n                        }\r\n                        cbz = false;\r\n                        break;\r\n                    case 'a':\r\n                        relative = true;\r\n                    case 'A':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n\r\n                            var angle = this.ParseDouble();\r\n                            var is_large = this.ParseDouble() !== 0;\r\n                            var sweep = minerva.SweepDirection.Counterclockwise;\r\n                            if (this.ParseDouble() !== 0) sweep = minerva.SweepDirection.Clockwise;\r\n\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n\r\n                            path.ellipticalArc(cp1.x, cp1.y, angle, is_large, sweep, cp2.x, cp2.y);\r\n\r\n                            cp.x = cp2.x;\r\n                            cp.y = cp2.y;\r\n\r\n                            this.Advance();\r\n                        }\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'z':\r\n                    case 'Z':\r\n                        //path.Line(start.x, start.y);\r\n                        path.close();\r\n                        //path.Move(start.x, start.y);\r\n\r\n                        cp.x = start.x;\r\n                        cp.y = start.y;\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            var pg = new PathGeometry();\r\n            pg.OverridePath(path);\r\n            pg.FillRule = <Shapes.FillRule>fillRule;\r\n            return pg;\r\n        }\r\n        */\r\n\r\n        /*\r\n        private ParsePoint (): Point {\r\n            var x = this.ParseDouble();\r\n            if (x == null)\r\n                return null;\r\n\r\n            var c;\r\n            while (this.index < this.len && ((c = this.str.charAt(this.index)) === ' ' || c === ',')) {\r\n                this.index++;\r\n            }\r\n            if (this.index >= this.len)\r\n                return null;\r\n\r\n            var y = this.ParseDouble();\r\n            if (y == null)\r\n                return null;\r\n\r\n            return new Point(x, y);\r\n        }\r\n        */\r\n\r\n        ParseDouble (): number {\r\n            this.Advance();\r\n            var isNegative = false;\r\n            if (this.Match('-')) {\r\n                isNegative = true;\r\n                this.index++;\r\n            } else if (this.Match('+')) {\r\n                this.index++;\r\n            }\r\n            if (this.Match('Infinity')) {\r\n                this.index += 8;\r\n                return isNegative ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\r\n            }\r\n            if (this.Match('NaN'))\r\n                return NaN;\r\n\r\n            var temp = '';\r\n            while (this.index < this.len) {\r\n                var code = this.str.charCodeAt(this.index);\r\n                var c = this.str[this.index];\r\n                //0-9, ., E, e, E-, e-\r\n                if (code >= 48 && code <= 57)\r\n                    temp += c;\r\n                else if (code === 46)\r\n                    temp += c;\r\n                else if (c === 'E' || c === 'e') {\r\n                    temp += c;\r\n                    if (this.str[this.index + 1] === '-') {\r\n                        temp += '-';\r\n                        this.index++;\r\n                    }\r\n                }\r\n                else\r\n                    break;\r\n                this.index++;\r\n            }\r\n            if (temp.length === 0)\r\n                return null;\r\n            var f = parseFloat(temp);\r\n            return isNegative ? -f : f;\r\n        }\r\n\r\n        private Match (matchStr: string): boolean {\r\n            var c1: string;\r\n            var c2: string;\r\n            for (var i = 0; i < matchStr.length && (this.index + i) < this.len; i++) {\r\n                c1 = matchStr.charAt(i);\r\n                c2 = this.str.charAt(this.index + i);\r\n                if (c1 !== c2)\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        private Advance () {\r\n            var code: number;\r\n            var c: string;\r\n            while (this.index < this.len) {\r\n                code = this.str.charCodeAt(this.index);\r\n                //alphanum\r\n                if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122) || (code >= 48 && code <= 57))\r\n                    break;\r\n                c = String.fromCharCode(code);\r\n                if (c === '.')\r\n                    break;\r\n                if (c === '-')\r\n                    break;\r\n                if (c === '+')\r\n                    break;\r\n                this.index++;\r\n            }\r\n        }\r\n\r\n        private MorePointsAvailable (): boolean {\r\n            var c;\r\n            while (this.index < this.len && ((c = this.str.charAt(this.index)) === ',' || c === ' ')) {\r\n                this.index++;\r\n            }\r\n            if (this.index >= this.len)\r\n                return false;\r\n            if (c === '.' || c === '-' || c === '+')\r\n                return true;\r\n            var code = this.str.charCodeAt(this.index);\r\n            return code >= 48 && code <= 57;\r\n        }\r\n    }\r\n}","namespace path2d {\r\n    export interface IPathOp {\r\n        type: PathOpType;\r\n        args: any[];\r\n    }\r\n    export enum PathOpType {\r\n        closePath,\r\n        moveTo,\r\n        lineTo,\r\n        bezierCurveTo,\r\n        quadraticCurveTo,\r\n        arc,\r\n        arcTo,\r\n        ellipse,\r\n        rect,\r\n    }\r\n\r\n    export class Path2DEx implements Path2D {\r\n        private $ops: IPathOp[];\r\n\r\n        constructor ();\r\n        constructor (path: Path2D);\r\n        constructor (d: string);\r\n        constructor (arg0?: string|Path2D) {\r\n            if (arg0 instanceof <any>Path2D) {\r\n                this.$ops = JSON.parse(JSON.stringify(this.$ops));\r\n            } else if (typeof arg0 === \"string\") {\r\n                this.$ops = [];\r\n                Path2DEx.parse.call(this, arg0);\r\n            } else {\r\n                this.$ops = [];\r\n            }\r\n        }\r\n\r\n        addPath (path: Path2D, transform?: SVGMatrix) {\r\n\r\n        }\r\n\r\n        closePath () {\r\n            this.$ops.push({\r\n                type: PathOpType.closePath,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        moveTo (x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.moveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        lineTo (x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.lineTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        bezierCurveTo (cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.bezierCurveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        quadraticCurveTo (cpx: number, cpy: number, x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.quadraticCurveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        arc (x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n            this.$ops.push({\r\n                type: PathOpType.arc,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        arcTo (x1: number, y1: number, x2: number, y2: number, radius: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.arcTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        ellipse (x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n            this.$ops.push({\r\n                type: PathOpType.ellipse,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        rect (x: number, y: number, width: number, height: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.rect,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        static parse (d: string): Path2D {\r\n            throw new Error(\"Not implemented\");\r\n        }\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\n(function (global: any) {\r\n    if (typeof Path2D === \"function\") {\r\n        global.Path2D.parse = global.path2d.Path2DEx.parse;\r\n    } else {\r\n        global.Path2D = global.path2d.Path2DEx;\r\n    }\r\n})(this);","namespace path2d {\r\n    export function parseNumber(tracker: IParseTracker): number {\r\n        var start = tracker.offset;\r\n        var data = tracker.data;\r\n        var len = data.length;\r\n        //NaN\r\n        if (isNaN(data, tracker.offset)) {\r\n            tracker.offset += 3;\r\n            return NaN;\r\n        }\r\n\r\n        //Check - or +\r\n        var negate = false;\r\n        if (data[tracker.offset] === 0x2D) {\r\n            negate = true;\r\n            tracker.offset++;\r\n        } else if (data[tracker.offset] === 0x2B) {\r\n            tracker.offset++;\r\n        }\r\n\r\n        //Infinity\r\n        if (isInfinity(data, tracker.offset)) {\r\n            tracker.offset += 8;\r\n            return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\r\n        }\r\n\r\n        //(characteristic)[.(mantissa)][Ee[+-](significand)]\r\n        parseInteger(tracker);\r\n        var cur = data[tracker.offset];\r\n        if (cur === 0x2E) { // '.'\r\n            tracker.offset++;\r\n            if (!parseMantissa(tracker))\r\n                throw new Error(\"Invalid number\");\r\n        }\r\n\r\n        if (!parseSignificand(tracker))\r\n            throw new Error(\"Invalid number\");\r\n\r\n        return parseFloat(getSlice(data, start, tracker.offset - start));\r\n    }\r\n\r\n    function isNaN(data: Uint8Array, i: number): boolean {\r\n        return data[i + 0] === 0x4E //N\r\n            && data[i + 1] === 0x61 //a\r\n            && data[i + 2] === 0x4E //N\r\n            ;\r\n    }\r\n\r\n    function isInfinity(data: Uint8Array, i: number): boolean {\r\n        return data[i + 0] === 0x49 //I\r\n            && data[i + 1] === 0x6E //n\r\n            && data[i + 2] === 0x66 //f\r\n            && data[i + 3] === 0x69 //i\r\n            && data[i + 4] === 0x6E //n\r\n            && data[i + 5] === 0x69 //i\r\n            && data[i + 6] === 0x74 //t\r\n            && data[i + 7] === 0x79 //y\r\n            ;\r\n    }\r\n\r\n    function parseInteger(tracker: IParseTracker): boolean {\r\n        var start = tracker.offset;\r\n        var data = tracker.data;\r\n        var cur: number;\r\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\r\n            tracker.offset++;\r\n        }\r\n        return tracker.offset !== start;\r\n    }\r\n\r\n    function parseMantissa(tracker: IParseTracker): boolean {\r\n        var start = tracker.offset;\r\n        var data = tracker.data;\r\n        var cur: number;\r\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\r\n            tracker.offset++;\r\n        }\r\n        return tracker.offset !== start;\r\n    }\r\n\r\n    function parseSignificand(tracker: IParseTracker): boolean {\r\n        var data = tracker.data;\r\n        if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\r\n            return true;\r\n        tracker.offset++;\r\n\r\n        var cur = data[tracker.offset];\r\n        if (cur === 0x2D || cur === 0x2B) // '-' '+'\r\n            tracker.offset++;\r\n        return parseInteger(tracker);\r\n    }\r\n\r\n    function getSlice(data: Uint8Array, offset: number, length: number): string {\r\n        var buf = new Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            buf[i] = data[offset + i];\r\n        }\r\n        return String.fromCharCode.apply(null, buf);\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\nnamespace path2d {\r\n    Path2DEx.parse = function (d: string): Path2D {\r\n        if (this instanceof Path2D)\r\n            return doParse(this, d);\r\n        return doParse(new Path2DEx(), d);\r\n    };\r\n\r\n    export interface IParseTracker {\r\n        data: Uint8Array;\r\n        offset: number;\r\n    }\r\n    function doParse(path: Path2D, d: string): Path2D {\r\n        var data = toBuffer(d);\r\n        var i = 0;\r\n        var len = data.length;\r\n\r\n        //TODO: Implement\r\n\r\n        return path;\r\n    }\r\n\r\n    function toBuffer(d: string): Uint8Array {\r\n        if (typeof TextEncoder === \"function\") {\r\n            return new TextEncoder().encode(d);\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}