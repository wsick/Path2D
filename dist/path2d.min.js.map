{"version":3,"sources":["_version.ts","Path2DEx.ts","Path2D_parse.ts","parser.ts"],"names":["path2d","path2d.Path2DEx","path2d.Path2DEx.constructor","path2d.Path2DEx.parse","global","Path2D","parse","Path2DEx","this","existing","doParse","d"],"mappings":"AAAA,GAAUA,SAAV,SAAUA,GACKA,EAAAA,QAAUA,SADfA,SAAAA,WCAV,IAAUA,SAAV,SAAUA,GACNA,GAAAA,GAAAA,WAIIC,QAAAA,GAAaA,GACLC,YAAqBA,SAEEA,gBAATA,IACdA,EAASA,MAAMA,KAAKA,KAAMA,GAiDtCD,MA3CIA,GAAAA,UAAAA,QAAAA,SAASA,EAAcA,KAIvBA,EAAAA,UAAAA,UAAAA,aAIAA,EAAAA,UAAAA,OAAAA,SAAQA,EAAWA,KAInBA,EAAAA,UAAAA,OAAAA,SAAQA,EAAWA,KAInBA,EAAAA,UAAAA,cAAAA,SAAeA,EAAcA,EAAcA,EAAcA,EAAcA,EAAWA,KAIlFA,EAAAA,UAAAA,iBAAAA,SAAkBA,EAAaA,EAAaA,EAAWA,KAIvDA,EAAAA,UAAAA,IAAAA,SAAKA,EAAWA,EAAWA,EAAgBA,EAAoBA,EAAkBA,KAIjFA,EAAAA,UAAAA,MAAAA,SAAOA,EAAYA,EAAYA,EAAYA,EAAYA,KAIvDA,EAAAA,UAAAA,QAAAA,SAASA,EAAWA,EAAWA,EAAiBA,EAAiBA,EAAkBA,EAAoBA,EAAkBA,KAIzHA,EAAAA,UAAAA,KAAAA,SAAMA,EAAWA,EAAWA,EAAeA,KAIpCA,EAAAA,MAAPA,SAAcA,GACVE,KAAMA,IAAIA,OAAMA,oBAExBF,IAzDaD,GAAAA,SAAQA,GADfA,SAAAA,YCEV,SAAWI,GACe,kBAAXC,QACPD,EAAOC,OAAOC,MAAQF,EAAOG,SAASD,MAEtCF,EAAOC,OAASD,EAAOG,UAE5BC,KCNH,IAAUR,SAAV,SAAUA,GAYNA,QAAAA,GAAkBA,EAAcA,IAXhCA,EAAAA,SAASA,MAAQA,SAAUA,GACvB,GAAIS,EAOJ,OALIA,GADAD,eAAgBH,QACLG,KAEA,GAAIR,GAAAO,SAEnBG,EAAQD,EAAUE,GACXF,IATLT,SAAAA","file":"path2d.min.js","sourcesContent":["namespace path2d {\r\n    export var version = '0.1.0';\r\n}","namespace path2d {\r\n    export class Path2DEx implements Path2D {\r\n        constructor ();\r\n        constructor (path: Path2D);\r\n        constructor (d: string);\r\n        constructor (arg0?: string|Path2D) {\r\n            if (arg0 instanceof <any>Path2D) {\r\n                //TODO: copyTo(<any>arg0, this);\r\n            } else if (typeof arg0 === \"string\") {\r\n                Path2DEx.parse.call(this, arg0);\r\n            } else {\r\n                //TODO: Initialize\r\n            }\r\n        }\r\n\r\n        addPath (path: Path2D, transform?: SVGMatrix) {\r\n\r\n        }\r\n\r\n        closePath () {\r\n\r\n        }\r\n\r\n        moveTo (x: number, y: number) {\r\n\r\n        }\r\n\r\n        lineTo (x: number, y: number) {\r\n\r\n        }\r\n\r\n        bezierCurveTo (cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\r\n\r\n        }\r\n\r\n        quadraticCurveTo (cpx: number, cpy: number, x: number, y: number) {\r\n\r\n        }\r\n\r\n        arc (x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n\r\n        }\r\n\r\n        arcTo (x1: number, y1: number, x2: number, y2: number, radius: number) {\r\n\r\n        }\r\n\r\n        ellipse (x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n\r\n        }\r\n\r\n        rect (x: number, y: number, width: number, height: number) {\r\n\r\n        }\r\n\r\n        static parse (d: string): Path2D {\r\n            throw new Error(\"Not implemented\");\r\n        }\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\n(function (global: any) {\r\n    if (typeof Path2D === \"function\") {\r\n        global.Path2D.parse = global.Path2DEx.parse;\r\n    } else {\r\n        global.Path2D = global.Path2DEx;\r\n    }\r\n})(this);","/// <reference path=\"Path2DEx\" />\r\n\r\nnamespace path2d {\r\n    Path2DEx.parse = function (d: string): Path2D {\r\n        var existing: Path2D;\r\n        if (this instanceof Path2D) {\r\n            existing = this;\r\n        } else {\r\n            existing = new Path2DEx();\r\n        }\r\n        doParse(existing, d);\r\n        return existing;\r\n    };\r\n\r\n    function doParse (path: Path2D, d: string) {\r\n        //TODO: Implement\r\n    }\r\n}"],"sourceRoot":"/source/"}