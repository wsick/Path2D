{"version":3,"sources":["_version.ts","polyfills/CanvasRenderingContext2D_drawPath.ts","polyfills/CanvasRenderingContext2D_ellipse.ts","polyfills/CanvasRenderingContext2D_exts.ts","polyfills/TextEncoder.ts","Path2DEx.ts","Path2D_parse.ts","parseNumber.ts","parser.ts"],"names":["path2d","this","beginPath","i","ops","path","$ops","len","length","op","name_1","PathOpType","type","func","CanvasRenderingContext2D","prototype","Error","apply","args","save","translate","x","y","rotate","rotation","scale","radiusX","radiusY","arc","startAngle","endAngle","antiClockwise","restore","arg","Path2D","drawPath","_fill","Array","slice","call","arguments","_stroke","_clip","global","TextEncoder","Object","defineProperty","value","writable","encode","str","path2d.PathOpType","path2d.Path2DEx","path2d.Path2DEx.constructor","path2d.Path2DEx.closePath","path2d.Path2DEx.moveTo","path2d.Path2DEx.lineTo","path2d.Path2DEx.bezierCurveTo","path2d.Path2DEx.quadraticCurveTo","path2d.Path2DEx.arc","path2d.Path2DEx.arcTo","path2d.Path2DEx.ellipse","path2d.Path2DEx.rect","path2d.Path2DEx.parse","parse","Path2DEx","path2d.parseNumber","path2d.isNaN","path2d.isInfinity","path2d.parseInteger","path2d.parseMantissa","path2d.parseSignificand","path2d.doParse","path2d.toBuffer","doParse","d"],"mappings":"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","file":"path2d.min.js","sourcesContent":["namespace path2d {\r\n    export var version = '0.1.0';\r\n}",null,null,null,null,"namespace path2d {\r\n    export interface IPathOp {\r\n        type: PathOpType;\r\n        args: any[];\r\n    }\r\n    export enum PathOpType {\r\n        closePath,\r\n        moveTo,\r\n        lineTo,\r\n        bezierCurveTo,\r\n        quadraticCurveTo,\r\n        arc,\r\n        arcTo,\r\n        ellipse,\r\n        rect,\r\n    }\r\n\r\n    export class Path2DEx implements Path2D {\r\n        private $ops: IPathOp[];\r\n\r\n        constructor ();\r\n        constructor (path: Path2D);\r\n        constructor (d: string);\r\n        constructor (arg0?: string|Path2D) {\r\n            if (arg0 instanceof <any>Path2D) {\r\n                this.$ops = JSON.parse(JSON.stringify(this.$ops));\r\n            } else if (typeof arg0 === \"string\") {\r\n                this.$ops = [];\r\n                Path2DEx.parse.call(this, arg0);\r\n            } else {\r\n                this.$ops = [];\r\n            }\r\n        }\r\n\r\n        addPath (path: Path2D, transform?: SVGMatrix) {\r\n\r\n        }\r\n\r\n        closePath () {\r\n            this.$ops.push({\r\n                type: PathOpType.closePath,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        moveTo (x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.moveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        lineTo (x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.lineTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        bezierCurveTo (cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.bezierCurveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        quadraticCurveTo (cpx: number, cpy: number, x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.quadraticCurveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        arc (x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n            this.$ops.push({\r\n                type: PathOpType.arc,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        arcTo (x1: number, y1: number, x2: number, y2: number, radius: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.arcTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        ellipse (x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n            this.$ops.push({\r\n                type: PathOpType.ellipse,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        rect (x: number, y: number, width: number, height: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.rect,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        static parse (d: string): Path2D {\r\n            throw new Error(\"Not implemented\");\r\n        }\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\n(function (global: any) {\r\n    if (typeof Path2D === \"function\") {\r\n        global.Path2D.parse = global.path2d.Path2DEx.parse;\r\n    } else {\r\n        global.Path2D = global.path2d.Path2DEx;\r\n    }\r\n})(this);","namespace path2d {\r\n    export function parseNumber(tracker: IParseTracker): number {\r\n        var data = tracker.data;\r\n        var len = data.length;\r\n        //NaN\r\n        if (isNaN(data, tracker.offset)) {\r\n            tracker.offset += 3;\r\n            return NaN;\r\n        }\r\n\r\n        //Check - or +\r\n        var negate = false;\r\n        if (data[tracker.offset] === 0x2D) {\r\n            negate = true;\r\n            tracker.offset++;\r\n        } else if (data[tracker.offset] === 0x2B) {\r\n            tracker.offset++;\r\n        }\r\n\r\n        //Infinity\r\n        if (isInfinity(data, tracker.offset)) {\r\n            tracker.offset += 8;\r\n            return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\r\n        }\r\n\r\n        //(characteristic)[.(mantissa)][Ee[+-](significand)]\r\n        var characteristic = parseInteger(tracker);\r\n        var cur = data[tracker.offset];\r\n        var mantissa = 0;\r\n        if (cur === 0x2E) { // '.'\r\n            mantissa = parseMantissa(tracker);\r\n        } else if (cur !== 0x45 && cur !== 0x65) { // 'E' 'e'\r\n            return negate ? -characteristic : characteristic;\r\n        }\r\n        var significand = parseSignificand(tracker);\r\n\r\n        var num = negate ? -characteristic - mantissa : characteristic + mantissa;\r\n        num = num * Math.pow(10, significand);\r\n        return num;\r\n    }\r\n\r\n    function isNaN(data: Uint8Array, i: number): boolean {\r\n        return data[i + 0] === 0x4E //N\r\n            && data[i + 1] === 0x61 //a\r\n            && data[i + 2] === 0x4E //N\r\n            ;\r\n    }\r\n\r\n    function isInfinity(data: Uint8Array, i: number): boolean {\r\n        return data[i + 0] === 0x49 //I\r\n            && data[i + 1] === 0x6E //n\r\n            && data[i + 2] === 0x66 //f\r\n            && data[i + 3] === 0x69 //i\r\n            && data[i + 4] === 0x6E //n\r\n            && data[i + 5] === 0x69 //i\r\n            && data[i + 6] === 0x74 //t\r\n            && data[i + 7] === 0x79 //y\r\n            ;\r\n    }\r\n\r\n    function parseInteger(tracker: IParseTracker): number {\r\n        return 0;\r\n    }\r\n\r\n    function parseMantissa(tracker: IParseTracker): number {\r\n        return 0;\r\n    }\r\n\r\n    function parseSignificand(tracker: IParseTracker): number {\r\n        var data = tracker.data;\r\n        if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\r\n            return 0;\r\n        tracker.offset++;\r\n\r\n        if (data[tracker.offset] === 0x2D) { // '-'\r\n            tracker.offset++;\r\n            return -parseInteger(tracker);\r\n        } else {\r\n            return parseInteger(tracker);\r\n        }\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\nnamespace path2d {\r\n    Path2DEx.parse = function (d: string): Path2D {\r\n        if (this instanceof Path2D)\r\n            return doParse(this, d);\r\n        return doParse(new Path2DEx(), d);\r\n    };\r\n\r\n    export interface IParseTracker {\r\n        data: Uint8Array;\r\n        offset: number;\r\n    }\r\n    function doParse(path: Path2D, d: string): Path2D {\r\n        var data = toBuffer(d);\r\n        var i = 0;\r\n        var len = data.length;\r\n\r\n        //TODO: Implement\r\n\r\n        return path;\r\n    }\r\n\r\n    function toBuffer(d: string): Uint8Array {\r\n        if (typeof TextEncoder === \"function\") {\r\n            return new TextEncoder().encode(d);\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}