{"version":3,"sources":["_version.ts","bounds/extenders/Arc.ts","bounds/extenders/LineTo.ts","bounds/extenders/ArcTo.ts","bounds/extenders/BezierCurveTo.ts","bounds/extenders/ClosePath.ts","bounds/extenders/Ellipse.ts","bounds/extenders/MoveTo.ts","bounds/extenders/QuadraticCurveTo.ts","bounds/ExtenderSelector.ts","bounds/fill/FillBounds.ts","IStrokeParameters.ts","bounds/stroke/extendEndCap.ts","bounds/stroke/extendLineJoin.ts","bounds/stroke/extendStartCap.ts","bounds/stroke/StartCapExtender.ts","bounds/stroke/StrokeBounds.ts","compiler/compile.ts","compiler/decompile.ts","compiler/ICompiledSegment.ts","ellipticalArc/fromEllipse.ts","ellipticalArc/radii.ts","ellipticalArc/toEllipse.ts","curve.js","ISegmentExecutor.ts","parse/buffer/parser.ts","parse/dom/parser.ts","parse/ParseTypes.ts","parse/IParser.ts","parse/matching/parser.ts","Path.ts","polyfills/CanvasRenderingContext2D_ellipse.ts","polyfills/CanvasRenderingContext2D_setFillRule.ts","polyfills/TextEncoder.ts","serialize.ts"],"names":["curve","curve.bounds","curve.bounds.extenders","curve.bounds.extenders.getStartVector","curve.bounds.extenders.getEndVector","curve.bounds.extenders.arcContainsPoint","curve.bounds.extenders.getCapSpread","curve.bounds.extenders.Arc","curve.bounds.extenders.Arc.constructor","curve.bounds.extenders.Arc.init","curve.bounds.extenders.Arc.extendFillBox","curve.bounds.extenders.Arc.extendStrokeBox","curve.bounds.extenders.LineTo","curve.bounds.extenders.LineTo.constructor","curve.bounds.extenders.LineTo.init","curve.bounds.extenders.LineTo.extendFillBox","curve.bounds.extenders.LineTo.extendStrokeBox","curve.bounds.extenders.createLine","curve.bounds.extenders.createArc","curve.bounds.extenders.getTangentPoint","curve.bounds.extenders.getPerpendicularIntersections","curve.bounds.extenders.ArcTo","curve.bounds.extenders.ArcTo.constructor","curve.bounds.extenders.ArcTo.init","curve.bounds.extenders.ArcTo.extendFillBox","curve.bounds.extenders.ArcTo.extendStrokeBox","curve.bounds.extenders.getMaxima","curve.bounds.extenders.cod","curve.bounds.extenders.BezierCurveTo","curve.bounds.extenders.BezierCurveTo.constructor","curve.bounds.extenders.BezierCurveTo.init","curve.bounds.extenders.BezierCurveTo.extendFillBox","curve.bounds.extenders.BezierCurveTo.extendStrokeBox","curve.bounds.extenders.ClosePath","curve.bounds.extenders.ClosePath.constructor","curve.bounds.extenders.ClosePath.init","curve.bounds.extenders.Ellipse","curve.bounds.extenders.Ellipse.constructor","curve.bounds.extenders.Ellipse.init","curve.bounds.extenders.Ellipse.extendFillBox","curve.bounds.extenders.Ellipse.extendStrokeBox","curve.bounds.extenders.MoveTo","curve.bounds.extenders.MoveTo.constructor","curve.bounds.extenders.MoveTo.init","curve.bounds.extenders.MoveTo.extendFillBox","curve.bounds.extenders.MoveTo.extendStrokeBox","curve.bounds.extenders.QuadraticCurveTo","curve.bounds.extenders.QuadraticCurveTo.constructor","curve.bounds.extenders.QuadraticCurveTo.init","curve.bounds.extenders.QuadraticCurveTo.extendFillBox","curve.bounds.extenders.QuadraticCurveTo.extendStrokeBox","curve.bounds.ExtenderSelector","curve.bounds.ExtenderSelector.closePath","curve.bounds.ExtenderSelector.moveTo","curve.bounds.ExtenderSelector.lineTo","curve.bounds.ExtenderSelector.bezierCurveTo","curve.bounds.ExtenderSelector.quadraticCurveTo","curve.bounds.ExtenderSelector.arc","curve.bounds.ExtenderSelector.arcTo","curve.bounds.ExtenderSelector.ellipse","curve.bounds.fill","curve.bounds.fill.FillBounds","curve.bounds.fill.FillBounds.constructor","curve.bounds.fill.FillBounds.reset","curve.bounds.fill.FillBounds.ensure","curve.bounds.fill.FillBounds.calculate","curve.PenLineCap","curve.PenLineJoin","curve.bounds.stroke","curve.bounds.stroke.extendEndCap","_a","metrics","endPoint","ex","ey","hs","thickness","box","l","Math","min","r","max","t","b","ed","vec2","clone","endVector","normalize","edo","orthogonal","x1","x2","y1","y2","curve.bounds.stroke.extendLineJoin","curve.bounds.stroke.findMiterTips","curve.bounds.stroke.findBevelTips","curve.bounds.stroke.extendStartCap","sx","sy","sd","startVector","reverse","sdo","curve.bounds.stroke.StartCapExtender","curve.bounds.stroke.StrokeBounds","curve.bounds.stroke.StrokeBounds.constructor","curve.bounds.stroke.StrokeBounds.reset","curve.bounds.stroke.StrokeBounds.ensure","curve.bounds.stroke.StrokeBounds.calculate","curve.compiler","curve.compiler.compile","curve.compiler.PathCompiler","curve.compiler.PathCompiler.constructor","curve.compiler.PathCompiler.setFillRule","curve.compiler.PathCompiler.closePath","curve.compiler.PathCompiler.moveTo","curve.compiler.PathCompiler.lineTo","curve.compiler.PathCompiler.bezierCurveTo","curve.compiler.PathCompiler.quadraticCurveTo","curve.compiler.PathCompiler.arc","curve.compiler.PathCompiler.arcTo","curve.compiler.PathCompiler.ellipse","curve.compiler.decompile","CompiledOpType","curve.ellipticalArc","curve.ellipticalArc.fromEllipse","curve.ellipticalArc.correctRadii","curve.ellipticalArc.toEllipse","curve.ellipticalArc.signAdjust","FillRule","SweepDirection","curve.parse","curve.parse.buffer","curve.parse.buffer.parseNumber","curve.parse.buffer.toBuffer","curve.parse.buffer.isNaN","curve.parse.buffer.isInfinity","curve.parse.buffer.parseInteger","curve.parse.buffer.parseMantissa","curve.parse.buffer.parseSignificand","curve.parse.buffer.getSlice","curve.parse.buffer.Parser","curve.parse.buffer.Parser.parse","curve.parse.dom","curve.parse.dom.parseSegment","curve.parse.dom.smoothCubic","curve.parse.dom.smoothQuadratic","curve.parse.dom.Parser","curve.parse.dom.Parser.parse","curve.parse.ParseStyles","curve.parse.getParser","curve.parse.matching","curve.parse.matching.parse","curve.parse.matching.parse.go","curve.parse.matching.parse.parsePoint","curve.parse.matching.parse.parseDouble","curve.parse.matching.parse.advance","curve.parse.matching.parse.match","curve.parse.matching.parse.morePointsAvailable","curve.parse.matching.Parser","curve.parse.matching.Parser.parse","curve.Path","curve.Path.constructor","get","curve.Path.isEmpty","enumerable","configurable","curve.Path.reset","curve.Path.exec","curve.Path.draw","curve.Path.addPath","curve.Path.setFillRule","curve.Path.closePath","curve.Path.moveTo","curve.Path.lineTo","curve.Path.bezierCurveTo","curve.Path.quadraticCurveTo","curve.Path.arc","curve.Path.arcTo","curve.Path.ellipse","curve.Path.parse","this","save","translate","x","y","rotate","rotation","scale","radiusX","radiusY","arc","startAngle","endAngle","antiClockwise","restore","fillRule","arg","global","TextEncoder","constructor","prototype","encode","str","curve.serialize","curve.close","curve.round","curve.Serializer","curve.Serializer.constructor","curve.Serializer.setFillRule","curve.Serializer.closePath","curve.Serializer.moveTo","curve.Serializer.lineTo","curve.Serializer.bezierCurveTo","curve.Serializer.quadraticCurveTo","curve.Serializer.ellipse","curve.Serializer.prepend"],"mappings":"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","file":"curve.min.js","sourcesContent":["namespace curve {\n    export var version = '0.1.4';\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export interface IArcMetrics extends ISegmentMetrics {\n        sx: number;\n        sy: number;\n        l: number;\n        cl: boolean;\n        r: number;\n        cr: boolean;\n        t: number;\n        ct: boolean;\n        b: number;\n        cb: boolean;\n    }\n\n    export class Arc implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): IArcMetrics {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n\n            sx = x + (radius * Math.cos(sa));\n            sy = y + (radius * Math.sin(sa));\n            var ex = x + (radius * Math.cos(ea));\n            var ey = y + (radius * Math.sin(ea));\n\n            var l = x - radius;\n            var cl = arcContainsPoint(sx, sy, ex, ey, l, y, cc);\n\n            var r = x + radius;\n            var cr = arcContainsPoint(sx, sy, ex, ey, r, y, cc);\n\n            var t = y - radius;\n            var ct = arcContainsPoint(sx, sy, ex, ey, x, t, cc);\n\n            var b = y + radius;\n            var cb = arcContainsPoint(sx, sy, ex, ey, x, b, cc);\n\n            return {\n                sx: sx,\n                sy: sy,\n                l: l,\n                cl: cl,\n                r: r,\n                cr: cr,\n                t: t,\n                ct: ct,\n                b: b,\n                cb: cb,\n                endPoint: vec2.create(ex, ey),\n                startVector: getStartVector(x, y, cc, sx, sy),\n                endVector: getEndVector(x, y, cc, ex, ey)\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcMetrics) {\n            var sa = args[3];\n            var ea = args[4];\n            if (ea === sa)\n                return;\n\n            var ep = metrics.endPoint,\n                ex = ep[0],\n                ey = ep[1];\n            box.l = Math.min(box.l, sx, ex);\n            box.r = Math.max(box.r, sx, ex);\n            box.t = Math.min(box.t, sy, ey);\n            box.b = Math.max(box.b, sy, ey);\n\n            if (metrics.cl)\n                box.l = Math.min(box.l, metrics.l);\n            if (metrics.cr)\n                box.r = Math.max(box.r, metrics.r);\n            if (metrics.ct)\n                box.t = Math.min(box.t, metrics.t);\n            if (metrics.cb)\n                box.b = Math.max(box.b, metrics.b);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcMetrics, pars: IStrokeParameters) {\n            var sa = args[3];\n            var ea = args[4];\n            if (ea === sa)\n                return;\n\n            var ep = metrics.endPoint,\n                ex = ep[0],\n                ey = ep[1];\n            box.l = Math.min(box.l, sx, ex);\n            box.r = Math.max(box.r, sx, ex);\n            box.t = Math.min(box.t, sy, ey);\n            box.b = Math.max(box.b, sy, ey);\n\n            var hs = pars.strokeThickness / 2.0;\n            if (metrics.cl)\n                box.l = Math.min(box.l, metrics.l - hs);\n            if (metrics.cr)\n                box.r = Math.max(box.r, metrics.r + hs);\n            if (metrics.ct)\n                box.t = Math.min(box.t, metrics.t - hs);\n            if (metrics.cb)\n                box.b = Math.max(box.b, metrics.b + hs);\n\n            var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0; //HTML5 doesn't support start and end cap\n            var sv = vec2.reverse(vec2.clone(metrics.startVector));\n            var ss = getCapSpread(sx, sy, pars.strokeThickness, cap, sv);\n            var es = getCapSpread(ex, ey, pars.strokeThickness, cap, metrics.endVector);\n\n            box.l = Math.min(box.l, ss.x1, ss.x2, es.x1, es.x2);\n            box.r = Math.max(box.r, ss.x1, ss.x2, es.x1, es.x2);\n            box.t = Math.min(box.t, ss.y1, ss.y2, es.y1, es.y2);\n            box.b = Math.max(box.b, ss.y1, ss.y2, es.y1, es.y2);\n        }\n    }\n\n    function getStartVector(x: number, y: number, cc: number, sx: number, sy: number): Float32Array {\n        var rx = sx - x,\n            ry = sy - y;\n        if (cc)\n            return vec2.create(ry, -rx);\n        return vec2.create(-ry, rx);\n    }\n\n    function getEndVector(x: number, y: number, cc: number, ex: number, ey: number): Float32Array {\n        var rx = ex - x,\n            ry = ey - y;\n        if (cc)\n            return vec2.create(ry, -rx);\n        return vec2.create(-ry, rx);\n    }\n\n    function arcContainsPoint(sx: number, sy: number, ex: number, ey: number, cpx: number, cpy: number, cc: boolean): boolean {\n        // var a = ex - sx;\n        // var b = cpx - sx;\n        // var c = ey - sy;\n        // var d = cpy - sy;\n        // det = ad - bc;\n        var n = (ex - sx) * (cpy - sy) - (cpx - sx) * (ey - sy);\n        if (n === 0)\n            return true;\n        if (n > 0 && cc)\n            return true;\n        if (n < 0 && !cc)\n            return true;\n        return false;\n    }\n\n    function getCapSpread(x: number, y: number, thickness: number, cap: PenLineCap, vector: Float32Array) {\n        var hs = thickness / 2.0;\n        switch (cap) {\n            case PenLineCap.Round:\n                return {\n                    x1: x - hs,\n                    x2: x + hs,\n                    y1: y - hs,\n                    y2: y + hs\n                };\n                break;\n            case PenLineCap.Square:\n                var ed = vec2.normalize(vec2.clone(vector));\n                var edo = vec2.orthogonal(vec2.clone(ed));\n                return {\n                    x1: x + hs * (ed[0] + edo[0]),\n                    x2: x + hs * (ed[0] - edo[0]),\n                    y1: y + hs * (ed[1] + edo[1]),\n                    y2: y + hs * (ed[1] - edo[1])\n                };\n                break;\n            case PenLineCap.Flat:\n            default:\n                var edo = vec2.orthogonal(vec2.normalize(vec2.clone(vector)));\n                return {\n                    x1: x + hs * edo[0],\n                    x2: x + hs * -edo[0],\n                    y1: y + hs * edo[1],\n                    y2: y + hs * -edo[1]\n                };\n                break;\n        }\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class LineTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var x = args[0];\n            var y = args[1];\n\n            return {\n                startVector: vec2.create(x - sx, y - sy),\n                endVector: vec2.create(x - sx, y - sy),\n                endPoint: vec2.create(x, y)\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var x = args[0];\n            var y = args[1];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            this.extendFillBox(box, sx, sy, args, metrics);\n        }\n    }\n}","/// <reference path=\"LineTo\" />\n/// <reference path=\"Arc\" />\n\nnamespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export interface IArcToMetrics extends ISegmentMetrics {\n        line: {\n            args: any[];\n            metrics: ISegmentMetrics;\n        };\n        arc: {\n            args: any[];\n            metrics: IArcMetrics;\n        };\n    }\n\n    var _arc = new Arc();\n    var _lineTo = new LineTo();\n\n    export class ArcTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): IArcToMetrics {\n            var x1: number = args[0];\n            var y1: number = args[1];\n            var x2: number = args[2];\n            var y2: number = args[3];\n            var radius: number = args[4];\n\n            var v1 = vec2.create(x1 - sx, y1 - sy);\n            var v2 = vec2.create(x2 - x1, y2 - y1);\n            var inner_theta = Math.PI - vec2.angleBetween(v1, v2);\n            //find 2 points tangent to imaginary circle along guide lines\n            var a = getTangentPoint(inner_theta, radius, vec2.create(sx, sy), v1, true);\n            var b = getTangentPoint(inner_theta, radius, vec2.create(x1, y1), v2, false);\n\n            var line = createLine(sx, sy, a[0], a[1]);\n            var arc = createArc(a, v1, b, v2, radius);\n\n            return {\n                line: line,\n                arc: arc,\n                startVector: line.metrics.startVector,\n                endVector: arc.metrics.endVector,\n                endPoint: arc.metrics.endPoint\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcToMetrics) {\n            _lineTo.extendFillBox(box, sx, sy, metrics.line.args, metrics.line.metrics);\n            var ep = metrics.line.metrics.endPoint;\n            _arc.extendFillBox(box, ep[0], ep[1], metrics.arc.args, metrics.arc.metrics);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcToMetrics, pars: IStrokeParameters) {\n            _lineTo.extendStrokeBox(box, sx, sy, metrics.line.args, metrics.line.metrics, pars);\n            var ep = metrics.line.metrics.endPoint;\n            _arc.extendStrokeBox(box, ep[0], ep[1], metrics.arc.args, metrics.arc.metrics, pars);\n        }\n    }\n\n    function createLine(sx: number, sy: number, x: number, y: number) {\n        var args = [x, y];\n        return {\n            args: args,\n            metrics: _lineTo.init(sx, sy, args)\n        };\n    }\n\n    function createArc(a: Float32Array, v1: Float32Array, b: Float32Array, v2: Float32Array, radius: number) {\n        //find center point\n        var c = getPerpendicularIntersections(a, v1, b, v2);\n        //counter clockwise test\n        var cc = !la.vec2.isClockwiseTo(v1, v2);\n        //find starting angle -- [1,0] is origin direction of 0rad\n        var sa = Math.atan2(a[1] - c[1], a[0] - c[0]);\n        if (sa < 0)\n            sa = (2 * Math.PI) + sa;\n        var ea = Math.atan2(b[1] - c[1], b[0] - c[0]);\n        if (ea < 0)\n            ea = (2 * Math.PI) + ea;\n        var args = [c[0], c[1], radius, sa, ea, cc];\n\n        return {\n            args: args,\n            metrics: _arc.init(a[0], a[1], args)\n        };\n    }\n\n    function getTangentPoint(theta: number, radius: number, s: Float32Array, d: Float32Array, invert: boolean): Float32Array {\n        var len = Math.sqrt(d[0] * d[0] + d[1] * d[1]);\n        var f = radius / Math.tan(theta / 2);\n        var t = f / len;\n        if (invert)\n            t = 1 - t;\n        return la.vec2.create(s[0] + t * d[0], s[1] + t * d[1]);\n    }\n\n    function getPerpendicularIntersections(s1: Float32Array, d1: Float32Array, s2: Float32Array, d2: Float32Array): Float32Array {\n        var p1 = vec2.orthogonal(vec2.clone(d1));\n        var p2 = vec2.orthogonal(vec2.clone(d2));\n        return vec2.intersection(s1, p1, s2, p2);\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class BezierCurveTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n\n            return {\n                endPoint: vec2.create(x, y),\n                startVector: vec2.create(3 * (cp1x - sx), 3 * (cp1y - sy)), // [F(0)'x, F(0)'y]\n                endVector: vec2.create(3 * (x - cp2x), 3 * (y - cp2y))      // [F(1)'x, F(1)'y]\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n\n            var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n            if (m.x[0] != null) {\n                box.l = Math.min(box.l, m.x[0]);\n                box.r = Math.max(box.r, m.x[0]);\n            }\n            if (m.x[1] != null) {\n                box.l = Math.min(box.l, m.x[1]);\n                box.r = Math.max(box.r, m.x[1]);\n            }\n            if (m.y[0] != null) {\n                box.t = Math.min(box.t, m.y[0]);\n                box.b = Math.max(box.b, m.y[0]);\n            }\n            if (m.y[1] != null) {\n                box.t = Math.min(box.t, m.y[1]);\n                box.b = Math.max(box.b, m.y[1]);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n            var hs = pars.strokeThickness / 2.0;\n\n            var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n            if (m.x[0] != null) {\n                box.l = Math.min(box.l, m.x[0] - hs);\n                box.r = Math.max(box.r, m.x[0] + hs);\n            }\n            if (m.x[1] != null) {\n                box.l = Math.min(box.l, m.x[1] - hs);\n                box.r = Math.max(box.r, m.x[1] + hs);\n            }\n            if (m.y[0] != null) {\n                box.t = Math.min(box.t, m.y[0] - hs);\n                box.b = Math.max(box.b, m.y[0] + hs);\n            }\n            if (m.y[1] != null) {\n                box.t = Math.min(box.t, m.y[1] - hs);\n                box.b = Math.max(box.b, m.y[1] + hs);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n    }\n\n    //http://pomax.nihongoresources.com/pages/bezier/\n    /* Cubic Bezier curve is defined by parameteric curve:\n     * F(t)x =\n     * F(t)y =\n     * where\n     *  s = start point\n     *  cp1 = control point 1\n     *  cp2 = control point 2\n     *  e = end point\n     *\n     * We find the coordinates (4) where F(t)x/dt = 0, F(t)y/dt = 0\n     * (within the constraints of the curve (0 <= t <= 1)\n     * These points will expand the bounding box\n     */\n\n    interface IMaxima {\n        x: number[];\n        y: number[];\n    }\n    function getMaxima(x1: number, x2: number, x3: number, x4: number, y1: number, y2: number, y3: number, y4: number): IMaxima {\n        return {\n            x: cod(x1, x2, x3, x4),\n            y: cod(y1, y2, y3, y4)\n        };\n    }\n\n    function cod(a: number, b: number, c: number, d: number): number[] {\n        var u = 2 * a - 4 * b + 2 * c;\n        var v = b - a;\n        var w = -a + 3 * b + d - 3 * c;\n        var rt = Math.sqrt(u * u - 4 * v * w);\n\n        var cods: number[] = [null, null];\n        if (isNaN(rt))\n            return cods;\n\n        var t: number,\n            ot: number;\n\n        t = (-u + rt) / (2 * w);\n        if (t >= 0 && t <= 1) {\n            ot = 1 - t;\n            cods[0] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n        }\n\n        t = (-u - rt) / (2 * w);\n        if (t >= 0 && t <= 1) {\n            ot = 1 - t;\n            cods[1] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n        }\n\n        return cods;\n    }\n}","namespace curve.bounds.extenders {\n    export class ClosePath implements IBoundsExtender {\n        isMove = false;\n\n        init(): ISegmentMetrics {\n            return {\n                endPoint: undefined,\n                startVector: undefined,\n                endVector: undefined\n            }\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n        }\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export interface IEllipseMetrics extends ISegmentMetrics {\n        util: la.IEllipse;\n    }\n\n    export class Ellipse implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): IEllipseMetrics {\n            var cx = args[0];\n            var cy = args[1];\n            var rx = args[2];\n            var ry = args[3];\n            var phi = args[4];\n            var sa = args[5];\n            var ea = args[6];\n            var ac = args[7];\n\n            var util = la.ellipse(cx, cy, rx, ry, phi);\n\n            var ep = util.point(ea);\n            var sv = util.tangent(sa);\n            var ev = util.tangent(ea);\n            if (ac == true) {\n                vec2.reverse(sv);\n                vec2.reverse(ev);\n            }\n\n            return {\n                util: util,\n                startVector: sv,\n                endVector: ev,\n                endPoint: ep\n            };\n        }\n\n        extendFillBox(box: curve.bounds.IBoundingBox, sx: number, sy: number, args: any[], metrics: IEllipseMetrics) {\n            var sa = args[5];\n            var ea = args[6];\n            var ac = args[7];\n            var util = metrics.util;\n\n            for (var i = 0, ext = util.extrema(sa, ea, ac); i < ext.length; i++) {\n                let p = ext[i];\n                if (!p)\n                    continue;\n                let x = p[0];\n                let y = p[1];\n                box.l = Math.min(box.l, x);\n                box.r = Math.max(box.r, x);\n                box.t = Math.min(box.t, y);\n                box.b = Math.max(box.b, y);\n            }\n        }\n\n        extendStrokeBox(box: curve.bounds.IBoundingBox, sx: number, sy: number, args: any[], metrics: IEllipseMetrics, pars: curve.IStrokeParameters) {\n            var sa = args[5];\n            var ea = args[6];\n            var ac = args[7];\n            var util = metrics.util;\n            var hs = pars.strokeThickness / 2.0;\n\n            var [vp1, vp2, hp1, hp2] = util.extrema(sa, ea, ac);\n\n            if (vp1) {\n                box.l = Math.min(box.l, vp1[0] - hs);\n                box.r = Math.max(box.r, vp1[0] + hs);\n            }\n            if (vp2) {\n                box.l = Math.min(box.l, vp2[0] - hs);\n                box.r = Math.max(box.r, vp2[0] + hs);\n            }\n\n            if (hp1) {\n                box.t = Math.min(box.t, hp1[1] - hs);\n                box.b = Math.max(box.b, hp1[1] + hs);\n            }\n            if (hp2) {\n                box.t = Math.min(box.t, hp2[1] - hs);\n                box.b = Math.max(box.b, hp2[1] + hs);\n            }\n        }\n    }\n}\n","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class MoveTo implements IBoundsExtender {\n        isMove = true;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var x = args[0];\n            var y = args[1];\n\n            return {\n                startVector: null,\n                endVector: null,\n                endPoint: vec2.create(x, y)\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var x = args[0];\n            var y = args[1];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            this.extendFillBox(box, sx, sy, args, metrics);\n        }\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class QuadraticCurveTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n\n            return {\n                endPoint: vec2.create(x, y),\n                startVector: vec2.create(2 * (cpx - sx), 2 * (cpy - sy)),   // [F(0)'x, F(0)'y]\n                endVector: vec2.create(2 * (x - cpx), 2 * (y - cpy))        // [F(1)'x, F(1)'y]\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n\n            var m = getMaxima(sx, cpx, x, sy, cpy, y);\n            if (m.x != null) {\n                box.l = Math.min(box.l, m.x);\n                box.r = Math.max(box.r, m.x);\n            }\n            if (m.y != null) {\n                box.t = Math.min(box.t, m.y);\n                box.b = Math.max(box.b, m.y);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n            var hs = pars.strokeThickness / 2.0;\n\n            var m = getMaxima(sx, cpx, x, sy, cpy, y);\n            if (m.x) {\n                box.l = Math.min(box.l, m.x - hs);\n                box.r = Math.max(box.r, m.x + hs);\n            }\n            if (m.y) {\n                box.t = Math.min(box.t, m.y - hs);\n                box.b = Math.max(box.b, m.y + hs);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n    }\n\n    //http://pomax.nihongoresources.com/pages/bezier/\n    /* Quadratic Bezier curve is defined by parametric curve:\n     *  F(t)x = s.x(1-t)^2 + cp.x(1-t)t + e.x(t^2)\n     *  F(t)x = s.y(1-t)^2 + cp.y(1-t)t + e.y(t^2)\n     * where\n     *  s = start point\n     *  cp = control point\n     *  e = end point\n     *\n     * We find the coordinates (2) where F(t)x/dt = 0, F(t)y/dt = 0\n     * (within the constraints of the curve (0 <= t <= 1)\n     * These points will expand the bounding box\n     */\n\n    interface IMaxima {\n        x: number;\n        y: number;\n    }\n    function getMaxima(x1: number, x2: number, x3: number, y1: number, y2: number, y3: number): IMaxima {\n        return {\n            x: cod(x1, x2, x3),\n            y: cod(y1, y2, y3)\n        };\n    }\n\n    function cod(a: number, b: number, c: number): number {\n        var t = (a - b) / (a - 2 * b + c);\n        if (t < 0 || t > 1)\n            return null;\n        return (a * Math.pow(1 - t, 2)) + (2 * b * (1 - t) * t) + (c * Math.pow(t, 2));\n    }\n}","/// <reference path=\"extenders/Arc\" />\n/// <reference path=\"extenders/ArcTo\" />\n/// <reference path=\"extenders/BezierCurveTo\" />\n/// <reference path=\"extenders/ClosePath\" />\n/// <reference path=\"extenders/Ellipse\" />\n/// <reference path=\"extenders/LineTo\" />\n/// <reference path=\"extenders/MoveTo\" />\n/// <reference path=\"extenders/QuadraticCurveTo\" />\n\nnamespace curve.bounds {\n    var arc = new extenders.Arc();\n    var arcTo = new extenders.ArcTo();\n    var bezierCurveTo = new extenders.BezierCurveTo();\n    var closePath = new extenders.ClosePath();\n    var ellipse = new extenders.Ellipse();\n    var lineTo = new extenders.LineTo();\n    var moveTo = new extenders.MoveTo();\n    var quadraticCurveTo = new extenders.QuadraticCurveTo();\n\n    export class ExtenderSelector implements ISegmentRunner {\n        current: extenders.IBoundsExtender;\n        args: any[];\n\n        setFillRule(fillRule: FillRule) {\n            //TODO: Does fill rule affect bounds?\n        }\n\n        closePath() {\n            this.current = closePath;\n            this.args = <any[]><any>arguments;\n        }\n\n        moveTo(x: number, y: number) {\n            this.current = moveTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        lineTo(x: number, y: number) {\n            this.current = lineTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.current = bezierCurveTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.current = quadraticCurveTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.current = arc;\n            this.args = <any[]><any>arguments;\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.current = arcTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.current = ellipse;\n            this.args = <any[]><any>arguments;\n        }\n    }\n}","namespace curve.bounds.fill {\n    export class FillBounds implements IBoundingBox {\n        path: Path;\n        l: number = 0;\n        t: number = 0;\n        r: number = 0;\n        b: number = 0;\n\n        private $calc = false;\n\n        constructor(path: Path) {\n            Object.defineProperties(this, {\n                \"path\": {value: path, writable: false}\n            });\n        }\n\n        reset() {\n            this.$calc = false;\n            this.l = this.t = this.r = this.b = 0;\n        }\n\n        ensure(): this {\n            if (!this.$calc)\n                this.calculate();\n            return this;\n        }\n\n        calculate(): this {\n            this.$calc = false;\n            this.l = Number.POSITIVE_INFINITY;\n            this.t = Number.POSITIVE_INFINITY;\n            this.r = Number.NEGATIVE_INFINITY;\n            this.b = Number.NEGATIVE_INFINITY;\n\n            var sx: number,\n                sy: number;\n            var selector = new ExtenderSelector();\n            this.path.exec(selector, () => {\n                var cur = selector.current;\n                var metrics = cur.init(sx, sy, selector.args);\n\n                cur.extendFillBox(this, sx, sy, selector.args, metrics);\n\n                sx = metrics.endPoint[0];\n                sy = metrics.endPoint[1];\n            });\n\n            this.$calc = true;\n            return this;\n        }\n    }\n}","namespace curve {\n    export enum PenLineCap {\n        Flat = 0,\n        Square = 1,\n        Round = 2,\n        Triangle = 3,\n    }\n\n    export enum PenLineJoin {\n        Miter = 0,\n        Bevel = 1,\n        Round = 2,\n    }\n\n    export interface IStrokeParameters {\n        strokeThickness: number;\n        strokeDashArray: number[];\n        strokeDashCap: PenLineCap;\n        strokeDashOffset: number;\n        strokeEndLineCap: PenLineCap;\n        strokeLineJoin: PenLineJoin;\n        strokeMiterLimit: number;\n        strokeStartLineCap: PenLineCap;\n    }\n}","///<reference path=\"../../IStrokeParameters.ts\"/>\n\nnamespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n\n    export function extendEndCap(box: IBoundingBox, metrics: any, pars: IStrokeParameters) {\n        //HTML5 doesn't support start *and* end cap individually\n        var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n        var func = cappers[cap] || cappers[PenLineCap.Flat];\n        func(box, metrics, pars.strokeThickness);\n    }\n\n    interface ICapper {\n        (box: IBoundingBox, metrics: any, thickness: number);\n    }\n    var cappers: ICapper[] = [];\n    cappers[PenLineCap.Round] = function (box: IBoundingBox, metrics: any, thickness: number) {\n        var [ex, ey] = metrics.endPoint;\n        var hs = thickness / 2.0;\n        box.l = Math.min(box.l, ex - hs);\n        box.r = Math.max(box.r, ex + hs);\n        box.t = Math.min(box.t, ey - hs);\n        box.b = Math.max(box.b, ey + hs);\n    };\n    cappers[PenLineCap.Square] = function (box: IBoundingBox, metrics: any, thickness: number) {\n        var ed = vec2.clone(metrics.endVector);\n        if (!ed || !ed[0] || !ed[1])\n            return;\n        vec2.normalize(ed);\n        var edo = vec2.orthogonal(vec2.clone(ed));\n\n        var [ex, ey] = metrics.endPoint;\n        var hs = thickness / 2.0;\n\n        var x1 = ex + hs * (ed[0] + edo[0]);\n        var x2 = ex + hs * (ed[0] - edo[0]);\n        var y1 = ey + hs * (ed[1] + edo[1]);\n        var y2 = ey + hs * (ed[1] - edo[1]);\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n    cappers[PenLineCap.Flat] = function (box: IBoundingBox, metrics: any, thickness: number) {\n        var edo = vec2.clone(metrics.endVector);\n        if (!edo || !edo[0] || !edo[1])\n            return;\n        vec2.orthogonal(vec2.normalize(edo));\n\n        var [ex, ey] = metrics.endPoint;\n        var hs = thickness / 2.0;\n\n        var x1 = ex + hs * edo[0];\n        var x2 = ex + hs * -edo[0];\n        var y1 = ey + hs * edo[1];\n        var y2 = ey + hs * -edo[1];\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n}","namespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n    import ISegmentMetrics = curve.bounds.extenders.ISegmentMetrics;\n\n    export function extendLineJoin(box: IBoundingBox, sx: number, sy: number, metrics: ISegmentMetrics, lastMetrics: ISegmentMetrics, pars: IStrokeParameters) {\n        var hs = pars.strokeThickness / 2.0;\n        if (pars.strokeLineJoin === PenLineJoin.Round) {\n            box.l = Math.min(box.l, sx - hs);\n            box.r = Math.max(box.r, sx + hs);\n            box.t = Math.min(box.t, sy - hs);\n            box.b = Math.max(box.b, sy + hs);\n            return;\n        }\n        var tips = (pars.strokeLineJoin === PenLineJoin.Miter)\n            ? findMiterTips(sx, sy, metrics, lastMetrics, hs, pars.strokeMiterLimit)\n            : findBevelTips(sx, sy, metrics, lastMetrics, hs);\n        if (!tips)\n            return;\n        var x1 = tips[0][0],\n            y1 = tips[0][1],\n            x2 = tips[1][0],\n            y2 = tips[1][1];\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    }\n\n    function findMiterTips(sx: number, sy: number, metrics: ISegmentMetrics, lastMetrics: ISegmentMetrics, hs: number, miterLimit: number): Float32Array[] {\n        var av = vec2.clone(lastMetrics.endVector);\n        var bv = vec2.clone(metrics.startVector);\n        if (!av || !bv)\n            return null;\n        vec2.reverse(av);\n        var tau = vec2.angleBetween(av, bv) / 2;\n        if (isNaN(tau))\n            return null;\n\n        var miterRatio = 1 / Math.sin(tau);\n        if (miterRatio > miterLimit)\n            return findBevelTips(sx, sy, metrics, lastMetrics, hs);\n\n        //vector in direction of join point to miter tip\n        var cv = vec2.isClockwiseTo(av, bv) ? vec2.clone(av) : vec2.clone(bv);\n        vec2.normalize(vec2.reverse(vec2.rotate(cv, tau)));\n\n        //distance from join point and miter tip\n        var miterLen = hs * miterRatio;\n\n        var tip = vec2.create(sx + miterLen * cv[0], sy + miterLen * cv[1]);\n        return [tip, tip];\n    }\n\n    function findBevelTips(sx: number, sy: number, metrics: ISegmentMetrics, lastMetrics: ISegmentMetrics, hs: number): Float32Array[] {\n        var av = vec2.clone(lastMetrics.endVector);\n        var bv = vec2.clone(metrics.startVector);\n        if (!av || !bv)\n            return;\n        vec2.normalize(vec2.reverse(av));\n        vec2.normalize(bv);\n\n        var avo = vec2.clone(av),\n            bvo = vec2.clone(bv);\n        if (vec2.isClockwiseTo(av, bv)) {\n            avo = vec2.orthogonal(av);\n            bvo = vec2.reverse(vec2.orthogonal(bv));\n        } else {\n            avo = vec2.reverse(vec2.orthogonal(av));\n            bvo = vec2.orthogonal(bv);\n        }\n\n        return [\n            vec2.create(sx - hs * avo[0], sy - hs * avo[1]),\n            vec2.create(sx - hs * bvo[0], sy - hs * bvo[1])\n        ];\n    }\n}","///<reference path=\"../../IStrokeParameters.ts\"/>\n\nnamespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n\n    export function extendStartCap(box: IBoundingBox, sx: number, sy: number, metrics: any, pars: IStrokeParameters) {\n        //HTML5 doesn't support start *and* end cap individually\n        var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n        var func = cappers[cap] || cappers[PenLineCap.Flat];\n        func(box, sx, sy, metrics, pars.strokeThickness);\n    }\n\n    interface ICapper {\n        (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number);\n    }\n    var cappers: ICapper[] = [];\n    cappers[PenLineCap.Round] = function (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number) {\n        var hs = thickness / 2.0;\n        box.l = Math.min(box.l, sx - hs);\n        box.r = Math.max(box.r, sx + hs);\n        box.t = Math.min(box.t, sy - hs);\n        box.b = Math.max(box.b, sy + hs);\n    };\n    cappers[PenLineCap.Square] = function (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number) {\n        var sd = vec2.clone(metrics.startVector);\n        if (!sd || !sd[0] || !sd[1])\n            return;\n        vec2.reverse(vec2.normalize(sd));\n        var sdo = vec2.orthogonal(vec2.clone(sd));\n\n        var hs = thickness / 2.0;\n        var x1 = sx + hs * (sd[0] + sdo[0]);\n        var x2 = sx + hs * (sd[0] - sdo[0]);\n        var y1 = sy + hs * (sd[1] + sdo[1]);\n        var y2 = sy + hs * (sd[1] - sdo[1]);\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n    cappers[PenLineCap.Flat] = function (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number) {\n        var sdo = vec2.clone(metrics.startVector);\n        if (!sdo || !sdo[0] || !sdo[1])\n            return;\n        vec2.orthogonal(vec2.normalize(sdo));\n\n        var hs = thickness / 2.0;\n        var x1 = sx + hs * sdo[0];\n        var x2 = sx + hs * -sdo[0];\n        var y1 = sy + hs * sdo[1];\n        var y2 = sy + hs * -sdo[1];\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n}","namespace curve.bounds.stroke {\n    export class StartCapExtender {\n        extend() {\n\n        }\n    }\n}","namespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n    import IBoundsExtender = curve.bounds.extenders.IBoundsExtender;\n    import ISegmentMetrics = curve.bounds.extenders.ISegmentMetrics;\n\n    export class StrokeBounds implements IBoundingBox {\n        path: Path;\n        pars: IStrokeParameters;\n        l: number = 0;\n        t: number = 0;\n        r: number = 0;\n        b: number = 0;\n\n        private $calc = false;\n\n        constructor(path: Path) {\n            Object.defineProperties(this, {\n                \"path\": {value: path, writable: false}\n            });\n        }\n\n        reset() {\n            this.$calc = false;\n            this.l = this.t = this.r = this.b = 0;\n        }\n\n        ensure(): this {\n            if (!this.$calc)\n                this.calculate();\n            return this;\n        }\n\n        calculate(): this {\n            this.$calc = false;\n            this.l = Number.POSITIVE_INFINITY;\n            this.t = Number.POSITIVE_INFINITY;\n            this.r = Number.NEGATIVE_INFINITY;\n            this.b = Number.NEGATIVE_INFINITY;\n\n            var sx: number,\n                sy: number,\n                last: IBoundsExtender,\n                lastMetrics: ISegmentMetrics;\n            var selector = new ExtenderSelector();\n            this.path.exec(selector, () => {\n                var cur = selector.current;\n                var metrics = cur.init(sx, sy, selector.args);\n\n                if (!cur.isMove) {\n                    if (last.isMove) {\n                        extendStartCap(this, sx, sy, metrics, this.pars);\n                    } else if (lastMetrics) {\n                        extendLineJoin(this, sx, sy, metrics, lastMetrics, this.pars);\n                    }\n                }\n\n                cur.extendStrokeBox(this, sx, sy, selector.args, metrics, this.pars);\n\n                sx = metrics.endPoint[0];\n                sy = metrics.endPoint[1];\n                last = cur;\n                lastMetrics = metrics;\n            });\n\n            if (lastMetrics)\n                extendEndCap(this, lastMetrics, this.pars);\n\n            this.$calc = true;\n            return this;\n        }\n    }\n}","namespace curve.compiler {\n    export function compile(arg0: string|ISegmentExecutor): ICompiledSegment[] {\n        var compiler = PathCompiler.instance;\n        compiler.compiled.length = 0;\n        if (typeof arg0 === \"string\") {\n            var parser = parse.getParser();\n            parser.parse(compiler, arg0);\n        } else if (typeof arg0.exec === \"function\") {\n            arg0.exec(compiler);\n        }\n        return compiler.compiled;\n    }\n\n    class PathCompiler implements ISegmentRunner {\n        static instance = new PathCompiler();\n\n        compiled: ICompiledSegment[] = [];\n\n        setFillRule(fillRule: FillRule) {\n            this.compiled.push({t: CompiledOpType.setFillRule, a: [fillRule]});\n        }\n\n        closePath() {\n            this.compiled.push({t: CompiledOpType.closePath, a: []});\n        }\n\n        moveTo(x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.moveTo, a: [x, y]});\n        }\n\n        lineTo(x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.lineTo, a: [x, y]});\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.bezierCurveTo, a: [cp1x, cp1y, cp2x, cp2y, x, y]});\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.quadraticCurveTo, a: [cpx, cpy, x, y]});\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.compiled.push({t: CompiledOpType.arc, a: [x, y, radius, startAngle, endAngle, anticlockwise]});\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.compiled.push({t: CompiledOpType.arcTo, a: [x1, y1, x2, y2, radius]});\n        }\n\n        ellipse(cx: number, cy: number, rx: number, ry: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.compiled.push({\n                t: CompiledOpType.ellipse,\n                a: [cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise]\n            })\n        }\n    }\n}","namespace curve.compiler {\n    export function decompile(runner: ISegmentRunner, compiled: ICompiledSegment[]) {\n        for (var i = 0; !!compiled && i < compiled.length; i++) {\n            let seg = compiled[i];\n            let typeStr: string;\n            if (typeof seg.t !== \"number\" || !(typeStr = CompiledOpType[seg.t])) {\n                console.warn(`Unknown compiled path command: ${seg.t}, ${seg.a}`);\n                continue;\n            }\n            var func = runner[typeStr];\n            func && func.apply(runner, seg.a);\n        }\n    }\n}","interface ICompiledSegment {\n    t: CompiledOpType;\n    a: any[];\n}\n\nenum CompiledOpType {\n    setFillRule = 1,\n    closePath = 2,\n    moveTo = 3,\n    lineTo = 4,\n    bezierCurveTo = 5,\n    quadraticCurveTo = 6,\n    arc = 7,\n    arcTo = 8,\n    ellipse = 9,\n}","namespace curve.ellipticalArc {\n    import vec2 = la.vec2;\n\n    // NOTES\n    // rx, ry, phi are the same between both parameterizations\n    // [cx, cy]/[rx, ry] defines the ellipse\n    // there are 2 possible solutions that are \"picked\" through anti-clockwise flag\n    // if anticlockwise, the arc becomes the complementary arc\n    //      (large arc sweeping clockwise becomes small arc sweeping counterclockwise)\n    // [sx, sy] defines the starting point as characterized by the starting angle\n    // [ex, ey] defines the ending point as characterized by the ending angle\n\n    export interface IEllipticalArcParameterization {\n        sx: number;\n        sy: number;\n        ex: number;\n        ey: number;\n        fa: number;\n        fs: number;\n        rx: number;\n        ry: number;\n        phi: number;\n    }\n\n    // [cx, cy] = ellipse center\n    // [rx, ry] = radial size\n    // sa = starting angle (radians - clockwise from x-axis)\n    // ea = ending angle (radians - clockwise from x-axis)\n    // phi = angle (radians) from x-axis of coordinate space to x-axis of ellipse\n    // ac = anti-clockwise\n    export function fromEllipse(cx: number, cy: number, rx: number, ry: number, phi: number, sa: number, ea: number, ac: boolean): IEllipticalArcParameterization {\n        // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        // F.6.4 Conversion from center to endpoint parameterization\n\n        // anti-clockwise inverts fA & fS (not mentioned in specification)\n\n        // F.6.4.1\n        // Compute a`\n        var ap = vec2.rotate(vec2.create(rx * Math.cos(sa), ry * Math.sin(sa)), phi);\n        ap[0] += cx;\n        ap[1] += cy;\n\n        // F.6.4.2\n        // Compute b`\n        var bp = vec2.rotate(vec2.create(rx * Math.cos(ea), ry * Math.sin(ea)), phi);\n        bp[0] += cx;\n        bp[1] += cy;\n\n        var da = ea - sa;\n        // F.6.4.3\n        // Compute fA\n        var fa = Math.abs(da) > Math.PI ? 1 : 0;\n        var expac = Math.abs(sa - ea) ? ea < sa : sa > ea;\n        fa = (expac !== ac) ? 1 - fa : fa;\n\n        // F.6.4.4\n        // Compute fS\n        var fs = ac === true ? 0 : 1;\n\n        return {\n            sx: ap[0],\n            sy: ap[1],\n            ex: bp[0],\n            ey: bp[1],\n            fa: fa,\n            fs: fs,\n            rx: rx,\n            ry: ry,\n            phi: phi\n        };\n    }\n}","namespace curve.ellipticalArc {\n    // [apx, apy] = primed coordinate values from F.6.5.1\n    // [rx, ry] = radial size\n    export function correctRadii(rx: number, ry: number, apx: number, apy: number): number[] {\n        // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        // F.6.6 Correction of out-of-range radii\n\n        // F.6.6.1\n        // Ensure radii are positive\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n\n        // F.6.6.2\n        // Compute lambda\n        var lambda = ((apx * apx) / (rx * rx)) + ((apy * apy) / (ry * ry));\n\n        // F.6.6.3\n        // Alter small radii\n        if (lambda > 1) {\n            var rl = Math.sqrt(lambda);\n            rx *= rl;\n            ry *= rl;\n        }\n\n        return [rx, ry];\n    }\n}","namespace curve.ellipticalArc {\n    import vec2 = la.vec2;\n    var PI2 = 2 * Math.PI;\n\n    // NOTES\n    // rx, ry, phi are the same between both parameterizations\n    // [cx, cy] is computed based on [sx, sy, rx, ry, ex, ey, fa, fs]\n    // there are 2 possible solutions for ellipse [cx, cy]\n    // each ellipse has 2 possible solutions\n    //   these solutions should be chosen based on fa, fs, and [sx,sy]->[ex,ey] relationship\n    //   the solutions chosen should have exactly one anti-clockwise true and one anti-clockwise false\n\n    export interface IEllipseParameterization {\n        cx: number;\n        cy: number;\n        rx: number;\n        ry: number;\n        phi?: number; // rotation (radians)\n        sa?: number; // start angle (radians)\n        ea?: number; // end angle (radians)\n        ac?: boolean; // anti-clockwise\n    }\n\n    // [sx, sy] = start point\n    // [rx, ry] = radial size\n    // phi = angle (radians) from x-axis of coordinate space to x-axis of ellipse\n    // fa = large arc flag\n    // fs = sweep direction flag\n    // [ex, ey] = end point\n    export function toEllipse(sx: number, sy: number, rx: number, ry: number, phi: number, fa: number, fs: number, ex: number, ey: number): IEllipseParameterization {\n        // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        // F.6.5 Conversion from endpoint to center parameterization\n        if (rx === 0 || ry === 0) {\n            return {cx: ex, cy: ey, rx: rx, ry: ry};\n        }\n\n        // F.6.5.1\n        // Compute a`\n        var ap = vec2.create((sx - ex) / 2.0, (sy - ey) / 2.0);\n        vec2.rotate(ap, -phi);\n\n        // Correct radii\n        [rx, ry] = correctRadii(rx, ry, ap[0], ap[1]);\n\n        // F.6.5.2\n        // Compute c`\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n        var apx2 = ap[0] * ap[0];\n        var apy2 = ap[1] * ap[1];\n        var factor = Math.sqrt(((rx2 * ry2) - (rx2 * apy2) - (ry2 * apx2)) / ((rx2 * apy2) + (ry2 * apx2)));\n        if (fa === fs) {\n            factor *= -1;\n        }\n        var cp = vec2.create(rx * ap[1] / ry, -ry * ap[0] / rx);\n        cp[0] *= factor;\n        cp[1] *= factor;\n\n        // F.6.5.3\n        // Compute c\n        var c = vec2.rotate(vec2.clone(cp), phi);\n        c[0] += (sx + ex) / 2.0;\n        c[1] += (sy + ey) / 2.0;\n\n        // F.6.5.5\n        // Compute theta1\n        var v = vec2.create(1, 0);\n        var u = vec2.create((ap[0] - cp[0]) / rx, (ap[1] - cp[1]) / ry);\n        var sa = vec2.angleBetween(v, u) * signAdjust(v, u);\n        if (sa < 0) {\n            sa += PI2;\n        }\n\n        // F.6.5.6\n        // Compute delta-theta\n        v = vec2.create((-ap[0] - cp[0]) / rx, (-ap[1] - cp[1]) / ry);\n        var dt = (vec2.angleBetween(u, v) * signAdjust(u, v)) % PI2;\n        // Correct for sweep flag\n        if (fs === 0 && dt > 0) {\n            dt -= PI2;\n        } else if (fs === 1 && dt < 0) {\n            dt += PI2;\n        }\n\n        // Normalize end angle\n        var ea = (sa + dt) % PI2;\n        if (ea < 0) {\n            ea += PI2;\n        }\n\n        var ac = fs === 0;\n\n        return {\n            cx: c[0],\n            cy: c[1],\n            rx: rx,\n            ry: ry,\n            phi: phi,\n            sa: sa,\n            ea: ea,\n            ac: ac\n        };\n    }\n\n    function signAdjust(u: Float32Array, v: Float32Array): number {\n        return ((u[0] * v[1]) - (u[1] * v[0])) < 0 ? -1 : 1;\n    }\n}","var curve;\n(function (curve) {\n    curve.version = '0.1.4';\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var Arc = (function () {\n                function Arc() {\n                    this.isMove = false;\n                }\n                Arc.prototype.init = function (sx, sy, args) {\n                    var x = args[0];\n                    var y = args[1];\n                    var radius = args[2];\n                    var sa = args[3];\n                    var ea = args[4];\n                    var cc = args[5];\n                    sx = x + (radius * Math.cos(sa));\n                    sy = y + (radius * Math.sin(sa));\n                    var ex = x + (radius * Math.cos(ea));\n                    var ey = y + (radius * Math.sin(ea));\n                    var l = x - radius;\n                    var cl = arcContainsPoint(sx, sy, ex, ey, l, y, cc);\n                    var r = x + radius;\n                    var cr = arcContainsPoint(sx, sy, ex, ey, r, y, cc);\n                    var t = y - radius;\n                    var ct = arcContainsPoint(sx, sy, ex, ey, x, t, cc);\n                    var b = y + radius;\n                    var cb = arcContainsPoint(sx, sy, ex, ey, x, b, cc);\n                    return {\n                        sx: sx,\n                        sy: sy,\n                        l: l,\n                        cl: cl,\n                        r: r,\n                        cr: cr,\n                        t: t,\n                        ct: ct,\n                        b: b,\n                        cb: cb,\n                        endPoint: vec2.create(ex, ey),\n                        startVector: getStartVector(x, y, cc, sx, sy),\n                        endVector: getEndVector(x, y, cc, ex, ey)\n                    };\n                };\n                Arc.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    var sa = args[3];\n                    var ea = args[4];\n                    if (ea === sa)\n                        return;\n                    var ep = metrics.endPoint, ex = ep[0], ey = ep[1];\n                    box.l = Math.min(box.l, sx, ex);\n                    box.r = Math.max(box.r, sx, ex);\n                    box.t = Math.min(box.t, sy, ey);\n                    box.b = Math.max(box.b, sy, ey);\n                    if (metrics.cl)\n                        box.l = Math.min(box.l, metrics.l);\n                    if (metrics.cr)\n                        box.r = Math.max(box.r, metrics.r);\n                    if (metrics.ct)\n                        box.t = Math.min(box.t, metrics.t);\n                    if (metrics.cb)\n                        box.b = Math.max(box.b, metrics.b);\n                };\n                Arc.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    var sa = args[3];\n                    var ea = args[4];\n                    if (ea === sa)\n                        return;\n                    var ep = metrics.endPoint, ex = ep[0], ey = ep[1];\n                    box.l = Math.min(box.l, sx, ex);\n                    box.r = Math.max(box.r, sx, ex);\n                    box.t = Math.min(box.t, sy, ey);\n                    box.b = Math.max(box.b, sy, ey);\n                    var hs = pars.strokeThickness / 2.0;\n                    if (metrics.cl)\n                        box.l = Math.min(box.l, metrics.l - hs);\n                    if (metrics.cr)\n                        box.r = Math.max(box.r, metrics.r + hs);\n                    if (metrics.ct)\n                        box.t = Math.min(box.t, metrics.t - hs);\n                    if (metrics.cb)\n                        box.b = Math.max(box.b, metrics.b + hs);\n                    var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n                    var sv = vec2.reverse(vec2.clone(metrics.startVector));\n                    var ss = getCapSpread(sx, sy, pars.strokeThickness, cap, sv);\n                    var es = getCapSpread(ex, ey, pars.strokeThickness, cap, metrics.endVector);\n                    box.l = Math.min(box.l, ss.x1, ss.x2, es.x1, es.x2);\n                    box.r = Math.max(box.r, ss.x1, ss.x2, es.x1, es.x2);\n                    box.t = Math.min(box.t, ss.y1, ss.y2, es.y1, es.y2);\n                    box.b = Math.max(box.b, ss.y1, ss.y2, es.y1, es.y2);\n                };\n                return Arc;\n            })();\n            extenders.Arc = Arc;\n            function getStartVector(x, y, cc, sx, sy) {\n                var rx = sx - x, ry = sy - y;\n                if (cc)\n                    return vec2.create(ry, -rx);\n                return vec2.create(-ry, rx);\n            }\n            function getEndVector(x, y, cc, ex, ey) {\n                var rx = ex - x, ry = ey - y;\n                if (cc)\n                    return vec2.create(ry, -rx);\n                return vec2.create(-ry, rx);\n            }\n            function arcContainsPoint(sx, sy, ex, ey, cpx, cpy, cc) {\n                var n = (ex - sx) * (cpy - sy) - (cpx - sx) * (ey - sy);\n                if (n === 0)\n                    return true;\n                if (n > 0 && cc)\n                    return true;\n                if (n < 0 && !cc)\n                    return true;\n                return false;\n            }\n            function getCapSpread(x, y, thickness, cap, vector) {\n                var hs = thickness / 2.0;\n                switch (cap) {\n                    case curve.PenLineCap.Round:\n                        return {\n                            x1: x - hs,\n                            x2: x + hs,\n                            y1: y - hs,\n                            y2: y + hs\n                        };\n                        break;\n                    case curve.PenLineCap.Square:\n                        var ed = vec2.normalize(vec2.clone(vector));\n                        var edo = vec2.orthogonal(vec2.clone(ed));\n                        return {\n                            x1: x + hs * (ed[0] + edo[0]),\n                            x2: x + hs * (ed[0] - edo[0]),\n                            y1: y + hs * (ed[1] + edo[1]),\n                            y2: y + hs * (ed[1] - edo[1])\n                        };\n                        break;\n                    case curve.PenLineCap.Flat:\n                    default:\n                        var edo = vec2.orthogonal(vec2.normalize(vec2.clone(vector)));\n                        return {\n                            x1: x + hs * edo[0],\n                            x2: x + hs * -edo[0],\n                            y1: y + hs * edo[1],\n                            y2: y + hs * -edo[1]\n                        };\n                        break;\n                }\n            }\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var LineTo = (function () {\n                function LineTo() {\n                    this.isMove = false;\n                }\n                LineTo.prototype.init = function (sx, sy, args) {\n                    var x = args[0];\n                    var y = args[1];\n                    return {\n                        startVector: vec2.create(x - sx, y - sy),\n                        endVector: vec2.create(x - sx, y - sy),\n                        endPoint: vec2.create(x, y)\n                    };\n                };\n                LineTo.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    var x = args[0];\n                    var y = args[1];\n                    box.l = Math.min(box.l, x);\n                    box.r = Math.max(box.r, x);\n                    box.t = Math.min(box.t, y);\n                    box.b = Math.max(box.b, y);\n                };\n                LineTo.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    this.extendFillBox(box, sx, sy, args, metrics);\n                };\n                return LineTo;\n            })();\n            extenders.LineTo = LineTo;\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var _arc = new extenders.Arc();\n            var _lineTo = new extenders.LineTo();\n            var ArcTo = (function () {\n                function ArcTo() {\n                    this.isMove = false;\n                }\n                ArcTo.prototype.init = function (sx, sy, args) {\n                    var x1 = args[0];\n                    var y1 = args[1];\n                    var x2 = args[2];\n                    var y2 = args[3];\n                    var radius = args[4];\n                    var v1 = vec2.create(x1 - sx, y1 - sy);\n                    var v2 = vec2.create(x2 - x1, y2 - y1);\n                    var inner_theta = Math.PI - vec2.angleBetween(v1, v2);\n                    var a = getTangentPoint(inner_theta, radius, vec2.create(sx, sy), v1, true);\n                    var b = getTangentPoint(inner_theta, radius, vec2.create(x1, y1), v2, false);\n                    var line = createLine(sx, sy, a[0], a[1]);\n                    var arc = createArc(a, v1, b, v2, radius);\n                    return {\n                        line: line,\n                        arc: arc,\n                        startVector: line.metrics.startVector,\n                        endVector: arc.metrics.endVector,\n                        endPoint: arc.metrics.endPoint\n                    };\n                };\n                ArcTo.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    _lineTo.extendFillBox(box, sx, sy, metrics.line.args, metrics.line.metrics);\n                    var ep = metrics.line.metrics.endPoint;\n                    _arc.extendFillBox(box, ep[0], ep[1], metrics.arc.args, metrics.arc.metrics);\n                };\n                ArcTo.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    _lineTo.extendStrokeBox(box, sx, sy, metrics.line.args, metrics.line.metrics, pars);\n                    var ep = metrics.line.metrics.endPoint;\n                    _arc.extendStrokeBox(box, ep[0], ep[1], metrics.arc.args, metrics.arc.metrics, pars);\n                };\n                return ArcTo;\n            })();\n            extenders.ArcTo = ArcTo;\n            function createLine(sx, sy, x, y) {\n                var args = [x, y];\n                return {\n                    args: args,\n                    metrics: _lineTo.init(sx, sy, args)\n                };\n            }\n            function createArc(a, v1, b, v2, radius) {\n                var c = getPerpendicularIntersections(a, v1, b, v2);\n                var cc = !la.vec2.isClockwiseTo(v1, v2);\n                var sa = Math.atan2(a[1] - c[1], a[0] - c[0]);\n                if (sa < 0)\n                    sa = (2 * Math.PI) + sa;\n                var ea = Math.atan2(b[1] - c[1], b[0] - c[0]);\n                if (ea < 0)\n                    ea = (2 * Math.PI) + ea;\n                var args = [c[0], c[1], radius, sa, ea, cc];\n                return {\n                    args: args,\n                    metrics: _arc.init(a[0], a[1], args)\n                };\n            }\n            function getTangentPoint(theta, radius, s, d, invert) {\n                var len = Math.sqrt(d[0] * d[0] + d[1] * d[1]);\n                var f = radius / Math.tan(theta / 2);\n                var t = f / len;\n                if (invert)\n                    t = 1 - t;\n                return la.vec2.create(s[0] + t * d[0], s[1] + t * d[1]);\n            }\n            function getPerpendicularIntersections(s1, d1, s2, d2) {\n                var p1 = vec2.orthogonal(vec2.clone(d1));\n                var p2 = vec2.orthogonal(vec2.clone(d2));\n                return vec2.intersection(s1, p1, s2, p2);\n            }\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var BezierCurveTo = (function () {\n                function BezierCurveTo() {\n                    this.isMove = false;\n                }\n                BezierCurveTo.prototype.init = function (sx, sy, args) {\n                    var cp1x = args[0];\n                    var cp1y = args[1];\n                    var cp2x = args[2];\n                    var cp2y = args[3];\n                    var x = args[4];\n                    var y = args[5];\n                    return {\n                        endPoint: vec2.create(x, y),\n                        startVector: vec2.create(3 * (cp1x - sx), 3 * (cp1y - sy)),\n                        endVector: vec2.create(3 * (x - cp2x), 3 * (y - cp2y))\n                    };\n                };\n                BezierCurveTo.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    var cp1x = args[0];\n                    var cp1y = args[1];\n                    var cp2x = args[2];\n                    var cp2y = args[3];\n                    var x = args[4];\n                    var y = args[5];\n                    var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n                    if (m.x[0] != null) {\n                        box.l = Math.min(box.l, m.x[0]);\n                        box.r = Math.max(box.r, m.x[0]);\n                    }\n                    if (m.x[1] != null) {\n                        box.l = Math.min(box.l, m.x[1]);\n                        box.r = Math.max(box.r, m.x[1]);\n                    }\n                    if (m.y[0] != null) {\n                        box.t = Math.min(box.t, m.y[0]);\n                        box.b = Math.max(box.b, m.y[0]);\n                    }\n                    if (m.y[1] != null) {\n                        box.t = Math.min(box.t, m.y[1]);\n                        box.b = Math.max(box.b, m.y[1]);\n                    }\n                    box.l = Math.min(box.l, x);\n                    box.r = Math.max(box.r, x);\n                    box.t = Math.min(box.t, y);\n                    box.b = Math.max(box.b, y);\n                };\n                BezierCurveTo.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    var cp1x = args[0];\n                    var cp1y = args[1];\n                    var cp2x = args[2];\n                    var cp2y = args[3];\n                    var x = args[4];\n                    var y = args[5];\n                    var hs = pars.strokeThickness / 2.0;\n                    var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n                    if (m.x[0] != null) {\n                        box.l = Math.min(box.l, m.x[0] - hs);\n                        box.r = Math.max(box.r, m.x[0] + hs);\n                    }\n                    if (m.x[1] != null) {\n                        box.l = Math.min(box.l, m.x[1] - hs);\n                        box.r = Math.max(box.r, m.x[1] + hs);\n                    }\n                    if (m.y[0] != null) {\n                        box.t = Math.min(box.t, m.y[0] - hs);\n                        box.b = Math.max(box.b, m.y[0] + hs);\n                    }\n                    if (m.y[1] != null) {\n                        box.t = Math.min(box.t, m.y[1] - hs);\n                        box.b = Math.max(box.b, m.y[1] + hs);\n                    }\n                    box.l = Math.min(box.l, x);\n                    box.r = Math.max(box.r, x);\n                    box.t = Math.min(box.t, y);\n                    box.b = Math.max(box.b, y);\n                };\n                return BezierCurveTo;\n            })();\n            extenders.BezierCurveTo = BezierCurveTo;\n            function getMaxima(x1, x2, x3, x4, y1, y2, y3, y4) {\n                return {\n                    x: cod(x1, x2, x3, x4),\n                    y: cod(y1, y2, y3, y4)\n                };\n            }\n            function cod(a, b, c, d) {\n                var u = 2 * a - 4 * b + 2 * c;\n                var v = b - a;\n                var w = -a + 3 * b + d - 3 * c;\n                var rt = Math.sqrt(u * u - 4 * v * w);\n                var cods = [null, null];\n                if (isNaN(rt))\n                    return cods;\n                var t, ot;\n                t = (-u + rt) / (2 * w);\n                if (t >= 0 && t <= 1) {\n                    ot = 1 - t;\n                    cods[0] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n                }\n                t = (-u - rt) / (2 * w);\n                if (t >= 0 && t <= 1) {\n                    ot = 1 - t;\n                    cods[1] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n                }\n                return cods;\n            }\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var ClosePath = (function () {\n                function ClosePath() {\n                    this.isMove = false;\n                }\n                ClosePath.prototype.init = function () {\n                    return {\n                        endPoint: undefined,\n                        startVector: undefined,\n                        endVector: undefined\n                    };\n                };\n                ClosePath.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                };\n                ClosePath.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                };\n                return ClosePath;\n            })();\n            extenders.ClosePath = ClosePath;\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var Ellipse = (function () {\n                function Ellipse() {\n                    this.isMove = false;\n                }\n                Ellipse.prototype.init = function (sx, sy, args) {\n                    var cx = args[0];\n                    var cy = args[1];\n                    var rx = args[2];\n                    var ry = args[3];\n                    var phi = args[4];\n                    var sa = args[5];\n                    var ea = args[6];\n                    var ac = args[7];\n                    var util = la.ellipse(cx, cy, rx, ry, phi);\n                    var ep = util.point(ea);\n                    var sv = util.tangent(sa);\n                    var ev = util.tangent(ea);\n                    if (ac == true) {\n                        vec2.reverse(sv);\n                        vec2.reverse(ev);\n                    }\n                    return {\n                        util: util,\n                        startVector: sv,\n                        endVector: ev,\n                        endPoint: ep\n                    };\n                };\n                Ellipse.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    var sa = args[5];\n                    var ea = args[6];\n                    var ac = args[7];\n                    var util = metrics.util;\n                    for (var i = 0, ext = util.extrema(sa, ea, ac); i < ext.length; i++) {\n                        var p = ext[i];\n                        if (!p)\n                            continue;\n                        var x = p[0];\n                        var y = p[1];\n                        box.l = Math.min(box.l, x);\n                        box.r = Math.max(box.r, x);\n                        box.t = Math.min(box.t, y);\n                        box.b = Math.max(box.b, y);\n                    }\n                };\n                Ellipse.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    var sa = args[5];\n                    var ea = args[6];\n                    var ac = args[7];\n                    var util = metrics.util;\n                    var hs = pars.strokeThickness / 2.0;\n                    var _a = util.extrema(sa, ea, ac), vp1 = _a[0], vp2 = _a[1], hp1 = _a[2], hp2 = _a[3];\n                    if (vp1) {\n                        box.l = Math.min(box.l, vp1[0] - hs);\n                        box.r = Math.max(box.r, vp1[0] + hs);\n                    }\n                    if (vp2) {\n                        box.l = Math.min(box.l, vp2[0] - hs);\n                        box.r = Math.max(box.r, vp2[0] + hs);\n                    }\n                    if (hp1) {\n                        box.t = Math.min(box.t, hp1[1] - hs);\n                        box.b = Math.max(box.b, hp1[1] + hs);\n                    }\n                    if (hp2) {\n                        box.t = Math.min(box.t, hp2[1] - hs);\n                        box.b = Math.max(box.b, hp2[1] + hs);\n                    }\n                };\n                return Ellipse;\n            })();\n            extenders.Ellipse = Ellipse;\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var MoveTo = (function () {\n                function MoveTo() {\n                    this.isMove = true;\n                }\n                MoveTo.prototype.init = function (sx, sy, args) {\n                    var x = args[0];\n                    var y = args[1];\n                    return {\n                        startVector: null,\n                        endVector: null,\n                        endPoint: vec2.create(x, y)\n                    };\n                };\n                MoveTo.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    var x = args[0];\n                    var y = args[1];\n                    box.l = Math.min(box.l, x);\n                    box.r = Math.max(box.r, x);\n                    box.t = Math.min(box.t, y);\n                    box.b = Math.max(box.b, y);\n                };\n                MoveTo.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    this.extendFillBox(box, sx, sy, args, metrics);\n                };\n                return MoveTo;\n            })();\n            extenders.MoveTo = MoveTo;\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var extenders;\n        (function (extenders) {\n            var vec2 = la.vec2;\n            var QuadraticCurveTo = (function () {\n                function QuadraticCurveTo() {\n                    this.isMove = false;\n                }\n                QuadraticCurveTo.prototype.init = function (sx, sy, args) {\n                    var cpx = args[0];\n                    var cpy = args[1];\n                    var x = args[2];\n                    var y = args[3];\n                    return {\n                        endPoint: vec2.create(x, y),\n                        startVector: vec2.create(2 * (cpx - sx), 2 * (cpy - sy)),\n                        endVector: vec2.create(2 * (x - cpx), 2 * (y - cpy))\n                    };\n                };\n                QuadraticCurveTo.prototype.extendFillBox = function (box, sx, sy, args, metrics) {\n                    var cpx = args[0];\n                    var cpy = args[1];\n                    var x = args[2];\n                    var y = args[3];\n                    var m = getMaxima(sx, cpx, x, sy, cpy, y);\n                    if (m.x != null) {\n                        box.l = Math.min(box.l, m.x);\n                        box.r = Math.max(box.r, m.x);\n                    }\n                    if (m.y != null) {\n                        box.t = Math.min(box.t, m.y);\n                        box.b = Math.max(box.b, m.y);\n                    }\n                    box.l = Math.min(box.l, x);\n                    box.r = Math.max(box.r, x);\n                    box.t = Math.min(box.t, y);\n                    box.b = Math.max(box.b, y);\n                };\n                QuadraticCurveTo.prototype.extendStrokeBox = function (box, sx, sy, args, metrics, pars) {\n                    var cpx = args[0];\n                    var cpy = args[1];\n                    var x = args[2];\n                    var y = args[3];\n                    var hs = pars.strokeThickness / 2.0;\n                    var m = getMaxima(sx, cpx, x, sy, cpy, y);\n                    if (m.x) {\n                        box.l = Math.min(box.l, m.x - hs);\n                        box.r = Math.max(box.r, m.x + hs);\n                    }\n                    if (m.y) {\n                        box.t = Math.min(box.t, m.y - hs);\n                        box.b = Math.max(box.b, m.y + hs);\n                    }\n                    box.l = Math.min(box.l, x);\n                    box.r = Math.max(box.r, x);\n                    box.t = Math.min(box.t, y);\n                    box.b = Math.max(box.b, y);\n                };\n                return QuadraticCurveTo;\n            })();\n            extenders.QuadraticCurveTo = QuadraticCurveTo;\n            function getMaxima(x1, x2, x3, y1, y2, y3) {\n                return {\n                    x: cod(x1, x2, x3),\n                    y: cod(y1, y2, y3)\n                };\n            }\n            function cod(a, b, c) {\n                var t = (a - b) / (a - 2 * b + c);\n                if (t < 0 || t > 1)\n                    return null;\n                return (a * Math.pow(1 - t, 2)) + (2 * b * (1 - t) * t) + (c * Math.pow(t, 2));\n            }\n        })(extenders = bounds.extenders || (bounds.extenders = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var arc = new bounds.extenders.Arc();\n        var arcTo = new bounds.extenders.ArcTo();\n        var bezierCurveTo = new bounds.extenders.BezierCurveTo();\n        var closePath = new bounds.extenders.ClosePath();\n        var ellipse = new bounds.extenders.Ellipse();\n        var lineTo = new bounds.extenders.LineTo();\n        var moveTo = new bounds.extenders.MoveTo();\n        var quadraticCurveTo = new bounds.extenders.QuadraticCurveTo();\n        var ExtenderSelector = (function () {\n            function ExtenderSelector() {\n            }\n            ExtenderSelector.prototype.setFillRule = function (fillRule) {\n            };\n            ExtenderSelector.prototype.closePath = function () {\n                this.current = closePath;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.moveTo = function (x, y) {\n                this.current = moveTo;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.lineTo = function (x, y) {\n                this.current = lineTo;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n                this.current = bezierCurveTo;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n                this.current = quadraticCurveTo;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {\n                this.current = arc;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n                this.current = arcTo;\n                this.args = arguments;\n            };\n            ExtenderSelector.prototype.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n                this.current = ellipse;\n                this.args = arguments;\n            };\n            return ExtenderSelector;\n        })();\n        bounds.ExtenderSelector = ExtenderSelector;\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var fill;\n        (function (fill) {\n            var FillBounds = (function () {\n                function FillBounds(path) {\n                    this.l = 0;\n                    this.t = 0;\n                    this.r = 0;\n                    this.b = 0;\n                    this.$calc = false;\n                    Object.defineProperties(this, {\n                        \"path\": { value: path, writable: false }\n                    });\n                }\n                FillBounds.prototype.reset = function () {\n                    this.$calc = false;\n                    this.l = this.t = this.r = this.b = 0;\n                };\n                FillBounds.prototype.ensure = function () {\n                    if (!this.$calc)\n                        this.calculate();\n                    return this;\n                };\n                FillBounds.prototype.calculate = function () {\n                    var _this = this;\n                    this.$calc = false;\n                    this.l = Number.POSITIVE_INFINITY;\n                    this.t = Number.POSITIVE_INFINITY;\n                    this.r = Number.NEGATIVE_INFINITY;\n                    this.b = Number.NEGATIVE_INFINITY;\n                    var sx, sy;\n                    var selector = new bounds.ExtenderSelector();\n                    this.path.exec(selector, function () {\n                        var cur = selector.current;\n                        var metrics = cur.init(sx, sy, selector.args);\n                        cur.extendFillBox(_this, sx, sy, selector.args, metrics);\n                        sx = metrics.endPoint[0];\n                        sy = metrics.endPoint[1];\n                    });\n                    this.$calc = true;\n                    return this;\n                };\n                return FillBounds;\n            })();\n            fill.FillBounds = FillBounds;\n        })(fill = bounds.fill || (bounds.fill = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    (function (PenLineCap) {\n        PenLineCap[PenLineCap[\"Flat\"] = 0] = \"Flat\";\n        PenLineCap[PenLineCap[\"Square\"] = 1] = \"Square\";\n        PenLineCap[PenLineCap[\"Round\"] = 2] = \"Round\";\n        PenLineCap[PenLineCap[\"Triangle\"] = 3] = \"Triangle\";\n    })(curve.PenLineCap || (curve.PenLineCap = {}));\n    var PenLineCap = curve.PenLineCap;\n    (function (PenLineJoin) {\n        PenLineJoin[PenLineJoin[\"Miter\"] = 0] = \"Miter\";\n        PenLineJoin[PenLineJoin[\"Bevel\"] = 1] = \"Bevel\";\n        PenLineJoin[PenLineJoin[\"Round\"] = 2] = \"Round\";\n    })(curve.PenLineJoin || (curve.PenLineJoin = {}));\n    var PenLineJoin = curve.PenLineJoin;\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var stroke;\n        (function (stroke) {\n            var vec2 = la.vec2;\n            function extendEndCap(box, metrics, pars) {\n                var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n                var func = cappers[cap] || cappers[curve.PenLineCap.Flat];\n                func(box, metrics, pars.strokeThickness);\n            }\n            stroke.extendEndCap = extendEndCap;\n            var cappers = [];\n            cappers[curve.PenLineCap.Round] = function (box, metrics, thickness) {\n                var _a = metrics.endPoint, ex = _a[0], ey = _a[1];\n                var hs = thickness / 2.0;\n                box.l = Math.min(box.l, ex - hs);\n                box.r = Math.max(box.r, ex + hs);\n                box.t = Math.min(box.t, ey - hs);\n                box.b = Math.max(box.b, ey + hs);\n            };\n            cappers[curve.PenLineCap.Square] = function (box, metrics, thickness) {\n                var ed = vec2.clone(metrics.endVector);\n                if (!ed || !ed[0] || !ed[1])\n                    return;\n                vec2.normalize(ed);\n                var edo = vec2.orthogonal(vec2.clone(ed));\n                var _a = metrics.endPoint, ex = _a[0], ey = _a[1];\n                var hs = thickness / 2.0;\n                var x1 = ex + hs * (ed[0] + edo[0]);\n                var x2 = ex + hs * (ed[0] - edo[0]);\n                var y1 = ey + hs * (ed[1] + edo[1]);\n                var y2 = ey + hs * (ed[1] - edo[1]);\n                box.l = Math.min(box.l, x1, x2);\n                box.r = Math.max(box.r, x1, x2);\n                box.t = Math.min(box.t, y1, y2);\n                box.b = Math.max(box.b, y1, y2);\n            };\n            cappers[curve.PenLineCap.Flat] = function (box, metrics, thickness) {\n                var edo = vec2.clone(metrics.endVector);\n                if (!edo || !edo[0] || !edo[1])\n                    return;\n                vec2.orthogonal(vec2.normalize(edo));\n                var _a = metrics.endPoint, ex = _a[0], ey = _a[1];\n                var hs = thickness / 2.0;\n                var x1 = ex + hs * edo[0];\n                var x2 = ex + hs * -edo[0];\n                var y1 = ey + hs * edo[1];\n                var y2 = ey + hs * -edo[1];\n                box.l = Math.min(box.l, x1, x2);\n                box.r = Math.max(box.r, x1, x2);\n                box.t = Math.min(box.t, y1, y2);\n                box.b = Math.max(box.b, y1, y2);\n            };\n        })(stroke = bounds.stroke || (bounds.stroke = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var stroke;\n        (function (stroke) {\n            var vec2 = la.vec2;\n            function extendLineJoin(box, sx, sy, metrics, lastMetrics, pars) {\n                var hs = pars.strokeThickness / 2.0;\n                if (pars.strokeLineJoin === curve.PenLineJoin.Round) {\n                    box.l = Math.min(box.l, sx - hs);\n                    box.r = Math.max(box.r, sx + hs);\n                    box.t = Math.min(box.t, sy - hs);\n                    box.b = Math.max(box.b, sy + hs);\n                    return;\n                }\n                var tips = (pars.strokeLineJoin === curve.PenLineJoin.Miter)\n                    ? findMiterTips(sx, sy, metrics, lastMetrics, hs, pars.strokeMiterLimit)\n                    : findBevelTips(sx, sy, metrics, lastMetrics, hs);\n                if (!tips)\n                    return;\n                var x1 = tips[0][0], y1 = tips[0][1], x2 = tips[1][0], y2 = tips[1][1];\n                box.l = Math.min(box.l, x1, x2);\n                box.r = Math.max(box.r, x1, x2);\n                box.t = Math.min(box.t, y1, y2);\n                box.b = Math.max(box.b, y1, y2);\n            }\n            stroke.extendLineJoin = extendLineJoin;\n            function findMiterTips(sx, sy, metrics, lastMetrics, hs, miterLimit) {\n                var av = vec2.clone(lastMetrics.endVector);\n                var bv = vec2.clone(metrics.startVector);\n                if (!av || !bv)\n                    return null;\n                vec2.reverse(av);\n                var tau = vec2.angleBetween(av, bv) / 2;\n                if (isNaN(tau))\n                    return null;\n                var miterRatio = 1 / Math.sin(tau);\n                if (miterRatio > miterLimit)\n                    return findBevelTips(sx, sy, metrics, lastMetrics, hs);\n                var cv = vec2.isClockwiseTo(av, bv) ? vec2.clone(av) : vec2.clone(bv);\n                vec2.normalize(vec2.reverse(vec2.rotate(cv, tau)));\n                var miterLen = hs * miterRatio;\n                var tip = vec2.create(sx + miterLen * cv[0], sy + miterLen * cv[1]);\n                return [tip, tip];\n            }\n            function findBevelTips(sx, sy, metrics, lastMetrics, hs) {\n                var av = vec2.clone(lastMetrics.endVector);\n                var bv = vec2.clone(metrics.startVector);\n                if (!av || !bv)\n                    return;\n                vec2.normalize(vec2.reverse(av));\n                vec2.normalize(bv);\n                var avo = vec2.clone(av), bvo = vec2.clone(bv);\n                if (vec2.isClockwiseTo(av, bv)) {\n                    avo = vec2.orthogonal(av);\n                    bvo = vec2.reverse(vec2.orthogonal(bv));\n                }\n                else {\n                    avo = vec2.reverse(vec2.orthogonal(av));\n                    bvo = vec2.orthogonal(bv);\n                }\n                return [\n                    vec2.create(sx - hs * avo[0], sy - hs * avo[1]),\n                    vec2.create(sx - hs * bvo[0], sy - hs * bvo[1])\n                ];\n            }\n        })(stroke = bounds.stroke || (bounds.stroke = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var stroke;\n        (function (stroke) {\n            var vec2 = la.vec2;\n            function extendStartCap(box, sx, sy, metrics, pars) {\n                var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n                var func = cappers[cap] || cappers[curve.PenLineCap.Flat];\n                func(box, sx, sy, metrics, pars.strokeThickness);\n            }\n            stroke.extendStartCap = extendStartCap;\n            var cappers = [];\n            cappers[curve.PenLineCap.Round] = function (box, sx, sy, metrics, thickness) {\n                var hs = thickness / 2.0;\n                box.l = Math.min(box.l, sx - hs);\n                box.r = Math.max(box.r, sx + hs);\n                box.t = Math.min(box.t, sy - hs);\n                box.b = Math.max(box.b, sy + hs);\n            };\n            cappers[curve.PenLineCap.Square] = function (box, sx, sy, metrics, thickness) {\n                var sd = vec2.clone(metrics.startVector);\n                if (!sd || !sd[0] || !sd[1])\n                    return;\n                vec2.reverse(vec2.normalize(sd));\n                var sdo = vec2.orthogonal(vec2.clone(sd));\n                var hs = thickness / 2.0;\n                var x1 = sx + hs * (sd[0] + sdo[0]);\n                var x2 = sx + hs * (sd[0] - sdo[0]);\n                var y1 = sy + hs * (sd[1] + sdo[1]);\n                var y2 = sy + hs * (sd[1] - sdo[1]);\n                box.l = Math.min(box.l, x1, x2);\n                box.r = Math.max(box.r, x1, x2);\n                box.t = Math.min(box.t, y1, y2);\n                box.b = Math.max(box.b, y1, y2);\n            };\n            cappers[curve.PenLineCap.Flat] = function (box, sx, sy, metrics, thickness) {\n                var sdo = vec2.clone(metrics.startVector);\n                if (!sdo || !sdo[0] || !sdo[1])\n                    return;\n                vec2.orthogonal(vec2.normalize(sdo));\n                var hs = thickness / 2.0;\n                var x1 = sx + hs * sdo[0];\n                var x2 = sx + hs * -sdo[0];\n                var y1 = sy + hs * sdo[1];\n                var y2 = sy + hs * -sdo[1];\n                box.l = Math.min(box.l, x1, x2);\n                box.r = Math.max(box.r, x1, x2);\n                box.t = Math.min(box.t, y1, y2);\n                box.b = Math.max(box.b, y1, y2);\n            };\n        })(stroke = bounds.stroke || (bounds.stroke = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var stroke;\n        (function (stroke) {\n            var StartCapExtender = (function () {\n                function StartCapExtender() {\n                }\n                StartCapExtender.prototype.extend = function () {\n                };\n                return StartCapExtender;\n            })();\n            stroke.StartCapExtender = StartCapExtender;\n        })(stroke = bounds.stroke || (bounds.stroke = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var bounds;\n    (function (bounds) {\n        var stroke;\n        (function (stroke) {\n            var StrokeBounds = (function () {\n                function StrokeBounds(path) {\n                    this.l = 0;\n                    this.t = 0;\n                    this.r = 0;\n                    this.b = 0;\n                    this.$calc = false;\n                    Object.defineProperties(this, {\n                        \"path\": { value: path, writable: false }\n                    });\n                }\n                StrokeBounds.prototype.reset = function () {\n                    this.$calc = false;\n                    this.l = this.t = this.r = this.b = 0;\n                };\n                StrokeBounds.prototype.ensure = function () {\n                    if (!this.$calc)\n                        this.calculate();\n                    return this;\n                };\n                StrokeBounds.prototype.calculate = function () {\n                    var _this = this;\n                    this.$calc = false;\n                    this.l = Number.POSITIVE_INFINITY;\n                    this.t = Number.POSITIVE_INFINITY;\n                    this.r = Number.NEGATIVE_INFINITY;\n                    this.b = Number.NEGATIVE_INFINITY;\n                    var sx, sy, last, lastMetrics;\n                    var selector = new bounds.ExtenderSelector();\n                    this.path.exec(selector, function () {\n                        var cur = selector.current;\n                        var metrics = cur.init(sx, sy, selector.args);\n                        if (!cur.isMove) {\n                            if (last.isMove) {\n                                stroke.extendStartCap(_this, sx, sy, metrics, _this.pars);\n                            }\n                            else if (lastMetrics) {\n                                stroke.extendLineJoin(_this, sx, sy, metrics, lastMetrics, _this.pars);\n                            }\n                        }\n                        cur.extendStrokeBox(_this, sx, sy, selector.args, metrics, _this.pars);\n                        sx = metrics.endPoint[0];\n                        sy = metrics.endPoint[1];\n                        last = cur;\n                        lastMetrics = metrics;\n                    });\n                    if (lastMetrics)\n                        stroke.extendEndCap(this, lastMetrics, this.pars);\n                    this.$calc = true;\n                    return this;\n                };\n                return StrokeBounds;\n            })();\n            stroke.StrokeBounds = StrokeBounds;\n        })(stroke = bounds.stroke || (bounds.stroke = {}));\n    })(bounds = curve.bounds || (curve.bounds = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var compiler;\n    (function (compiler_1) {\n        function compile(arg0) {\n            var compiler = PathCompiler.instance;\n            compiler.compiled.length = 0;\n            if (typeof arg0 === \"string\") {\n                var parser = curve.parse.getParser();\n                parser.parse(compiler, arg0);\n            }\n            else if (typeof arg0.exec === \"function\") {\n                arg0.exec(compiler);\n            }\n            return compiler.compiled;\n        }\n        compiler_1.compile = compile;\n        var PathCompiler = (function () {\n            function PathCompiler() {\n                this.compiled = [];\n            }\n            PathCompiler.prototype.setFillRule = function (fillRule) {\n                this.compiled.push({ t: CompiledOpType.setFillRule, a: [fillRule] });\n            };\n            PathCompiler.prototype.closePath = function () {\n                this.compiled.push({ t: CompiledOpType.closePath, a: [] });\n            };\n            PathCompiler.prototype.moveTo = function (x, y) {\n                this.compiled.push({ t: CompiledOpType.moveTo, a: [x, y] });\n            };\n            PathCompiler.prototype.lineTo = function (x, y) {\n                this.compiled.push({ t: CompiledOpType.lineTo, a: [x, y] });\n            };\n            PathCompiler.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n                this.compiled.push({ t: CompiledOpType.bezierCurveTo, a: [cp1x, cp1y, cp2x, cp2y, x, y] });\n            };\n            PathCompiler.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n                this.compiled.push({ t: CompiledOpType.quadraticCurveTo, a: [cpx, cpy, x, y] });\n            };\n            PathCompiler.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {\n                this.compiled.push({ t: CompiledOpType.arc, a: [x, y, radius, startAngle, endAngle, anticlockwise] });\n            };\n            PathCompiler.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n                this.compiled.push({ t: CompiledOpType.arcTo, a: [x1, y1, x2, y2, radius] });\n            };\n            PathCompiler.prototype.ellipse = function (cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise) {\n                this.compiled.push({\n                    t: CompiledOpType.ellipse,\n                    a: [cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise]\n                });\n            };\n            PathCompiler.instance = new PathCompiler();\n            return PathCompiler;\n        })();\n    })(compiler = curve.compiler || (curve.compiler = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var compiler;\n    (function (compiler) {\n        function decompile(runner, compiled) {\n            for (var i = 0; !!compiled && i < compiled.length; i++) {\n                var seg = compiled[i];\n                var typeStr = void 0;\n                if (typeof seg.t !== \"number\" || !(typeStr = CompiledOpType[seg.t])) {\n                    console.warn(\"Unknown compiled path command: \" + seg.t + \", \" + seg.a);\n                    continue;\n                }\n                var func = runner[typeStr];\n                func && func.apply(runner, seg.a);\n            }\n        }\n        compiler.decompile = decompile;\n    })(compiler = curve.compiler || (curve.compiler = {}));\n})(curve || (curve = {}));\nvar CompiledOpType;\n(function (CompiledOpType) {\n    CompiledOpType[CompiledOpType[\"setFillRule\"] = 1] = \"setFillRule\";\n    CompiledOpType[CompiledOpType[\"closePath\"] = 2] = \"closePath\";\n    CompiledOpType[CompiledOpType[\"moveTo\"] = 3] = \"moveTo\";\n    CompiledOpType[CompiledOpType[\"lineTo\"] = 4] = \"lineTo\";\n    CompiledOpType[CompiledOpType[\"bezierCurveTo\"] = 5] = \"bezierCurveTo\";\n    CompiledOpType[CompiledOpType[\"quadraticCurveTo\"] = 6] = \"quadraticCurveTo\";\n    CompiledOpType[CompiledOpType[\"arc\"] = 7] = \"arc\";\n    CompiledOpType[CompiledOpType[\"arcTo\"] = 8] = \"arcTo\";\n    CompiledOpType[CompiledOpType[\"ellipse\"] = 9] = \"ellipse\";\n})(CompiledOpType || (CompiledOpType = {}));\nvar curve;\n(function (curve) {\n    var ellipticalArc;\n    (function (ellipticalArc) {\n        var vec2 = la.vec2;\n        function fromEllipse(cx, cy, rx, ry, phi, sa, ea, ac) {\n            var ap = vec2.rotate(vec2.create(rx * Math.cos(sa), ry * Math.sin(sa)), phi);\n            ap[0] += cx;\n            ap[1] += cy;\n            var bp = vec2.rotate(vec2.create(rx * Math.cos(ea), ry * Math.sin(ea)), phi);\n            bp[0] += cx;\n            bp[1] += cy;\n            var da = ea - sa;\n            var fa = Math.abs(da) > Math.PI ? 1 : 0;\n            var expac = Math.abs(sa - ea) ? ea < sa : sa > ea;\n            fa = (expac !== ac) ? 1 - fa : fa;\n            var fs = ac === true ? 0 : 1;\n            return {\n                sx: ap[0],\n                sy: ap[1],\n                ex: bp[0],\n                ey: bp[1],\n                fa: fa,\n                fs: fs,\n                rx: rx,\n                ry: ry,\n                phi: phi\n            };\n        }\n        ellipticalArc.fromEllipse = fromEllipse;\n    })(ellipticalArc = curve.ellipticalArc || (curve.ellipticalArc = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var ellipticalArc;\n    (function (ellipticalArc) {\n        function correctRadii(rx, ry, apx, apy) {\n            rx = Math.abs(rx);\n            ry = Math.abs(ry);\n            var lambda = ((apx * apx) / (rx * rx)) + ((apy * apy) / (ry * ry));\n            if (lambda > 1) {\n                var rl = Math.sqrt(lambda);\n                rx *= rl;\n                ry *= rl;\n            }\n            return [rx, ry];\n        }\n        ellipticalArc.correctRadii = correctRadii;\n    })(ellipticalArc = curve.ellipticalArc || (curve.ellipticalArc = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var ellipticalArc;\n    (function (ellipticalArc) {\n        var vec2 = la.vec2;\n        var PI2 = 2 * Math.PI;\n        function toEllipse(sx, sy, rx, ry, phi, fa, fs, ex, ey) {\n            if (rx === 0 || ry === 0) {\n                return { cx: ex, cy: ey, rx: rx, ry: ry };\n            }\n            var ap = vec2.create((sx - ex) / 2.0, (sy - ey) / 2.0);\n            vec2.rotate(ap, -phi);\n            _a = ellipticalArc.correctRadii(rx, ry, ap[0], ap[1]), rx = _a[0], ry = _a[1];\n            var rx2 = rx * rx;\n            var ry2 = ry * ry;\n            var apx2 = ap[0] * ap[0];\n            var apy2 = ap[1] * ap[1];\n            var factor = Math.sqrt(((rx2 * ry2) - (rx2 * apy2) - (ry2 * apx2)) / ((rx2 * apy2) + (ry2 * apx2)));\n            if (fa === fs) {\n                factor *= -1;\n            }\n            var cp = vec2.create(rx * ap[1] / ry, -ry * ap[0] / rx);\n            cp[0] *= factor;\n            cp[1] *= factor;\n            var c = vec2.rotate(vec2.clone(cp), phi);\n            c[0] += (sx + ex) / 2.0;\n            c[1] += (sy + ey) / 2.0;\n            var v = vec2.create(1, 0);\n            var u = vec2.create((ap[0] - cp[0]) / rx, (ap[1] - cp[1]) / ry);\n            var sa = vec2.angleBetween(v, u) * signAdjust(v, u);\n            if (sa < 0) {\n                sa += PI2;\n            }\n            v = vec2.create((-ap[0] - cp[0]) / rx, (-ap[1] - cp[1]) / ry);\n            var dt = (vec2.angleBetween(u, v) * signAdjust(u, v)) % PI2;\n            if (fs === 0 && dt > 0) {\n                dt -= PI2;\n            }\n            else if (fs === 1 && dt < 0) {\n                dt += PI2;\n            }\n            var ea = (sa + dt) % PI2;\n            if (ea < 0) {\n                ea += PI2;\n            }\n            var ac = fs === 0;\n            return {\n                cx: c[0],\n                cy: c[1],\n                rx: rx,\n                ry: ry,\n                phi: phi,\n                sa: sa,\n                ea: ea,\n                ac: ac\n            };\n            var _a;\n        }\n        ellipticalArc.toEllipse = toEllipse;\n        function signAdjust(u, v) {\n            return ((u[0] * v[1]) - (u[1] * v[0])) < 0 ? -1 : 1;\n        }\n    })(ellipticalArc = curve.ellipticalArc || (curve.ellipticalArc = {}));\n})(curve || (curve = {}));\nvar FillRule;\n(function (FillRule) {\n    FillRule[FillRule[\"EvenOdd\"] = 0] = \"EvenOdd\";\n    FillRule[FillRule[\"NonZero\"] = 1] = \"NonZero\";\n})(FillRule || (FillRule = {}));\nvar SweepDirection;\n(function (SweepDirection) {\n    SweepDirection[SweepDirection[\"Counterclockwise\"] = 0] = \"Counterclockwise\";\n    SweepDirection[SweepDirection[\"Clockwise\"] = 1] = \"Clockwise\";\n})(SweepDirection || (SweepDirection = {}));\nvar curve;\n(function (curve) {\n    var parse;\n    (function (parse) {\n        var buffer;\n        (function (buffer_1) {\n            var Parser = (function () {\n                function Parser() {\n                }\n                Parser.prototype.parse = function (runner, data) {\n                    var buffer = toBuffer(data);\n                    return undefined;\n                };\n                return Parser;\n            })();\n            buffer_1.Parser = Parser;\n            function parseNumber(tracker) {\n                var start = tracker.offset;\n                var data = tracker.data;\n                var len = data.length;\n                if (isNaN(data, tracker.offset)) {\n                    tracker.offset += 3;\n                    return NaN;\n                }\n                var negate = false;\n                if (data[tracker.offset] === 0x2D) {\n                    negate = true;\n                    tracker.offset++;\n                }\n                else if (data[tracker.offset] === 0x2B) {\n                    tracker.offset++;\n                }\n                if (isInfinity(data, tracker.offset)) {\n                    tracker.offset += 8;\n                    return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n                }\n                parseInteger(tracker);\n                var cur = data[tracker.offset];\n                if (cur === 0x2E) {\n                    tracker.offset++;\n                    if (!parseMantissa(tracker))\n                        throw new Error(\"Invalid number\");\n                }\n                if (!parseSignificand(tracker))\n                    throw new Error(\"Invalid number\");\n                return parseFloat(getSlice(data, start, tracker.offset - start));\n            }\n            buffer_1.parseNumber = parseNumber;\n            function toBuffer(data) {\n                if (data instanceof Uint8Array)\n                    return data;\n                if (typeof TextEncoder === \"function\")\n                    return new TextEncoder().encode(data);\n            }\n            function isNaN(data, i) {\n                return data[i + 0] === 0x4E\n                    && data[i + 1] === 0x61\n                    && data[i + 2] === 0x4E;\n            }\n            function isInfinity(data, i) {\n                return data[i + 0] === 0x49\n                    && data[i + 1] === 0x6E\n                    && data[i + 2] === 0x66\n                    && data[i + 3] === 0x69\n                    && data[i + 4] === 0x6E\n                    && data[i + 5] === 0x69\n                    && data[i + 6] === 0x74\n                    && data[i + 7] === 0x79;\n            }\n            function parseInteger(tracker) {\n                var start = tracker.offset;\n                var data = tracker.data;\n                var cur;\n                while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n                    tracker.offset++;\n                }\n                return tracker.offset !== start;\n            }\n            function parseMantissa(tracker) {\n                var start = tracker.offset;\n                var data = tracker.data;\n                var cur;\n                while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n                    tracker.offset++;\n                }\n                return tracker.offset !== start;\n            }\n            function parseSignificand(tracker) {\n                var data = tracker.data;\n                if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\n                    return true;\n                tracker.offset++;\n                var cur = data[tracker.offset];\n                if (cur === 0x2D || cur === 0x2B)\n                    tracker.offset++;\n                return parseInteger(tracker);\n            }\n            function getSlice(data, offset, length) {\n                var buf = new Array(length);\n                for (var i = 0; i < length; i++) {\n                    buf[i] = data[offset + i];\n                }\n                return String.fromCharCode.apply(null, buf);\n            }\n        })(buffer = parse.buffer || (parse.buffer = {}));\n    })(parse = curve.parse || (curve.parse = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var parse;\n    (function (parse) {\n        var dom;\n        (function (dom) {\n            var domsvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n            var dompath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            var Parser = (function () {\n                function Parser() {\n                }\n                Parser.prototype.parse = function (runner, data) {\n                    if (typeof data !== \"string\") {\n                        console.warn(\"Input parse data was not a string.\", data);\n                        return;\n                    }\n                    dompath.setAttribute(\"d\", data);\n                    var segments = dompath.pathSegList, cur = [0, 0];\n                    for (var i = 0, len = segments.numberOfItems; i < len; i++) {\n                        parseSegment(runner, segments.getItem(i), cur);\n                    }\n                };\n                return Parser;\n            })();\n            dom.Parser = Parser;\n            function parseSegment(runner, segment, cur) {\n                switch (segment.pathSegType) {\n                    case SVGPathSeg.PATHSEG_ARC_ABS:\n                        var arc1 = segment;\n                        var ell1 = curve.ellipticalArc.toEllipse(cur[0], cur[1], arc1.r1, arc1.r2, arc1.angle, arc1.largeArcFlag ? 1 : 0, arc1.sweepFlag ? 1 : 0, arc1.x, arc1.y);\n                        if (!ell1.rx || !ell1.ry)\n                            runner.lineTo(ell1.cx, ell1.cy);\n                        else\n                            runner.ellipse(ell1.cx, ell1.cy, ell1.rx, ell1.ry, ell1.phi, ell1.sa, ell1.ea, ell1.ac);\n                        cur[0] = arc1.x;\n                        cur[1] = arc1.y;\n                        break;\n                    case SVGPathSeg.PATHSEG_ARC_REL:\n                        var arc2 = segment;\n                        var ell2 = curve.ellipticalArc.toEllipse(cur[0], cur[1], arc2.r1, arc2.r2, arc2.angle, arc2.largeArcFlag ? 1 : 0, arc2.sweepFlag ? 1 : 0, cur[0] + arc2.x, cur[1] + arc2.y);\n                        if (!ell2.rx || !ell2.ry)\n                            runner.lineTo(ell2.cx, ell2.cy);\n                        else\n                            runner.ellipse(ell2.cx, ell2.cy, ell2.rx, ell2.ry, ell2.phi, ell2.sa, ell2.ea, ell2.ac);\n                        cur[0] += arc2.x;\n                        cur[1] += arc2.y;\n                        break;\n                    case SVGPathSeg.PATHSEG_CLOSEPATH:\n                        runner.closePath();\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                        var curve1 = segment;\n                        runner.bezierCurveTo(curve1.x1, curve1.y1, curve1.x2, curve1.y2, curve1.x, curve1.y);\n                        cur[0] = curve1.x;\n                        cur[1] = curve1.y;\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                        var curve2 = segment;\n                        runner.bezierCurveTo(cur[0] + curve2.x1, cur[1] + curve2.y1, cur[0] + curve2.x2, cur[1] + curve2.y2, cur[0] + curve2.x, cur[1] + curve2.y);\n                        cur[0] += curve2.x;\n                        cur[1] += curve2.y;\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                        var curve3 = segment;\n                        smoothCubic(runner, curve3.x2, curve3.y2, curve3.x, curve3.y, cur);\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                        var curve4 = segment;\n                        smoothCubic(runner, cur[0] + curve4.x2, cur[1] + curve4.y2, cur[0] + curve4.x, cur[1] + curve4.y, cur);\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                        var curve5 = segment;\n                        runner.quadraticCurveTo(curve5.x1, curve5.y1, curve5.x, curve5.y);\n                        cur[0] = curve5.x;\n                        cur[1] = curve5.y;\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                        var curve6 = segment;\n                        runner.quadraticCurveTo(cur[0] + curve6.x1, cur[1] + curve6.y1, cur[0] + curve6.x, cur[1] + curve6.y);\n                        cur[0] += curve6.x;\n                        cur[1] += curve6.y;\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                        var curve7 = segment;\n                        smoothQuadratic(runner, curve7.x, curve7.y, cur);\n                        break;\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                        var curve8 = segment;\n                        smoothQuadratic(runner, cur[0] + curve8.x, cur[1] + curve8.y, cur);\n                        break;\n                    case SVGPathSeg.PATHSEG_LINETO_ABS:\n                        var line1 = segment;\n                        cur[0] = line1.x;\n                        cur[1] = line1.y;\n                        runner.lineTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                        var line2 = segment;\n                        cur[0] = line2.x;\n                        runner.lineTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                        var line3 = segment;\n                        cur[0] += line3.x;\n                        runner.lineTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_LINETO_REL:\n                        var line4 = segment;\n                        cur[0] += line4.x;\n                        cur[1] += line4.y;\n                        runner.lineTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                        var line5 = segment;\n                        cur[1] = line5.y;\n                        runner.lineTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                        var line6 = segment;\n                        cur[1] += line6.y;\n                        runner.lineTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_MOVETO_ABS:\n                        var move1 = segment;\n                        cur[0] = move1.x;\n                        cur[1] = move1.y;\n                        runner.moveTo(cur[0], cur[1]);\n                        break;\n                    case SVGPathSeg.PATHSEG_MOVETO_REL:\n                        var move2 = segment;\n                        cur[0] += move2.x;\n                        cur[1] += move2.y;\n                        runner.moveTo(cur[0], cur[1]);\n                        break;\n                    default:\n                    case SVGPathSeg.PATHSEG_UNKNOWN:\n                        console.warn(\"Unknown path segment.\");\n                        break;\n                }\n            }\n            function smoothCubic(runner, x2, y2, x, y, cur) {\n                var cx = cur[0], cy = cur[1];\n                console.warn(\"Smooth cubic\", \"Not implemented\");\n            }\n            function smoothQuadratic(runner, x, y, cur) {\n                var cx = cur[0], cy = cur[1];\n                console.warn(\"Smooth quadratic\", \"Not implemented\");\n            }\n        })(dom = parse.dom || (parse.dom = {}));\n    })(parse = curve.parse || (curve.parse = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var parse;\n    (function (parse) {\n        (function (ParseStyles) {\n            ParseStyles[ParseStyles[\"Dom\"] = 1] = \"Dom\";\n            ParseStyles[ParseStyles[\"Buffer\"] = 2] = \"Buffer\";\n            ParseStyles[ParseStyles[\"CharMatching\"] = 3] = \"CharMatching\";\n        })(parse.ParseStyles || (parse.ParseStyles = {}));\n        var ParseStyles = parse.ParseStyles;\n    })(parse = curve.parse || (curve.parse = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var parse;\n    (function (parse) {\n        parse.style = parse.ParseStyles.CharMatching;\n        function getParser() {\n            if (parse.style === parse.ParseStyles.Buffer)\n                return new parse.buffer.Parser();\n            else if (parse.style === parse.ParseStyles.Dom)\n                return new parse.dom.Parser();\n            return new parse.matching.Parser();\n        }\n        parse.getParser = getParser;\n    })(parse = curve.parse || (curve.parse = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var parse;\n    (function (parse_1) {\n        var matching;\n        (function (matching) {\n            var Parser = (function () {\n                function Parser() {\n                }\n                Parser.prototype.parse = function (runner, data) {\n                    if (typeof data === \"string\")\n                        parse(runner, data, data.length);\n                    else\n                        console.warn(\"Input parse data was not a string.\", data);\n                };\n                return Parser;\n            })();\n            matching.Parser = Parser;\n            function parse(runner, str, len) {\n                var index = 0;\n                go();\n                function go() {\n                    var cp = { x: 0, y: 0 };\n                    var cp1, cp2, cp3;\n                    var start = { x: 0, y: 0 };\n                    var cbz = false;\n                    var qbz = false;\n                    var cbzp = { x: 0, y: 0 };\n                    var qbzp = { x: 0, y: 0 };\n                    var ell;\n                    while (index < len) {\n                        var c;\n                        while (index < len && (c = str.charAt(index)) === ' ') {\n                            index++;\n                        }\n                        index++;\n                        var relative = false;\n                        switch (c) {\n                            case 'f':\n                            case 'F':\n                                c = str.charAt(index);\n                                if (c === '0')\n                                    runner.setFillRule(FillRule.EvenOdd);\n                                else if (c === '1')\n                                    runner.setFillRule(FillRule.NonZero);\n                                else\n                                    return null;\n                                index++;\n                                c = str.charAt(index);\n                                break;\n                            case 'm':\n                                relative = true;\n                            case 'M':\n                                cp1 = parsePoint();\n                                if (cp1 == null)\n                                    break;\n                                if (relative) {\n                                    cp1.x += cp.x;\n                                    cp1.y += cp.y;\n                                }\n                                runner.moveTo(cp1.x, cp1.y);\n                                start.x = cp.x = cp1.x;\n                                start.y = cp.y = cp1.y;\n                                advance();\n                                while (morePointsAvailable()) {\n                                    if ((cp1 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp1.x += cp.x;\n                                        cp1.y += cp.y;\n                                    }\n                                    runner.lineTo(cp1.x, cp1.y);\n                                }\n                                cp.x = cp1.x;\n                                cp.y = cp1.y;\n                                cbz = qbz = false;\n                                break;\n                            case 'l':\n                                relative = true;\n                            case 'L':\n                                while (morePointsAvailable()) {\n                                    if ((cp1 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp1.x += cp.x;\n                                        cp1.y += cp.y;\n                                    }\n                                    runner.lineTo(cp1.x, cp1.y);\n                                    cp.x = cp1.x;\n                                    cp.y = cp1.y;\n                                    advance();\n                                }\n                                cbz = qbz = false;\n                                break;\n                            case 'h':\n                                relative = true;\n                            case 'H':\n                                var x = parseDouble();\n                                if (x == null)\n                                    break;\n                                if (relative)\n                                    x += cp.x;\n                                cp = { x: x, y: cp.y };\n                                runner.lineTo(cp.x, cp.y);\n                                cbz = qbz = false;\n                                break;\n                            case 'v':\n                                relative = true;\n                            case 'V':\n                                var y = parseDouble();\n                                if (y == null)\n                                    break;\n                                if (relative)\n                                    y += cp.y;\n                                cp = { x: cp.x, y: y };\n                                runner.lineTo(cp.x, cp.y);\n                                cbz = qbz = false;\n                                break;\n                            case 'c':\n                                relative = true;\n                            case 'C':\n                                while (morePointsAvailable()) {\n                                    if ((cp1 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp1.x += cp.x;\n                                        cp1.y += cp.y;\n                                    }\n                                    advance();\n                                    if ((cp2 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp2.x += cp.x;\n                                        cp2.y += cp.y;\n                                    }\n                                    advance();\n                                    if ((cp3 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp3.x += cp.x;\n                                        cp3.y += cp.y;\n                                    }\n                                    advance();\n                                    runner.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n                                    cp1.x = cp3.x;\n                                    cp1.y = cp3.y;\n                                }\n                                cp.x = cp3.x;\n                                cp.y = cp3.y;\n                                cbz = true;\n                                cbzp.x = cp2.x;\n                                cbzp.y = cp2.y;\n                                qbz = false;\n                                break;\n                            case 's':\n                                relative = true;\n                            case 'S':\n                                while (morePointsAvailable()) {\n                                    if ((cp2 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp2.x += cp.x;\n                                        cp2.y += cp.y;\n                                    }\n                                    advance();\n                                    if ((cp3 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp3.x += cp.x;\n                                        cp3.y += cp.y;\n                                    }\n                                    if (cbz) {\n                                        cp1.x = 2 * cp.x - cbzp.x;\n                                        cp1.y = 2 * cp.y - cbzp.y;\n                                    }\n                                    else\n                                        cp1 = cp;\n                                    runner.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n                                    cbz = true;\n                                    cbzp.x = cp2.x;\n                                    cbzp.y = cp2.y;\n                                    cp.x = cp3.x;\n                                    cp.y = cp3.y;\n                                    advance();\n                                }\n                                qbz = false;\n                                break;\n                            case 'q':\n                                relative = true;\n                            case 'Q':\n                                while (morePointsAvailable()) {\n                                    if ((cp1 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp1.x += cp.x;\n                                        cp1.y += cp.y;\n                                    }\n                                    advance();\n                                    if ((cp2 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp2.x += cp.x;\n                                        cp2.y += cp.y;\n                                    }\n                                    advance();\n                                    runner.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n                                    cp.x = cp2.x;\n                                    cp.y = cp2.y;\n                                }\n                                qbz = true;\n                                qbzp.x = cp1.x;\n                                qbzp.y = cp1.y;\n                                cbz = false;\n                                break;\n                            case 't':\n                                relative = true;\n                            case 'T':\n                                while (morePointsAvailable()) {\n                                    if ((cp2 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp2.x += cp.x;\n                                        cp2.y += cp.y;\n                                    }\n                                    if (qbz) {\n                                        cp1.x = 2 * cp.x - qbzp.x;\n                                        cp1.y = 2 * cp.y - qbzp.y;\n                                    }\n                                    else\n                                        cp1 = cp;\n                                    runner.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n                                    qbz = true;\n                                    qbzp.x = cp1.x;\n                                    qbzp.y = cp1.y;\n                                    cp.x = cp2.x;\n                                    cp.y = cp2.y;\n                                    advance();\n                                }\n                                cbz = false;\n                                break;\n                            case 'a':\n                                relative = true;\n                            case 'A':\n                                while (morePointsAvailable()) {\n                                    if ((cp1 = parsePoint()) == null)\n                                        break;\n                                    var angle = parseDouble();\n                                    var is_large = parseDouble() !== 0 ? 1 : 0;\n                                    var sweep = SweepDirection.Counterclockwise;\n                                    if (parseDouble() !== 0)\n                                        sweep = SweepDirection.Clockwise;\n                                    if ((cp2 = parsePoint()) == null)\n                                        break;\n                                    if (relative) {\n                                        cp2.x += cp.x;\n                                        cp2.y += cp.y;\n                                    }\n                                    var phi = angle * Math.PI / 180.0;\n                                    ell = curve.ellipticalArc.toEllipse(cp.x, cp.y, cp1.x, cp1.y, phi, is_large, sweep, cp2.x, cp2.y);\n                                    if (!ell.rx || !ell.ry)\n                                        runner.lineTo(ell.cx, ell.cy);\n                                    else\n                                        runner.ellipse(ell.cx, ell.cy, ell.rx, ell.ry, ell.phi, ell.sa, ell.ea, ell.ac);\n                                    cp.x = cp2.x;\n                                    cp.y = cp2.y;\n                                    advance();\n                                }\n                                cbz = qbz = false;\n                                break;\n                            case 'z':\n                            case 'Z':\n                                runner.closePath();\n                                cp.x = start.x;\n                                cp.y = start.y;\n                                cbz = qbz = false;\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                }\n                function parsePoint() {\n                    var x = parseDouble();\n                    if (x == null)\n                        return null;\n                    var c;\n                    while (index < len && ((c = str.charAt(index)) === ' ' || c === ',')) {\n                        index++;\n                    }\n                    if (index >= len)\n                        return null;\n                    var y = parseDouble();\n                    if (y == null)\n                        return null;\n                    return { x: x, y: y };\n                }\n                function parseDouble() {\n                    advance();\n                    var isNegative = false;\n                    if (match('-')) {\n                        isNegative = true;\n                        index++;\n                    }\n                    else if (match('+')) {\n                        index++;\n                    }\n                    if (match('Infinity')) {\n                        index += 8;\n                        return isNegative ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n                    }\n                    if (match('NaN'))\n                        return NaN;\n                    var temp = '';\n                    while (index < len) {\n                        var code = str.charCodeAt(index);\n                        var c = str[index];\n                        if (code >= 48 && code <= 57)\n                            temp += c;\n                        else if (code === 46)\n                            temp += c;\n                        else if (c === 'E' || c === 'e') {\n                            temp += c;\n                            if (str[index + 1] === '-') {\n                                temp += '-';\n                                index++;\n                            }\n                        }\n                        else\n                            break;\n                        index++;\n                    }\n                    if (temp.length === 0)\n                        return null;\n                    var f = parseFloat(temp);\n                    return isNegative ? -f : f;\n                }\n                function advance() {\n                    var code;\n                    var c;\n                    while (index < len) {\n                        code = str.charCodeAt(index);\n                        if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122) || (code >= 48 && code <= 57))\n                            break;\n                        c = String.fromCharCode(code);\n                        if (c === '.')\n                            break;\n                        if (c === '-')\n                            break;\n                        if (c === '+')\n                            break;\n                        index++;\n                    }\n                }\n                function match(matchStr) {\n                    var c1;\n                    var c2;\n                    for (var i = 0; i < matchStr.length && (index + i) < len; i++) {\n                        c1 = matchStr.charAt(i);\n                        c2 = str.charAt(index + i);\n                        if (c1 !== c2)\n                            return false;\n                    }\n                    return true;\n                }\n                function morePointsAvailable() {\n                    var c;\n                    while (index < len && ((c = str.charAt(index)) === ',' || c === ' ')) {\n                        index++;\n                    }\n                    if (index >= len)\n                        return false;\n                    if (c === '.' || c === '-' || c === '+')\n                        return true;\n                    var code = str.charCodeAt(index);\n                    return code >= 48 && code <= 57;\n                }\n            }\n        })(matching = parse_1.matching || (parse_1.matching = {}));\n    })(parse = curve.parse || (curve.parse = {}));\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var Path = (function () {\n        function Path(arg0) {\n            this.$ops = [];\n            if (arg0 instanceof Path) {\n                arg0.exec(this);\n            }\n            else if (Array.isArray(arg0)) {\n                new curve.compiler.decompile(this, arg0);\n            }\n            else if (typeof arg0 === \"string\") {\n                var parser = curve.parse.getParser();\n                parser.parse(this, arg0);\n            }\n        }\n        Object.defineProperty(Path.prototype, \"isEmpty\", {\n            get: function () {\n                return this.$ops.length < 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Path.prototype.reset = function () {\n            this.$ops.length = 0;\n        };\n        Path.prototype.exec = function (runner, step) {\n            for (var ops = this.$ops, i = 0; ops && i < ops.length; i++) {\n                ops[i](runner);\n                step && step();\n            }\n        };\n        Path.prototype.draw = function (ctx) {\n            this.exec(ctx);\n        };\n        Path.prototype.addPath = function (path) {\n            path.exec(this);\n        };\n        Path.prototype.setFillRule = function (fillRule) {\n            this.$ops.push(function (exec) { return exec.setFillRule(fillRule); });\n        };\n        Path.prototype.closePath = function () {\n            this.$ops.push(function (exec) { return exec.closePath(); });\n        };\n        Path.prototype.moveTo = function (x, y) {\n            this.$ops.push(function (exec) { return exec.moveTo(x, y); });\n        };\n        Path.prototype.lineTo = function (x, y) {\n            this.$ops.push(function (exec) { return exec.lineTo(x, y); });\n        };\n        Path.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n            this.$ops.push(function (exec) { return exec.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); });\n        };\n        Path.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n            this.$ops.push(function (exec) { return exec.quadraticCurveTo(cpx, cpy, x, y); });\n        };\n        Path.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {\n            this.$ops.push(function (exec) { return exec.arc(x, y, radius, startAngle, endAngle, anticlockwise); });\n        };\n        Path.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n            this.$ops.push(function (exec) { return exec.arcTo(x1, y1, x2, y2, radius); });\n        };\n        Path.prototype.ellipse = function (cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise) {\n            this.$ops.push(function (exec) { return exec.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise); });\n        };\n        Path.parse = function (runner, data) {\n            var parser = curve.parse.getParser();\n            parser.parse(runner, data);\n        };\n        return Path;\n    })();\n    curve.Path = Path;\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var proto = CanvasRenderingContext2D.prototype;\n    if (!proto.ellipse) {\n        proto.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n            this.save();\n            this.translate(x, y);\n            this.rotate(rotation);\n            this.scale(radiusX, radiusY);\n            this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n            this.restore();\n        };\n    }\n})(curve || (curve = {}));\nvar curve;\n(function (curve) {\n    var proto = CanvasRenderingContext2D.prototype;\n    if (!proto.setFillRule) {\n        proto.setFillRule = function (arg) {\n            this.fillRule = arg;\n        };\n    }\n})(curve || (curve = {}));\n(function (global) {\n    if (typeof global.TextEncoder === \"function\")\n        return;\n    global.TextEncoder = (function () {\n        function TextEncoder() {\n            Object.defineProperties(this, {\n                \"encoding\": { value: \"utf-8\", writable: false }\n            });\n        }\n        TextEncoder.prototype.encode = function (str) {\n            var buf = new ArrayBuffer(str.length);\n            var arr = new Uint8Array(buf);\n            for (var i = 0; i < arr.length; i++) {\n                arr[i] = str.charCodeAt(i);\n            }\n            return arr;\n        };\n        return TextEncoder;\n    })();\n})(this);\nvar curve;\n(function (curve) {\n    function serialize(path, pretty) {\n        var serializer = new Serializer(pretty);\n        path.exec(serializer);\n        return serializer.data;\n    }\n    curve.serialize = serialize;\n    var Serializer = (function () {\n        function Serializer(pretty) {\n            this.data = \"\";\n            this.pretty = pretty === true;\n        }\n        Serializer.prototype.setFillRule = function (fillRule) {\n            this.prepend().data += \"F\" + fillRule;\n        };\n        Serializer.prototype.closePath = function () {\n            this.prepend().data += \"Z\";\n        };\n        Serializer.prototype.moveTo = function (x, y) {\n            if (this.pretty) {\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += \"M\" + x + \",\" + y;\n            this.prev = { x: x, y: y };\n        };\n        Serializer.prototype.lineTo = function (x, y) {\n            if (this.pretty) {\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += \"L\" + x + \",\" + y;\n            this.prev = { x: x, y: y };\n        };\n        Serializer.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n            if (this.pretty) {\n                cp1x = round(cp1x, 2);\n                cp1y = round(cp1y, 2);\n                cp2x = round(cp2x, 2);\n                cp2y = round(cp2y, 2);\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += \"C\" + cp1x + \",\" + cp1y + \",\" + cp2x + \",\" + cp2y + \",\" + x + \",\" + y;\n            this.prev = { x: x, y: y };\n        };\n        Serializer.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n            if (this.pretty) {\n                cpx = round(cpx, 2);\n                cpy = round(cpy, 2);\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += \"Q\" + cpx + \",\" + cpy + \",\" + x + \",\" + y;\n            this.prev = { x: x, y: y };\n        };\n        Serializer.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {\n        };\n        Serializer.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n        };\n        Serializer.prototype.ellipse = function (cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise) {\n            var earc = curve.ellipticalArc.fromEllipse(cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise);\n            earc.phi = earc.phi * 180 / Math.PI;\n            if (this.pretty) {\n                earc.sx = round(earc.sx, 2);\n                earc.sy = round(earc.sy, 2);\n                earc.rx = round(earc.rx, 2);\n                earc.ry = round(earc.ry, 2);\n                earc.phi = round(earc.phi, 2);\n                earc.ex = round(earc.ex, 2);\n                earc.ey = round(earc.ey, 2);\n            }\n            if (this.prev && close(this.prev.x, earc.sx) && close(this.prev.y, earc.sy))\n                this.prepend().data += \"A\" + earc.rx + \",\" + earc.ry + \" \" + earc.phi + \" \" + earc.fa + \" \" + earc.fs + \" \" + earc.ex + \",\" + earc.ey;\n            else\n                this.prepend().data += \"L\" + earc.sx + \",\" + earc.sy + \" A\" + earc.rx + \",\" + earc.ry + \" \" + earc.phi + \" \" + earc.fa + \" \" + earc.fs + \" \" + earc.ex + \",\" + earc.ey;\n        };\n        Serializer.prototype.prepend = function () {\n            if (this.data)\n                this.data += \" \";\n            return this;\n        };\n        return Serializer;\n    })();\n    var EPSILON = 1e-4;\n    function close(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n    function round(a, digits) {\n        var factor = Math.pow(10, digits);\n        return Math.round(a * factor) / factor;\n    }\n})(curve || (curve = {}));\n","interface ISegmentExecutor {\n    exec(runner: ISegmentRunner, step?: Function);\n}\n\ninterface ISegmentRunner {\n    setFillRule(fillRule: FillRule);\n    closePath();\n    moveTo(x: number, y: number);\n    lineTo(x: number, y: number);\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number);\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number);\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean);\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number);\n    ellipse(cx: number, cy: number, rx: number, ry: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean);\n}\n\ninterface ISegment {\n    (runner: ISegmentRunner): void;\n}\n\nenum FillRule {\n    EvenOdd = 0,\n    NonZero = 1\n}\n\nenum SweepDirection {\n    Counterclockwise = 0,\n    Clockwise = 1,\n}\n\ninterface CanvasRenderingContext2D extends ISegmentRunner {\n}\n","namespace curve.parse.buffer {\n    export class Parser implements IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array) {\n            var buffer = toBuffer(data);\n            //TODO: Implement\n            return undefined;\n        }\n    }\n\n    export function parseNumber(tracker: IParseTracker): number {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var len = data.length;\n        //NaN\n        if (isNaN(data, tracker.offset)) {\n            tracker.offset += 3;\n            return NaN;\n        }\n\n        //Check - or +\n        var negate = false;\n        if (data[tracker.offset] === 0x2D) {\n            negate = true;\n            tracker.offset++;\n        } else if (data[tracker.offset] === 0x2B) {\n            tracker.offset++;\n        }\n\n        //Infinity\n        if (isInfinity(data, tracker.offset)) {\n            tracker.offset += 8;\n            return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n        }\n\n        //(characteristic)[.(mantissa)][Ee[+-](significand)]\n        parseInteger(tracker);\n        var cur = data[tracker.offset];\n        if (cur === 0x2E) { // '.'\n            tracker.offset++;\n            if (!parseMantissa(tracker))\n                throw new Error(\"Invalid number\");\n        }\n\n        if (!parseSignificand(tracker))\n            throw new Error(\"Invalid number\");\n\n        return parseFloat(getSlice(data, start, tracker.offset - start));\n    }\n\n    function toBuffer(data: string|Uint8Array): Uint8Array {\n        if (data instanceof Uint8Array)\n            return data;\n        if (typeof TextEncoder === \"function\")\n            return new TextEncoder().encode(<string>data);\n    }\n\n    function isNaN(data: Uint8Array, i: number): boolean {\n        return data[i + 0] === 0x4E //N\n            && data[i + 1] === 0x61 //a\n            && data[i + 2] === 0x4E //N\n            ;\n    }\n\n    function isInfinity(data: Uint8Array, i: number): boolean {\n        return data[i + 0] === 0x49 //I\n            && data[i + 1] === 0x6E //n\n            && data[i + 2] === 0x66 //f\n            && data[i + 3] === 0x69 //i\n            && data[i + 4] === 0x6E //n\n            && data[i + 5] === 0x69 //i\n            && data[i + 6] === 0x74 //t\n            && data[i + 7] === 0x79 //y\n            ;\n    }\n\n    function parseInteger(tracker: IParseTracker): boolean {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var cur: number;\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n            tracker.offset++;\n        }\n        return tracker.offset !== start;\n    }\n\n    function parseMantissa(tracker: IParseTracker): boolean {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var cur: number;\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n            tracker.offset++;\n        }\n        return tracker.offset !== start;\n    }\n\n    function parseSignificand(tracker: IParseTracker): boolean {\n        var data = tracker.data;\n        if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\n            return true;\n        tracker.offset++;\n\n        var cur = data[tracker.offset];\n        if (cur === 0x2D || cur === 0x2B) // '-' '+'\n            tracker.offset++;\n        return parseInteger(tracker);\n    }\n\n    function getSlice(data: Uint8Array, offset: number, length: number): string {\n        var buf = new Array(length);\n        for (var i = 0; i < length; i++) {\n            buf[i] = data[offset + i];\n        }\n        return String.fromCharCode.apply(null, buf);\n    }\n}","namespace curve.parse.dom {\n    var domsvg = <SVGSVGElement>document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    var dompath = <SVGPathElement>document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n\n    export class Parser implements IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array) {\n            if (typeof data !== \"string\") {\n                console.warn(\"Input parse data was not a string.\", data);\n                return;\n            }\n            dompath.setAttribute(\"d\", <string>data);\n\n            var segments = dompath.pathSegList,\n                cur: number[] = [0, 0];\n            for (var i = 0, len = segments.numberOfItems; i < len; i++) {\n                parseSegment(runner, segments.getItem(i), cur);\n            }\n        }\n    }\n\n    function parseSegment(runner: ISegmentRunner, segment: SVGPathSeg, cur: number[]) {\n        switch (segment.pathSegType) {\n            case SVGPathSeg.PATHSEG_ARC_ABS:\n                let arc1 = <SVGPathSegArcAbs>segment;\n                let ell1 = ellipticalArc.toEllipse(cur[0], cur[1], arc1.r1, arc1.r2, arc1.angle, arc1.largeArcFlag ? 1 : 0, arc1.sweepFlag ? 1 : 0, arc1.x, arc1.y);\n                if (!ell1.rx || !ell1.ry)\n                    runner.lineTo(ell1.cx, ell1.cy);\n                else\n                    runner.ellipse(ell1.cx, ell1.cy, ell1.rx, ell1.ry, ell1.phi, ell1.sa, ell1.ea, ell1.ac);\n                cur[0] = arc1.x;\n                cur[1] = arc1.y;\n                break;\n            case SVGPathSeg.PATHSEG_ARC_REL:\n                let arc2 = <SVGPathSegArcRel>segment;\n                let ell2 = ellipticalArc.toEllipse(cur[0], cur[1], arc2.r1, arc2.r2, arc2.angle, arc2.largeArcFlag ? 1 : 0, arc2.sweepFlag ? 1 : 0, cur[0] + arc2.x, cur[1] + arc2.y);\n                if (!ell2.rx || !ell2.ry)\n                    runner.lineTo(ell2.cx, ell2.cy);\n                else\n                    runner.ellipse(ell2.cx, ell2.cy, ell2.rx, ell2.ry, ell2.phi, ell2.sa, ell2.ea, ell2.ac);\n                cur[0] += arc2.x;\n                cur[1] += arc2.y;\n                break;\n            case SVGPathSeg.PATHSEG_CLOSEPATH:\n                runner.closePath();\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                let curve1 = <SVGPathSegCurvetoCubicAbs>segment;\n                runner.bezierCurveTo(curve1.x1, curve1.y1, curve1.x2, curve1.y2, curve1.x, curve1.y);\n                cur[0] = curve1.x;\n                cur[1] = curve1.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                let curve2 = <SVGPathSegCurvetoCubicRel>segment;\n                runner.bezierCurveTo(cur[0] + curve2.x1, cur[1] + curve2.y1, cur[0] + curve2.x2, cur[1] + curve2.y2, cur[0] + curve2.x, cur[1] + curve2.y);\n                cur[0] += curve2.x;\n                cur[1] += curve2.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                let curve3 = <SVGPathSegCurvetoCubicSmoothAbs>segment;\n                smoothCubic(runner, curve3.x2, curve3.y2, curve3.x, curve3.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                let curve4 = <SVGPathSegCurvetoCubicSmoothRel>segment;\n                smoothCubic(runner, cur[0] + curve4.x2, cur[1] + curve4.y2, cur[0] + curve4.x, cur[1] + curve4.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                let curve5 = <SVGPathSegCurvetoQuadraticAbs>segment;\n                runner.quadraticCurveTo(curve5.x1, curve5.y1, curve5.x, curve5.y);\n                cur[0] = curve5.x;\n                cur[1] = curve5.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                let curve6 = <SVGPathSegCurvetoQuadraticRel>segment;\n                runner.quadraticCurveTo(cur[0] + curve6.x1, cur[1] + curve6.y1, cur[0] + curve6.x, cur[1] + curve6.y);\n                cur[0] += curve6.x;\n                cur[1] += curve6.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                let curve7 = <SVGPathSegCurvetoQuadraticSmoothAbs>segment;\n                smoothQuadratic(runner, curve7.x, curve7.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                let curve8 = <SVGPathSegCurvetoQuadraticSmoothRel>segment;\n                smoothQuadratic(runner, cur[0] + curve8.x, cur[1] + curve8.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_ABS:\n                let line1 = <SVGPathSegLinetoAbs>segment;\n                cur[0] = line1.x;\n                cur[1] = line1.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                let line2 = <SVGPathSegLinetoHorizontalAbs>segment;\n                cur[0] = line2.x;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                let line3 = <SVGPathSegLinetoHorizontalRel>segment;\n                cur[0] += line3.x;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_REL:\n                let line4 = <SVGPathSegLinetoRel>segment;\n                cur[0] += line4.x;\n                cur[1] += line4.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                let line5 = <SVGPathSegLinetoVerticalAbs>segment;\n                cur[1] = line5.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                let line6 = <SVGPathSegLinetoVerticalRel>segment;\n                cur[1] += line6.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_MOVETO_ABS:\n                let move1 = <SVGPathSegMovetoAbs>segment;\n                cur[0] = move1.x;\n                cur[1] = move1.y;\n                runner.moveTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_MOVETO_REL:\n                let move2 = <SVGPathSegMovetoRel>segment;\n                cur[0] += move2.x;\n                cur[1] += move2.y;\n                runner.moveTo(cur[0], cur[1]);\n                break;\n            default:\n            case SVGPathSeg.PATHSEG_UNKNOWN:\n                console.warn(\"Unknown path segment.\");\n                break;\n        }\n    }\n\n    function smoothCubic(runner: ISegmentRunner, x2: number, y2: number, x: number, y: number, cur: number[]) {\n        var [cx, cy] = cur;\n        console.warn(\"Smooth cubic\", \"Not implemented\");\n    }\n\n    function smoothQuadratic(runner: ISegmentRunner, x: number, y: number, cur: number[]) {\n        var [cx, cy] = cur;\n        console.warn(\"Smooth quadratic\", \"Not implemented\");\n    }\n}","namespace curve.parse {\n    export enum ParseStyles {\n        Dom = 1,\n        Buffer = 2,\n        CharMatching = 3,\n    }\n}","///<reference path=\"ParseTypes.ts\"/>\n\nnamespace curve.parse {\n    export interface IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array);\n    }\n\n    export var style = ParseStyles.CharMatching;\n\n    export function getParser(): IParser {\n        if (style === ParseStyles.Buffer)\n            return new buffer.Parser();\n        else if (style === ParseStyles.Dom)\n            return new dom.Parser();\n        return new matching.Parser();\n    }\n}","// Path Markup Syntax: http://msdn.microsoft.com/en-us/library/cc189041(v=vs.95).aspx\n\n//FigureDescription Syntax\n// MoveCommand DrawCommands [CloseCommand]\n\n//Double Syntax\n// digits\n// digits.digits\n// 'Infinity'\n// '-Infinity'\n// 'NaN'\n\n//Point Syntax\n// x,y\n// x y\n\n//Loop until exhausted\n//  Parse FigureDescription\n//      Find \"M\" or \"m\"? - Parse MoveCommand (start point)\n//          <point>\n//\n//      Find \"L\" or \"l\"? - Parse LineCommand (end point)\n//          <point>\n//      Find \"H\" or \"h\"? - Parse HorizontalLineCommand (x)\n//          <double>\n//      Find \"V\" or \"v\"? - Parse VerticalLineCommand (y)\n//          <double>\n//      Find \"C\" or \"c\"? - Parse CubicBezierCurveCommand (control point 1, control point 2, end point)\n//          <point> <point> <point>\n//      Find \"Q\" or \"q\"? - Parse QuadraticBezierCurveCommand (control point, end point)\n//          <point> <point>\n//      Find \"S\" or \"s\"? - Parse SmoothCubicBezierCurveCommand (control point 2, end point)\n//          <point> <point>\n//      Find \"T\" or \"t\"? - Parse SmoothQuadraticBezierCurveCommand (control point, end point)\n//          <point> <point>\n//      Find \"A\" or \"a\"? - Parse EllipticalArcCommand (size, rotationAngle, isLargeArcFlag, sweepDirectionFlag, endPoint)\n//          <point> <double> <1,0> <1,0> <point>\n//\n//      Find \"Z\" or \"z\"? - CloseCommand\n\nnamespace curve.parse.matching {\n    import IEllipseParameterization = curve.ellipticalArc.IEllipseParameterization;\n\n    export class Parser implements IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array) {\n            if (typeof data === \"string\")\n                parse(runner, data, data.length);\n            else\n                console.warn(\"Input parse data was not a string.\", data);\n        }\n    }\n\n    interface IPoint {\n        x: number;\n        y: number;\n    }\n\n    function parse(runner: ISegmentRunner, str: string, len: number) {\n        var index = 0;\n        go();\n\n        function go() {\n            var cp = {x: 0, y: 0};\n            var cp1: IPoint, cp2: IPoint, cp3: IPoint;\n            var start = {x: 0, y: 0};\n            var cbz = false; // last figure is a cubic bezier curve\n            var qbz = false; // last figure is a quadratic bezier curve\n            var cbzp = {x: 0, y: 0}; // points needed to create \"smooth\" beziers\n            var qbzp = {x: 0, y: 0}; // points needed to create \"smooth\" beziers\n            var ell: IEllipseParameterization;\n\n            while (index < len) {\n                var c;\n                while (index < len && (c = str.charAt(index)) === ' ') {\n                    index++;\n                }\n                index++;\n                var relative = false;\n                switch (c) {\n                    case 'f':\n                    case 'F':\n                        c = str.charAt(index);\n                        if (c === '0')\n                            runner.setFillRule(FillRule.EvenOdd);\n                        else if (c === '1')\n                            runner.setFillRule(FillRule.NonZero);\n                        else\n                            return null;\n                        index++;\n                        c = str.charAt(index);\n                        break;\n                    case 'm':\n                        relative = true;\n                    case 'M':\n                        cp1 = parsePoint();\n                        if (cp1 == null)\n                            break;\n                        if (relative) {\n                            cp1.x += cp.x;\n                            cp1.y += cp.y;\n                        }\n                        runner.moveTo(cp1.x, cp1.y);\n                        start.x = cp.x = cp1.x;\n                        start.y = cp.y = cp1.y;\n                        advance();\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            runner.lineTo(cp1.x, cp1.y);\n                        }\n                        cp.x = cp1.x;\n                        cp.y = cp1.y;\n                        cbz = qbz = false;\n                        break;\n                    case 'l':\n                        relative = true;\n                    case 'L':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n\n                            runner.lineTo(cp1.x, cp1.y);\n\n                            cp.x = cp1.x;\n                            cp.y = cp1.y;\n                            advance();\n                        }\n                        cbz = qbz = false;\n                        break;\n                    case 'h':\n                        relative = true;\n                    case 'H':\n                        var x = parseDouble();\n                        if (x == null)\n                            break;\n\n                        if (relative)\n                            x += cp.x;\n                        cp = {x: x, y: cp.y};\n\n                        runner.lineTo(cp.x, cp.y);\n                        cbz = qbz = false;\n                        break;\n                    case 'v':\n                        relative = true;\n                    case 'V':\n                        var y = parseDouble();\n                        if (y == null)\n                            break;\n\n                        if (relative)\n                            y += cp.y;\n                        cp = {x: cp.x, y: y};\n\n                        runner.lineTo(cp.x, cp.y);\n                        cbz = qbz = false;\n                        break;\n                    case 'c':\n                        relative = true;\n                    case 'C':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            advance();\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n                            if ((cp3 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp3.x += cp.x;\n                                cp3.y += cp.y;\n                            }\n                            advance();\n\n                            runner.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n\n                            cp1.x = cp3.x;\n                            cp1.y = cp3.y;\n                        }\n                        cp.x = cp3.x;\n                        cp.y = cp3.y;\n                        cbz = true;\n                        cbzp.x = cp2.x;\n                        cbzp.y = cp2.y;\n                        qbz = false;\n                        break;\n                    case 's':\n                        relative = true;\n                    case 'S':\n                        while (morePointsAvailable()) {\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n                            if ((cp3 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp3.x += cp.x;\n                                cp3.y += cp.y;\n                            }\n\n                            if (cbz) {\n                                cp1.x = 2 * cp.x - cbzp.x;\n                                cp1.y = 2 * cp.y - cbzp.y;\n                            } else\n                                cp1 = cp;\n\n                            runner.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n\n                            cbz = true;\n                            cbzp.x = cp2.x;\n                            cbzp.y = cp2.y;\n\n                            cp.x = cp3.x;\n                            cp.y = cp3.y;\n\n                            advance();\n                        }\n                        qbz = false;\n                        break;\n                    case 'q':\n                        relative = true;\n                    case 'Q':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            advance();\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n\n                            runner.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n                        }\n                        qbz = true;\n                        qbzp.x = cp1.x;\n                        qbzp.y = cp1.y;\n                        cbz = false;\n                        break;\n                    case 't':\n                        relative = true;\n                    case 'T':\n                        while (morePointsAvailable()) {\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n\n                            if (qbz) {\n                                cp1.x = 2 * cp.x - qbzp.x;\n                                cp1.y = 2 * cp.y - qbzp.y;\n                            } else\n                                cp1 = cp;\n\n                            runner.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n\n                            qbz = true;\n                            qbzp.x = cp1.x;\n                            qbzp.y = cp1.y;\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n\n                            advance();\n                        }\n                        cbz = false;\n                        break;\n                    case 'a':\n                        relative = true;\n                    case 'A':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n\n                            var angle = parseDouble();\n                            var is_large = parseDouble() !== 0 ? 1 : 0;\n                            var sweep = SweepDirection.Counterclockwise;\n                            if (parseDouble() !== 0) sweep = SweepDirection.Clockwise;\n\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n\n                            var phi = angle * Math.PI / 180.0;\n                            ell = ellipticalArc.toEllipse(cp.x, cp.y, cp1.x, cp1.y, phi, is_large, sweep, cp2.x, cp2.y);\n                            if (!ell.rx || !ell.ry)\n                                runner.lineTo(ell.cx, ell.cy);\n                            else\n                                runner.ellipse(ell.cx, ell.cy, ell.rx, ell.ry, ell.phi, ell.sa, ell.ea, ell.ac);\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n\n                            advance();\n                        }\n                        cbz = qbz = false;\n                        break;\n                    case 'z':\n                    case 'Z':\n                        runner.closePath();\n\n                        cp.x = start.x;\n                        cp.y = start.y;\n                        cbz = qbz = false;\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        function parsePoint(): IPoint {\n            var x = parseDouble();\n            if (x == null)\n                return null;\n\n            var c;\n            while (index < len && ((c = str.charAt(index)) === ' ' || c === ',')) {\n                index++;\n            }\n            if (index >= len)\n                return null;\n\n            var y = parseDouble();\n            if (y == null)\n                return null;\n\n            return {x: x, y: y};\n        }\n\n        function parseDouble(): number {\n            advance();\n            var isNegative = false;\n            if (match('-')) {\n                isNegative = true;\n                index++;\n            } else if (match('+')) {\n                index++;\n            }\n            if (match('Infinity')) {\n                index += 8;\n                return isNegative ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n            }\n            if (match('NaN'))\n                return NaN;\n\n            var temp = '';\n            while (index < len) {\n                var code = str.charCodeAt(index);\n                var c = str[index];\n                //0-9, ., E, e, E-, e-\n                if (code >= 48 && code <= 57)\n                    temp += c;\n                else if (code === 46)\n                    temp += c;\n                else if (c === 'E' || c === 'e') {\n                    temp += c;\n                    if (str[index + 1] === '-') {\n                        temp += '-';\n                        index++;\n                    }\n                }\n                else\n                    break;\n                index++;\n            }\n            if (temp.length === 0)\n                return null;\n            var f = parseFloat(temp);\n            return isNegative ? -f : f;\n        }\n\n        function advance() {\n            var code: number;\n            var c: string;\n            while (index < len) {\n                code = str.charCodeAt(index);\n                //alphanum\n                if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122) || (code >= 48 && code <= 57))\n                    break;\n                c = String.fromCharCode(code);\n                if (c === '.')\n                    break;\n                if (c === '-')\n                    break;\n                if (c === '+')\n                    break;\n                index++;\n            }\n        }\n\n        function match(matchStr: string): boolean {\n            var c1: string;\n            var c2: string;\n            for (var i = 0; i < matchStr.length && (index + i) < len; i++) {\n                c1 = matchStr.charAt(i);\n                c2 = str.charAt(index + i);\n                if (c1 !== c2)\n                    return false;\n            }\n            return true;\n        }\n\n        function morePointsAvailable(): boolean {\n            var c;\n            while (index < len && ((c = str.charAt(index)) === ',' || c === ' ')) {\n                index++;\n            }\n            if (index >= len)\n                return false;\n            if (c === '.' || c === '-' || c === '+')\n                return true;\n            var code = str.charCodeAt(index);\n            return code >= 48 && code <= 57;\n        }\n    }\n}","namespace curve {\n    export class Path implements ISegmentRunner, ISegmentExecutor {\n        private $ops: ISegment[] = [];\n\n        constructor();\n        constructor(path: Path);\n        constructor(d: string);\n        constructor(compiled: ICompiledSegment[]);\n        constructor(arg0?: string|Path|ICompiledSegment[]) {\n            if (arg0 instanceof Path) {\n                arg0.exec(this);\n            } else if (Array.isArray(arg0)) {\n                new compiler.decompile(this, <ICompiledSegment[]>arg0);\n            } else if (typeof arg0 === \"string\") {\n                var parser = parse.getParser();\n                parser.parse(this, arg0);\n            }\n        }\n\n        get isEmpty() {\n            return this.$ops.length < 1;\n        }\n\n        reset() {\n            this.$ops.length = 0;\n        }\n\n        exec(runner: ISegmentRunner, step?: Function) {\n            for (var ops = this.$ops, i = 0; ops && i < ops.length; i++) {\n                ops[i](runner);\n                step && step();\n            }\n        }\n\n        draw(ctx: CanvasRenderingContext2D) {\n            this.exec(ctx);\n        }\n\n        addPath(path: Path) {\n            path.exec(this);\n        }\n\n        setFillRule(fillRule: FillRule) {\n            this.$ops.push(exec => exec.setFillRule(fillRule));\n        }\n\n        closePath() {\n            this.$ops.push(exec => exec.closePath());\n        }\n\n        moveTo(x: number, y: number) {\n            this.$ops.push(exec => exec.moveTo(x, y));\n        }\n\n        lineTo(x: number, y: number) {\n            this.$ops.push(exec => exec.lineTo(x, y));\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.$ops.push(exec => exec.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.$ops.push(exec => exec.quadraticCurveTo(cpx, cpy, x, y));\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.$ops.push(exec => exec.arc(x, y, radius, startAngle, endAngle, anticlockwise));\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.$ops.push(exec => exec.arcTo(x1, y1, x2, y2, radius));\n        }\n\n        ellipse(cx: number, cy: number, rx: number, ry: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.$ops.push(exec => exec.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise));\n        }\n\n        static parse(runner: ISegmentRunner, data: string) {\n            var parser = parse.getParser();\n            parser.parse(runner, data);\n        }\n    }\n}","interface CanvasRenderingContext2D {\n    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean);\n}\n\nnamespace curve {\n    var proto: CanvasRenderingContext2D = CanvasRenderingContext2D.prototype;\n    if (!proto.ellipse) {\n        proto.ellipse = function (x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.save();\n            this.translate(x, y);\n            this.rotate(rotation);\n            this.scale(radiusX, radiusY);\n            this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n            this.restore();\n        }\n    }\n}\n","namespace curve {\n    var proto: CanvasRenderingContext2D = CanvasRenderingContext2D.prototype;\n    if (!proto.setFillRule) {\n        proto.setFillRule = function (arg: FillRule) {\n            this.fillRule = arg;\n        };\n    }\n}","interface TextEncoder {\n    encode(str: string): Uint8Array;\n    encoding: string;\n}\ndeclare var TextEncoder: {\n    prototype: TextEncoder;\n    new(): TextEncoder;\n};\n\n(function (global: any) {\n    if (typeof global.TextEncoder === \"function\")\n        return;\n\n    global.TextEncoder = class TextEncoder {\n        constructor() {\n            Object.defineProperties(this, {\n                \"encoding\": {value: \"utf-8\", writable: false}\n            });\n        }\n\n        encode(str: string): Uint8Array {\n            var buf = new ArrayBuffer(str.length);\n            var arr = new Uint8Array(buf);\n            for (var i = 0; i < arr.length; i++) {\n                arr[i] = str.charCodeAt(i);\n            }\n            return arr;\n        }\n    };\n})(this);","namespace curve {\n    export function serialize(path: Path, pretty?: boolean) {\n        var serializer = new Serializer(pretty);\n        path.exec(serializer);\n        return serializer.data;\n    }\n\n    class Serializer implements ISegmentRunner {\n        private prev: {x:number;y:number;};\n        private pretty: boolean;\n        data: string = \"\";\n\n        constructor(pretty?: boolean) {\n            this.pretty = pretty === true;\n        }\n\n        setFillRule(fillRule: FillRule) {\n            this.prepend().data += `F${fillRule}`;\n        }\n\n        closePath() {\n            this.prepend().data += \"Z\";\n        }\n\n        moveTo(x: number, y: number) {\n            if (this.pretty) {\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += `M${x},${y}`;\n            this.prev = {x: x, y: y};\n        }\n\n        lineTo(x: number, y: number) {\n            if (this.pretty) {\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += `L${x},${y}`;\n            this.prev = {x: x, y: y};\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            if (this.pretty) {\n                cp1x = round(cp1x, 2);\n                cp1y = round(cp1y, 2);\n                cp2x = round(cp2x, 2);\n                cp2y = round(cp2y, 2);\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += `C${cp1x},${cp1y},${cp2x},${cp2y},${x},${y}`;\n            this.prev = {x: x, y: y};\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            if (this.pretty) {\n                cpx = round(cpx, 2);\n                cpy = round(cpy, 2);\n                x = round(x, 2);\n                y = round(y, 2);\n            }\n            this.prepend().data += `Q${cpx},${cpy},${x},${y}`;\n            this.prev = {x: x, y: y};\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            // Not represented in svg\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            // Not represented in svg\n        }\n\n        ellipse(cx: number, cy: number, rx: number, ry: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            var earc = ellipticalArc.fromEllipse(cx, cy, rx, ry, rotation, startAngle, endAngle, antiClockwise);\n            earc.phi = earc.phi * 180 / Math.PI;\n            if (this.pretty) {\n                earc.sx = round(earc.sx, 2);\n                earc.sy = round(earc.sy, 2);\n                earc.rx = round(earc.rx, 2);\n                earc.ry = round(earc.ry, 2);\n                earc.phi = round(earc.phi, 2);\n                earc.ex = round(earc.ex, 2);\n                earc.ey = round(earc.ey, 2);\n            }\n            if (this.prev && close(this.prev.x, earc.sx) && close(this.prev.y, earc.sy))\n                this.prepend().data += `A${earc.rx},${earc.ry} ${earc.phi} ${earc.fa} ${earc.fs} ${earc.ex},${earc.ey}`;\n            else\n                this.prepend().data += `L${earc.sx},${earc.sy} A${earc.rx},${earc.ry} ${earc.phi} ${earc.fa} ${earc.fs} ${earc.ex},${earc.ey}`;\n        }\n\n        private prepend(): this {\n            if (this.data)\n                this.data += \" \";\n            return this;\n        }\n    }\n\n    var EPSILON = 1e-4;\n\n    function close(a: number, b: number): boolean {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    function round(a: number, digits: number): number {\n        var factor = Math.pow(10, digits);\n        return Math.round(a * factor) / factor;\n    }\n}"],"sourceRoot":"./src"}