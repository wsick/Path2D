{"version":3,"sources":["_version.ts","polyfills/CanvasRenderingContext2D_ellipse.ts","polyfills/CanvasRenderingContext2D_setFillRule.ts","polyfills/TextEncoder.ts","bounds/extenders/Arc.ts","bounds/extenders/LineTo.ts","bounds/extenders/ArcTo.ts","bounds/extenders/BezierCurveTo.ts","bounds/extenders/ClosePath.ts","bounds/extenders/Ellipse.ts","bounds/extenders/MoveTo.ts","bounds/extenders/QuadraticCurveTo.ts","bounds/ExtenderSelector.ts","compiler/compile.ts","compiler/decompile.ts","compiler/ICompiledSegment.ts","ellipticalArc/generate.ts","parse/ParseTypes.ts","parse/IParser.ts","bounds/fill/FillBounds.ts","IStrokeParameters.ts","bounds/stroke/extendEndCap.ts","bounds/stroke/extendLineJoin.ts","bounds/stroke/extendStartCap.ts","bounds/stroke/StartCapExtender.ts","bounds/stroke/StrokeBounds.ts","parse/buffer/parser.ts","parse/dom/parser.ts","parse/matching/parser.ts","ISegmentExecutor.ts","Path.ts","serialize.ts"],"names":["curve","this","save","translate","x","y","rotate","rotation","scale","radiusX","radiusY","arc","startAngle","endAngle","antiClockwise","restore","fillRule","arg","global","TextEncoder","constructor","prototype","encode","str","curve.bounds","curve.bounds.extenders","curve.bounds.extenders.getStartVector","curve.bounds.extenders.getEndVector","curve.bounds.extenders.arcContainsPoint","curve.bounds.extenders.getCapSpread","curve.bounds.extenders.Arc","curve.bounds.extenders.Arc.constructor","curve.bounds.extenders.Arc.init","curve.bounds.extenders.Arc.extendFillBox","curve.bounds.extenders.Arc.extendStrokeBox","curve.bounds.extenders.LineTo","curve.bounds.extenders.LineTo.constructor","curve.bounds.extenders.LineTo.init","curve.bounds.extenders.LineTo.extendFillBox","curve.bounds.extenders.LineTo.extendStrokeBox","curve.bounds.extenders.createLine","curve.bounds.extenders.createArc","curve.bounds.extenders.getTangentPoint","curve.bounds.extenders.getPerpendicularIntersections","curve.bounds.extenders.ArcTo","curve.bounds.extenders.ArcTo.constructor","curve.bounds.extenders.ArcTo.init","curve.bounds.extenders.ArcTo.extendFillBox","curve.bounds.extenders.ArcTo.extendStrokeBox","curve.bounds.extenders.getMaxima","curve.bounds.extenders.cod","curve.bounds.extenders.BezierCurveTo","curve.bounds.extenders.BezierCurveTo.constructor","curve.bounds.extenders.BezierCurveTo.init","curve.bounds.extenders.BezierCurveTo.extendFillBox","curve.bounds.extenders.BezierCurveTo.extendStrokeBox","curve.bounds.extenders.ClosePath","curve.bounds.extenders.ClosePath.constructor","curve.bounds.extenders.ClosePath.init","curve.bounds.extenders.Ellipse","curve.bounds.extenders.Ellipse.constructor","curve.bounds.extenders.MoveTo","curve.bounds.extenders.MoveTo.constructor","curve.bounds.extenders.MoveTo.init","curve.bounds.extenders.MoveTo.extendFillBox","curve.bounds.extenders.MoveTo.extendStrokeBox","curve.bounds.extenders.QuadraticCurveTo","curve.bounds.extenders.QuadraticCurveTo.constructor","curve.bounds.extenders.QuadraticCurveTo.init","curve.bounds.extenders.QuadraticCurveTo.extendFillBox","curve.bounds.extenders.QuadraticCurveTo.extendStrokeBox","curve.bounds.ExtenderSelector","curve.bounds.ExtenderSelector.closePath","curve.bounds.ExtenderSelector.moveTo","curve.bounds.ExtenderSelector.lineTo","curve.bounds.ExtenderSelector.bezierCurveTo","curve.bounds.ExtenderSelector.quadraticCurveTo","curve.bounds.ExtenderSelector.arc","curve.bounds.ExtenderSelector.arcTo","curve.bounds.ExtenderSelector.ellipse","curve.compiler","curve.compiler.compile","curve.compiler.PathCompiler","curve.compiler.PathCompiler.constructor","curve.compiler.PathCompiler.setFillRule","curve.compiler.PathCompiler.closePath","curve.compiler.PathCompiler.moveTo","curve.compiler.PathCompiler.lineTo","curve.compiler.PathCompiler.bezierCurveTo","curve.compiler.PathCompiler.quadraticCurveTo","curve.compiler.PathCompiler.arc","curve.compiler.PathCompiler.arcTo","curve.compiler.PathCompiler.ellipse","curve.compiler.decompile","CompiledOpType","curve.ellipticalArc","curve.ellipticalArc.genEllipse","curve.parse","curve.parse.ParseStyles","curve.parse.getParser","curve.bounds.fill","curve.bounds.fill.FillBounds","curve.bounds.fill.FillBounds.constructor","curve.bounds.fill.FillBounds.ensure","curve.bounds.fill.FillBounds.calculate","curve.PenLineCap","curve.PenLineJoin","curve.bounds.stroke","curve.bounds.stroke.extendEndCap","_a","metrics","endPoint","ex","ey","hs","thickness","box","l","Math","min","r","max","t","b","ed","vec2","clone","endVector","normalize","edo","orthogonal","x1","x2","y1","y2","curve.bounds.stroke.extendLineJoin","curve.bounds.stroke.findMiterTips","curve.bounds.stroke.findBevelTips","curve.bounds.stroke.extendStartCap","sx","sy","sd","startVector","reverse","sdo","curve.bounds.stroke.StartCapExtender","curve.bounds.stroke.StrokeBounds","curve.bounds.stroke.StrokeBounds.constructor","curve.bounds.stroke.StrokeBounds.ensure","curve.bounds.stroke.StrokeBounds.calculate","curve.parse.buffer","curve.parse.buffer.parseNumber","curve.parse.buffer.toBuffer","curve.parse.buffer.isNaN","curve.parse.buffer.isInfinity","curve.parse.buffer.parseInteger","curve.parse.buffer.parseMantissa","curve.parse.buffer.parseSignificand","curve.parse.buffer.getSlice","curve.parse.buffer.Parser","curve.parse.buffer.Parser.parse","curve.parse.dom","curve.parse.dom.parseSegment","curve.parse.dom.smoothCubic","curve.parse.dom.smoothQuadratic","curve.parse.dom.Parser","curve.parse.dom.Parser.parse","curve.parse.matching","curve.parse.matching.parse","curve.parse.matching.parse.go","curve.parse.matching.parse.parsePoint","curve.parse.matching.parse.parseDouble","curve.parse.matching.parse.advance","curve.parse.matching.parse.match","curve.parse.matching.parse.morePointsAvailable","curve.parse.matching.Parser","curve.parse.matching.Parser.parse","FillRule","SweepDirection","curve.Path","curve.Path.constructor","curve.Path.exec","curve.Path.draw","curve.Path.addPath","curve.Path.setFillRule","curve.Path.closePath","curve.Path.moveTo","curve.Path.lineTo","curve.Path.bezierCurveTo","curve.Path.quadraticCurveTo","curve.Path.arc","curve.Path.arcTo","curve.Path.ellipse","curve.Path.parse","curve.serialize","curve.Serializer","curve.Serializer.constructor","curve.Serializer.setFillRule","curve.Serializer.closePath","curve.Serializer.moveTo","curve.Serializer.lineTo","curve.Serializer.bezierCurveTo","curve.Serializer.quadraticCurveTo","curve.Serializer.ellipse","curve.Serializer.prepend"],"mappings":"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","file":"curve.min.js","sourcesContent":["namespace curve {\r\n    export var version = '0.1.0';\r\n}",null,null,null,"namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export interface IArcMetrics extends ISegmentMetrics {\n        sx: number;\n        sy: number;\n        l: number;\n        cl: boolean;\n        r: number;\n        cr: boolean;\n        t: number;\n        ct: boolean;\n        b: number;\n        cb: boolean;\n    }\n\n    export class Arc implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): IArcMetrics {\n            var x = args[0];\n            var y = args[1];\n            var radius = args[2];\n            var sa = args[3];\n            var ea = args[4];\n            var cc = args[5];\n\n            sx = x + (radius * Math.cos(sa));\n            sy = y + (radius * Math.sin(sa));\n            var ex = x + (radius * Math.cos(ea));\n            var ey = y + (radius * Math.sin(ea));\n\n            var l = x - radius;\n            var cl = arcContainsPoint(sx, sy, ex, ey, l, y, cc);\n\n            var r = x + radius;\n            var cr = arcContainsPoint(sx, sy, ex, ey, r, y, cc);\n\n            var t = y - radius;\n            var ct = arcContainsPoint(sx, sy, ex, ey, x, t, cc);\n\n            var b = y + radius;\n            var cb = arcContainsPoint(sx, sy, ex, ey, x, b, cc);\n\n            return {\n                sx: sx,\n                sy: sy,\n                l: l,\n                cl: cl,\n                r: r,\n                cr: cr,\n                t: t,\n                ct: ct,\n                b: b,\n                cb: cb,\n                endPoint: vec2.create(ex, ey),\n                startVector: getStartVector(x, y, cc, sx, sy),\n                endVector: getEndVector(x, y, cc, ex, ey)\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcMetrics) {\n            var sa = args[3];\n            var ea = args[4];\n            if (ea === sa)\n                return;\n\n            var ep = metrics.endPoint,\n                ex = ep[0],\n                ey = ep[1];\n            box.l = Math.min(box.l, sx, ex);\n            box.r = Math.max(box.r, sx, ex);\n            box.t = Math.min(box.t, sy, ey);\n            box.b = Math.max(box.b, sy, ey);\n\n            if (metrics.cl)\n                box.l = Math.min(box.l, metrics.l);\n            if (metrics.cr)\n                box.r = Math.max(box.r, metrics.r);\n            if (metrics.ct)\n                box.t = Math.min(box.t, metrics.t);\n            if (metrics.cb)\n                box.b = Math.max(box.b, metrics.b);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcMetrics, pars: IStrokeParameters) {\n            var sa = args[3];\n            var ea = args[4];\n            if (ea === sa)\n                return;\n\n            var ep = metrics.endPoint,\n                ex = ep[0],\n                ey = ep[1];\n            box.l = Math.min(box.l, sx, ex);\n            box.r = Math.max(box.r, sx, ex);\n            box.t = Math.min(box.t, sy, ey);\n            box.b = Math.max(box.b, sy, ey);\n\n            var hs = pars.strokeThickness / 2.0;\n            if (metrics.cl)\n                box.l = Math.min(box.l, metrics.l - hs);\n            if (metrics.cr)\n                box.r = Math.max(box.r, metrics.r + hs);\n            if (metrics.ct)\n                box.t = Math.min(box.t, metrics.t - hs);\n            if (metrics.cb)\n                box.b = Math.max(box.b, metrics.b + hs);\n\n            var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0; //HTML5 doesn't support start and end cap\n            var sv = vec2.reverse(vec2.clone(metrics.startVector));\n            var ss = getCapSpread(sx, sy, pars.strokeThickness, cap, sv);\n            var es = getCapSpread(ex, ey, pars.strokeThickness, cap, metrics.endVector);\n\n            box.l = Math.min(box.l, ss.x1, ss.x2, es.x1, es.x2);\n            box.r = Math.max(box.r, ss.x1, ss.x2, es.x1, es.x2);\n            box.t = Math.min(box.t, ss.y1, ss.y2, es.y1, es.y2);\n            box.b = Math.max(box.b, ss.y1, ss.y2, es.y1, es.y2);\n        }\n    }\n\n    function getStartVector(x: number, y: number, cc: number, sx: number, sy: number): Float32Array {\n        var rx = sx - x,\n            ry = sy - y;\n        if (cc)\n            return vec2.create(ry, -rx);\n        return vec2.create(-ry, rx);\n    }\n\n    function getEndVector(x: number, y: number, cc: number, ex: number, ey: number): Float32Array {\n        var rx = ex - x,\n            ry = ey - y;\n        if (cc)\n            return vec2.create(ry, -rx);\n        return vec2.create(-ry, rx);\n    }\n\n    function arcContainsPoint(sx: number, sy: number, ex: number, ey: number, cpx: number, cpy: number, cc: boolean): boolean {\n        // var a = ex - sx;\n        // var b = cpx - sx;\n        // var c = ey - sy;\n        // var d = cpy - sy;\n        // det = ad - bc;\n        var n = (ex - sx) * (cpy - sy) - (cpx - sx) * (ey - sy);\n        if (n === 0)\n            return true;\n        if (n > 0 && cc)\n            return true;\n        if (n < 0 && !cc)\n            return true;\n        return false;\n    }\n\n    function getCapSpread(x: number, y: number, thickness: number, cap: PenLineCap, vector: Float32Array) {\n        var hs = thickness / 2.0;\n        switch (cap) {\n            case PenLineCap.Round:\n                return {\n                    x1: x - hs,\n                    x2: x + hs,\n                    y1: y - hs,\n                    y2: y + hs\n                };\n                break;\n            case PenLineCap.Square:\n                var ed = vec2.normalize(vec2.clone(vector));\n                var edo = vec2.orthogonal(vec2.clone(ed));\n                return {\n                    x1: x + hs * (ed[0] + edo[0]),\n                    x2: x + hs * (ed[0] - edo[0]),\n                    y1: y + hs * (ed[1] + edo[1]),\n                    y2: y + hs * (ed[1] - edo[1])\n                };\n                break;\n            case PenLineCap.Flat:\n            default:\n                var edo = vec2.orthogonal(vec2.normalize(vec2.clone(vector)));\n                return {\n                    x1: x + hs * edo[0],\n                    x2: x + hs * -edo[0],\n                    y1: y + hs * edo[1],\n                    y2: y + hs * -edo[1]\n                };\n                break;\n        }\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class LineTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var x = args[0];\n            var y = args[1];\n\n            return {\n                startVector: vec2.create(x - sx, y - sy),\n                endVector: vec2.create(x - sx, y - sy),\n                endPoint: vec2.create(x, y)\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var x = args[0];\n            var y = args[1];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            this.extendFillBox(box, sx, sy, args, metrics);\n        }\n    }\n}","/// <reference path=\"LineTo\" />\n/// <reference path=\"Arc\" />\n\nnamespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export interface IArcToMetrics extends ISegmentMetrics {\n        line: {\n            args: any[];\n            metrics: ISegmentMetrics;\n        };\n        arc: {\n            args: any[];\n            metrics: IArcMetrics;\n        };\n    }\n\n    var _arc = new Arc();\n    var _lineTo = new LineTo();\n\n    export class ArcTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): IArcToMetrics {\n            var x1: number = args[0];\n            var y1: number = args[1];\n            var x2: number = args[2];\n            var y2: number = args[3];\n            var radius: number = args[4];\n\n            var v1 = vec2.create(x1 - sx, y1 - sy);\n            var v2 = vec2.create(x2 - x1, y2 - y1);\n            var inner_theta = Math.PI - vec2.angleBetween(v1, v2);\n            //find 2 points tangent to imaginary circle along guide lines\n            var a = getTangentPoint(inner_theta, radius, vec2.create(sx, sy), v1, true);\n            var b = getTangentPoint(inner_theta, radius, vec2.create(x1, y1), v2, false);\n\n            var line = createLine(sx, sy, a[0], a[1]);\n            var arc = createArc(a, v1, b, v2, radius);\n\n            return {\n                line: line,\n                arc: arc,\n                startVector: line.metrics.startVector,\n                endVector: arc.metrics.endVector,\n                endPoint: arc.metrics.endPoint\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcToMetrics) {\n            _lineTo.extendFillBox(box, sx, sy, metrics.line.args, metrics.line.metrics);\n            var ep = metrics.line.metrics.endPoint;\n            _arc.extendFillBox(box, ep[0], ep[1], metrics.arc.args, metrics.arc.metrics);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: IArcToMetrics, pars: IStrokeParameters) {\n            _lineTo.extendStrokeBox(box, sx, sy, metrics.line.args, metrics.line.metrics, pars);\n            var ep = metrics.line.metrics.endPoint;\n            _arc.extendStrokeBox(box, ep[0], ep[1], metrics.arc.args, metrics.arc.metrics, pars);\n        }\n    }\n\n    function createLine(sx: number, sy: number, x: number, y: number) {\n        var args = [x, y];\n        return {\n            args: args,\n            metrics: _lineTo.init(sx, sy, args)\n        };\n    }\n\n    function createArc(a: Float32Array, v1: Float32Array, b: Float32Array, v2: Float32Array, radius: number) {\n        //find center point\n        var c = getPerpendicularIntersections(a, v1, b, v2);\n        //counter clockwise test\n        var cc = !la.vec2.isClockwiseTo(v1, v2);\n        //find starting angle -- [1,0] is origin direction of 0rad\n        var sa = Math.atan2(a[1] - c[1], a[0] - c[0]);\n        if (sa < 0)\n            sa = (2 * Math.PI) + sa;\n        var ea = Math.atan2(b[1] - c[1], b[0] - c[0]);\n        if (ea < 0)\n            ea = (2 * Math.PI) + ea;\n        var args = [c[0], c[1], radius, sa, ea, cc];\n\n        return {\n            args: args,\n            metrics: _arc.init(a[0], a[1], args)\n        };\n    }\n\n    function getTangentPoint(theta: number, radius: number, s: Float32Array, d: Float32Array, invert: boolean): Float32Array {\n        var len = Math.sqrt(d[0] * d[0] + d[1] * d[1]);\n        var f = radius / Math.tan(theta / 2);\n        var t = f / len;\n        if (invert)\n            t = 1 - t;\n        return la.vec2.create(s[0] + t * d[0], s[1] + t * d[1]);\n    }\n\n    function getPerpendicularIntersections(s1: Float32Array, d1: Float32Array, s2: Float32Array, d2: Float32Array): Float32Array {\n        var p1 = vec2.orthogonal(vec2.clone(d1));\n        var p2 = vec2.orthogonal(vec2.clone(d2));\n        return vec2.intersection(s1, p1, s2, p2);\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class BezierCurveTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n\n            return {\n                endPoint: vec2.create(x, y),\n                startVector: vec2.create(3 * (cp1x - sx), 3 * (cp1y - sy)), // [F(0)'x, F(0)'y]\n                endVector: vec2.create(3 * (x - cp2x), 3 * (y - cp2y))      // [F(1)'x, F(1)'y]\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n\n            var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n            if (m.x[0] != null) {\n                box.l = Math.min(box.l, m.x[0]);\n                box.r = Math.max(box.r, m.x[0]);\n            }\n            if (m.x[1] != null) {\n                box.l = Math.min(box.l, m.x[1]);\n                box.r = Math.max(box.r, m.x[1]);\n            }\n            if (m.y[0] != null) {\n                box.t = Math.min(box.t, m.y[0]);\n                box.b = Math.max(box.b, m.y[0]);\n            }\n            if (m.y[1] != null) {\n                box.t = Math.min(box.t, m.y[1]);\n                box.b = Math.max(box.b, m.y[1]);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            var cp1x: number = args[0];\n            var cp1y: number = args[1];\n            var cp2x: number = args[2];\n            var cp2y: number = args[3];\n            var x: number = args[4];\n            var y: number = args[5];\n            var hs = pars.strokeThickness / 2.0;\n\n            var m = getMaxima(sx, cp1x, cp2x, x, sy, cp1y, cp2y, y);\n            if (m.x[0] != null) {\n                box.l = Math.min(box.l, m.x[0] - hs);\n                box.r = Math.max(box.r, m.x[0] + hs);\n            }\n            if (m.x[1] != null) {\n                box.l = Math.min(box.l, m.x[1] - hs);\n                box.r = Math.max(box.r, m.x[1] + hs);\n            }\n            if (m.y[0] != null) {\n                box.t = Math.min(box.t, m.y[0] - hs);\n                box.b = Math.max(box.b, m.y[0] + hs);\n            }\n            if (m.y[1] != null) {\n                box.t = Math.min(box.t, m.y[1] - hs);\n                box.b = Math.max(box.b, m.y[1] + hs);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n    }\n\n    //http://pomax.nihongoresources.com/pages/bezier/\n    /* Cubic Bezier curve is defined by parameteric curve:\n     * F(t)x =\n     * F(t)y =\n     * where\n     *  s = start point\n     *  cp1 = control point 1\n     *  cp2 = control point 2\n     *  e = end point\n     *\n     * We find the coordinates (4) where F(t)x/dt = 0, F(t)y/dt = 0\n     * (within the constraints of the curve (0 <= t <= 1)\n     * These points will expand the bounding box\n     */\n\n    interface IMaxima {\n        x: number[];\n        y: number[];\n    }\n    function getMaxima(x1: number, x2: number, x3: number, x4: number, y1: number, y2: number, y3: number, y4: number): IMaxima {\n        return {\n            x: cod(x1, x2, x3, x4),\n            y: cod(y1, y2, y3, y4)\n        };\n    }\n\n    function cod(a: number, b: number, c: number, d: number): number[] {\n        var u = 2 * a - 4 * b + 2 * c;\n        var v = b - a;\n        var w = -a + 3 * b + d - 3 * c;\n        var rt = Math.sqrt(u * u - 4 * v * w);\n\n        var cods: number[] = [null, null];\n        if (isNaN(rt))\n            return cods;\n\n        var t: number,\n            ot: number;\n\n        t = (-u + rt) / (2 * w);\n        if (t >= 0 && t <= 1) {\n            ot = 1 - t;\n            cods[0] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n        }\n\n        t = (-u - rt) / (2 * w);\n        if (t >= 0 && t <= 1) {\n            ot = 1 - t;\n            cods[1] = (a * ot * ot * ot) + (3 * b * t * ot * ot) + (3 * c * ot * t * t) + (d * t * t * t);\n        }\n\n        return cods;\n    }\n}","namespace curve.bounds.extenders {\n    export class ClosePath implements IBoundsExtender {\n        isMove = false;\n\n        init(): ISegmentMetrics {\n            return {\n                endPoint: undefined,\n                startVector: undefined,\n                endVector: undefined\n            }\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n        }\n    }\n}","namespace curve.bounds.extenders {\n    export class Ellipse implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): curve.bounds.extenders.ISegmentMetrics {\n            //TODO: Implement\n            return undefined;\n        }\n\n        extendFillBox(box: curve.bounds.IBoundingBox, sx: number, sy: number, args: any[], metrics: curve.bounds.extenders.ISegmentMetrics) {\n        }\n\n        extendStrokeBox(box: curve.bounds.IBoundingBox, sx: number, sy: number, args: any[], metrics: curve.bounds.extenders.ISegmentMetrics, pars: curve.IStrokeParameters) {\n        }\n\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class MoveTo implements IBoundsExtender {\n        isMove = true;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var x = args[0];\n            var y = args[1];\n\n            return {\n                startVector: null,\n                endVector: null,\n                endPoint: vec2.create(x, y)\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var x = args[0];\n            var y = args[1];\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            this.extendFillBox(box, sx, sy, args, metrics);\n        }\n    }\n}","namespace curve.bounds.extenders {\n    import vec2 = la.vec2;\n\n    export class QuadraticCurveTo implements IBoundsExtender {\n        isMove = false;\n\n        init(sx: number, sy: number, args: any[]): ISegmentMetrics {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n\n            return {\n                endPoint: vec2.create(x, y),\n                startVector: vec2.create(2 * (cpx - sx), 2 * (cpy - sy)),   // [F(0)'x, F(0)'y]\n                endVector: vec2.create(2 * (x - cpx), 2 * (y - cpy))        // [F(1)'x, F(1)'y]\n            };\n        }\n\n        extendFillBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n\n            var m = getMaxima(sx, cpx, x, sy, cpy, y);\n            if (m.x != null) {\n                box.l = Math.min(box.l, m.x);\n                box.r = Math.max(box.r, m.x);\n            }\n            if (m.y != null) {\n                box.t = Math.min(box.t, m.y);\n                box.b = Math.max(box.b, m.y);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n\n        extendStrokeBox(box: IBoundingBox, sx: number, sy: number, args: any[], metrics: ISegmentMetrics, pars: IStrokeParameters) {\n            var cpx: number = args[0];\n            var cpy: number = args[1];\n            var x: number = args[2];\n            var y: number = args[3];\n            var hs = pars.strokeThickness / 2.0;\n\n            var m = getMaxima(sx, cpx, x, sy, cpy, y);\n            if (m.x) {\n                box.l = Math.min(box.l, m.x - hs);\n                box.r = Math.max(box.r, m.x + hs);\n            }\n            if (m.y) {\n                box.t = Math.min(box.t, m.y - hs);\n                box.b = Math.max(box.b, m.y + hs);\n            }\n\n            box.l = Math.min(box.l, x);\n            box.r = Math.max(box.r, x);\n            box.t = Math.min(box.t, y);\n            box.b = Math.max(box.b, y);\n        }\n    }\n\n    //http://pomax.nihongoresources.com/pages/bezier/\n    /* Quadratic Bezier curve is defined by parametric curve:\n     *  F(t)x = s.x(1-t)^2 + cp.x(1-t)t + e.x(t^2)\n     *  F(t)x = s.y(1-t)^2 + cp.y(1-t)t + e.y(t^2)\n     * where\n     *  s = start point\n     *  cp = control point\n     *  e = end point\n     *\n     * We find the coordinates (2) where F(t)x/dt = 0, F(t)y/dt = 0\n     * (within the constraints of the curve (0 <= t <= 1)\n     * These points will expand the bounding box\n     */\n\n    interface IMaxima {\n        x: number;\n        y: number;\n    }\n    function getMaxima(x1: number, x2: number, x3: number, y1: number, y2: number, y3: number): IMaxima {\n        return {\n            x: cod(x1, x2, x3),\n            y: cod(y1, y2, y3)\n        };\n    }\n\n    function cod(a: number, b: number, c: number): number {\n        var t = (a - b) / (a - 2 * b + c);\n        if (t < 0 || t > 1)\n            return null;\n        return (a * Math.pow(1 - t, 2)) + (2 * b * (1 - t) * t) + (c * Math.pow(t, 2));\n    }\n}","/// <reference path=\"extenders/Arc\" />\n/// <reference path=\"extenders/ArcTo\" />\n/// <reference path=\"extenders/BezierCurveTo\" />\n/// <reference path=\"extenders/ClosePath\" />\n/// <reference path=\"extenders/Ellipse\" />\n/// <reference path=\"extenders/LineTo\" />\n/// <reference path=\"extenders/MoveTo\" />\n/// <reference path=\"extenders/QuadraticCurveTo\" />\n\nnamespace curve.bounds {\n    var arc = new extenders.Arc();\n    var arcTo = new extenders.ArcTo();\n    var bezierCurveTo = new extenders.BezierCurveTo();\n    var closePath = new extenders.ClosePath();\n    var ellipse = new extenders.Ellipse();\n    var lineTo = new extenders.LineTo();\n    var moveTo = new extenders.MoveTo();\n    var quadraticCurveTo = new extenders.QuadraticCurveTo();\n\n    export class ExtenderSelector implements ISegmentRunner {\n        current: extenders.IBoundsExtender;\n        args: any[];\n\n        setFillRule(fillRule: FillRule) {\n            //TODO: Does fill rule affect bounds?\n        }\n\n        closePath() {\n            this.current = closePath;\n            this.args = <any[]><any>arguments;\n        }\n\n        moveTo(x: number, y: number) {\n            this.current = moveTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        lineTo(x: number, y: number) {\n            this.current = lineTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.current = bezierCurveTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.current = quadraticCurveTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.current = arc;\n            this.args = <any[]><any>arguments;\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.current = arcTo;\n            this.args = <any[]><any>arguments;\n        }\n\n        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.current = ellipse;\n            this.args = <any[]><any>arguments;\n        }\n    }\n}","namespace curve.compiler {\n    export function compile(arg0: string|ISegmentExecutor): ICompiledSegment[] {\n        var compiler = PathCompiler.instance;\n        compiler.compiled.length = 0;\n        if (typeof arg0 === \"string\") {\n            var parser = parse.getParser();\n            parser.parse(compiler, arg0);\n        } else if (typeof arg0.exec === \"function\") {\n            arg0.exec(compiler);\n        }\n        return compiler.compiled;\n    }\n\n    class PathCompiler implements ISegmentRunner {\n        static instance = new PathCompiler();\n\n        compiled: ICompiledSegment[] = [];\n\n        setFillRule(fillRule: FillRule) {\n            this.compiled.push({t: CompiledOpType.setFillRule, a: [fillRule]});\n        }\n\n        closePath() {\n            this.compiled.push({t: CompiledOpType.closePath, a: []});\n        }\n\n        moveTo(x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.moveTo, a: [x, y]});\n        }\n\n        lineTo(x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.lineTo, a: [x, y]});\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.bezierCurveTo, a: [cp1x, cp1y, cp2x, cp2y, x, y]});\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.compiled.push({t: CompiledOpType.quadraticCurveTo, a: [cpx, cpy, x, y]});\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.compiled.push({t: CompiledOpType.arc, a: [x, y, radius, startAngle, endAngle, anticlockwise]});\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.compiled.push({t: CompiledOpType.arcTo, a: [x1, y1, x2, y2, radius]});\n        }\n\n        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.compiled.push({\n                t: CompiledOpType.ellipse,\n                a: [x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise]\n            })\n        }\n    }\n}","namespace curve.compiler {\n    export function decompile(runner: ISegmentRunner, compiled: ICompiledSegment[]) {\n        for (var i = 0; !!compiled && i < compiled.length; i++) {\n            let seg = compiled[i];\n            let typeStr: string;\n            if (typeof seg.t !== \"number\" || !(typeStr = CompiledOpType[seg.t])) {\n                console.warn(`Unknown compiled path command: ${seg.t}, ${seg.a}`);\n                continue;\n            }\n            var func = runner[typeStr];\n            func && func.apply(runner, seg.a);\n        }\n    }\n}","interface ICompiledSegment {\n    t: CompiledOpType;\n    a: any[];\n}\n\nenum CompiledOpType {\n    setFillRule = 1,\n    closePath = 2,\n    moveTo = 3,\n    lineTo = 4,\n    bezierCurveTo = 5,\n    quadraticCurveTo = 6,\n    arc = 7,\n    arcTo = 8,\n    ellipse = 9,\n}","namespace curve.ellipticalArc {\n    import vec2 = la.vec2;\n    var PI2 = 2 * Math.PI;\n\n    // [x1, y1] = start point\n    // [x2, y2] = end point\n    // fa = large arc flag\n    // fs = sweep direction flag\n    // [rx, ry] = radial size\n    // phi = angle (radians) from x-axis of coordinate space to x-axis of ellipse\n    export function genEllipse(runner: ISegmentRunner, x1: number, y1: number, x2: number, y2: number, fa: number, fs: number, rx: number, ry: number, phi: number) {\n        // Convert from endpoint to center parametrization, as detailed in:\n        //   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        if (rx === 0 || ry === 0) {\n            runner.lineTo(x2, y2);\n            return;\n        }\n\n        // F.6.5.1\n        // Compute a`\n        var ap = vec2.midpoint(vec2.create(x1, y1), vec2.create(x2, y2));\n        vec2.rotate(ap, -phi);\n\n        // F.6.5.2\n        // Compute c`\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n        var apx2 = ap[0] * ap[0];\n        var apy2 = ap[1] * ap[1];\n        var factor = Math.sqrt(((rx2 * ry2) - (rx2 * apy2) - (ry2 * apx2)) / ((rx2 * apy2) + (ry2 * apx2)));\n        if (fa === fs) {\n            factor *= -1;\n        }\n        var cp = vec2.create(rx * ap[1] / ry, -ry * ap[0] / rx);\n        cp[0] *= factor;\n        cp[1] *= factor;\n\n        // F.6.5.3\n        // Compute c\n        var c = vec2.rotate(vec2.clone(cp), phi);\n        c[0] += (x1 + x2) / 2.0;\n        c[1] += (y1 + y2) / 2.0;\n\n        // F.6.5.5\n        // Compute theta1\n        var u = vec2.create((ap[0] - cp[0]) / rx, (ap[1] - cp[1]) / ry);\n        var v = vec2.create((-ap[0] - cp[0]) / rx, (-ap[1] - cp[1]) / ry);\n        var sa = vec2.angleBetween(vec2.create(1, 0), u);\n\n        // F.6.5.6\n        // Compute delta-theta\n        var dt = vec2.angleBetween(u, v) % PI2;\n        // Correct for sweep flag\n        if (fs === 0 && dt > 0) {\n            dt -= PI2;\n        } else if (fs === 1 && dt < 0) {\n            dt += PI2;\n        }\n\n        runner.ellipse(c[0], c[1], rx, ry, phi, sa, sa + dt, (1 - fs) === 1);\n    }\n}","namespace curve.parse {\n    export enum ParseStyles {\n        Dom = 1,\n        Buffer = 2,\n        CharMatching = 3,\n    }\n}","///<reference path=\"ParseTypes.ts\"/>\n\nnamespace curve.parse {\n    export interface IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array);\n    }\n\n    export var style = ParseStyles.CharMatching;\n\n    export function getParser(): IParser {\n        if (style === ParseStyles.Buffer)\n            return new buffer.Parser();\n        else if (style === ParseStyles.Dom)\n            return new dom.Parser();\n        return new matching.Parser();\n    }\n}","namespace curve.bounds.fill {\n    export class FillBounds implements IBoundingBox {\n        path: Path;\n        l: number = 0;\n        t: number = 0;\n        r: number = 0;\n        b: number = 0;\n\n        private $calc = false;\n\n        constructor(path: Path) {\n            Object.defineProperties(this, {\n                \"path\": {value: path, writable: false}\n            });\n        }\n\n        ensure(): this {\n            if (!this.$calc)\n                this.calculate();\n            return this;\n        }\n\n        calculate(): this {\n            this.$calc = false;\n            this.l = Number.POSITIVE_INFINITY;\n            this.t = Number.POSITIVE_INFINITY;\n            this.r = Number.NEGATIVE_INFINITY;\n            this.b = Number.NEGATIVE_INFINITY;\n\n            var sx: number,\n                sy: number;\n            var selector = new ExtenderSelector();\n            this.path.exec(selector, () => {\n                var cur = selector.current;\n                var metrics = cur.init(sx, sy, selector.args);\n\n                cur.extendFillBox(this, sx, sy, selector.args, metrics);\n\n                sx = metrics.endPoint[0];\n                sy = metrics.endPoint[1];\n            });\n\n            this.$calc = true;\n            return this;\n        }\n    }\n}","namespace curve {\n    export enum PenLineCap {\n        Flat = 0,\n        Square = 1,\n        Round = 2,\n        Triangle = 3,\n    }\n\n    export enum PenLineJoin {\n        Miter = 0,\n        Bevel = 1,\n        Round = 2,\n    }\n\n    export interface IStrokeParameters {\n        strokeThickness: number;\n        strokeDashArray: number[];\n        strokeDashCap: PenLineCap;\n        strokeDashOffset: number;\n        strokeEndLineCap: PenLineCap;\n        strokeLineJoin: PenLineJoin;\n        strokeMiterLimit: number;\n        strokeStartLineCap: PenLineCap;\n    }\n}","///<reference path=\"../../IStrokeParameters.ts\"/>\n\nnamespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n\n    export function extendEndCap(box: IBoundingBox, metrics: any, pars: IStrokeParameters) {\n        //HTML5 doesn't support start *and* end cap individually\n        var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n        var func = cappers[cap] || cappers[PenLineCap.Flat];\n        func(box, metrics, pars.strokeThickness);\n    }\n\n    interface ICapper {\n        (box: IBoundingBox, metrics: any, thickness: number);\n    }\n    var cappers: ICapper[] = [];\n    cappers[PenLineCap.Round] = function (box: IBoundingBox, metrics: any, thickness: number) {\n        var [ex, ey] = metrics.endPoint;\n        var hs = thickness / 2.0;\n        box.l = Math.min(box.l, ex - hs);\n        box.r = Math.max(box.r, ex + hs);\n        box.t = Math.min(box.t, ey - hs);\n        box.b = Math.max(box.b, ey + hs);\n    };\n    cappers[PenLineCap.Square] = function (box: IBoundingBox, metrics: any, thickness: number) {\n        var ed = vec2.clone(metrics.endVector);\n        if (!ed || !ed[0] || !ed[1])\n            return;\n        vec2.normalize(ed);\n        var edo = vec2.orthogonal(vec2.clone(ed));\n\n        var [ex, ey] = metrics.endPoint;\n        var hs = thickness / 2.0;\n\n        var x1 = ex + hs * (ed[0] + edo[0]);\n        var x2 = ex + hs * (ed[0] - edo[0]);\n        var y1 = ey + hs * (ed[1] + edo[1]);\n        var y2 = ey + hs * (ed[1] - edo[1]);\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n    cappers[PenLineCap.Flat] = function (box: IBoundingBox, metrics: any, thickness: number) {\n        var edo = vec2.clone(metrics.endVector);\n        if (!edo || !edo[0] || !edo[1])\n            return;\n        vec2.orthogonal(vec2.normalize(edo));\n\n        var [ex, ey] = metrics.endPoint;\n        var hs = thickness / 2.0;\n\n        var x1 = ex + hs * edo[0];\n        var x2 = ex + hs * -edo[0];\n        var y1 = ey + hs * edo[1];\n        var y2 = ey + hs * -edo[1];\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n}","namespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n    import ISegmentMetrics = curve.bounds.extenders.ISegmentMetrics;\n\n    export function extendLineJoin(box: IBoundingBox, sx: number, sy: number, metrics: ISegmentMetrics, lastMetrics: ISegmentMetrics, pars: IStrokeParameters) {\n        var hs = pars.strokeThickness / 2.0;\n        if (pars.strokeLineJoin === PenLineJoin.Round) {\n            box.l = Math.min(box.l, sx - hs);\n            box.r = Math.max(box.r, sx + hs);\n            box.t = Math.min(box.t, sy - hs);\n            box.b = Math.max(box.b, sy + hs);\n            return;\n        }\n        var tips = (pars.strokeLineJoin === PenLineJoin.Miter)\n            ? findMiterTips(sx, sy, metrics, lastMetrics, hs, pars.strokeMiterLimit)\n            : findBevelTips(sx, sy, metrics, lastMetrics, hs);\n        if (!tips)\n            return;\n        var x1 = tips[0][0],\n            y1 = tips[0][1],\n            x2 = tips[1][0],\n            y2 = tips[1][1];\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    }\n\n    function findMiterTips(sx: number, sy: number, metrics: ISegmentMetrics, lastMetrics: ISegmentMetrics, hs: number, miterLimit: number): Float32Array[] {\n        var av = vec2.clone(lastMetrics.endVector);\n        var bv = vec2.clone(metrics.startVector);\n        if (!av || !bv)\n            return null;\n        vec2.reverse(av);\n        var tau = vec2.angleBetween(av, bv) / 2;\n        if (isNaN(tau))\n            return null;\n\n        var miterRatio = 1 / Math.sin(tau);\n        if (miterRatio > miterLimit)\n            return findBevelTips(sx, sy, metrics, lastMetrics, hs);\n\n        //vector in direction of join point to miter tip\n        var cv = vec2.isClockwiseTo(av, bv) ? vec2.clone(av) : vec2.clone(bv);\n        vec2.normalize(vec2.reverse(vec2.rotate(cv, tau)));\n\n        //distance from join point and miter tip\n        var miterLen = hs * miterRatio;\n\n        var tip = vec2.create(sx + miterLen * cv[0], sy + miterLen * cv[1]);\n        return [tip, tip];\n    }\n\n    function findBevelTips(sx: number, sy: number, metrics: ISegmentMetrics, lastMetrics: ISegmentMetrics, hs: number): Float32Array[] {\n        var av = vec2.clone(lastMetrics.endVector);\n        var bv = vec2.clone(metrics.startVector);\n        if (!av || !bv)\n            return;\n        vec2.normalize(vec2.reverse(av));\n        vec2.normalize(bv);\n\n        var avo = vec2.clone(av),\n            bvo = vec2.clone(bv);\n        if (vec2.isClockwiseTo(av, bv)) {\n            avo = vec2.orthogonal(av);\n            bvo = vec2.reverse(vec2.orthogonal(bv));\n        } else {\n            avo = vec2.reverse(vec2.orthogonal(av));\n            bvo = vec2.orthogonal(bv);\n        }\n\n        return [\n            vec2.create(sx - hs * avo[0], sy - hs * avo[1]),\n            vec2.create(sx - hs * bvo[0], sy - hs * bvo[1])\n        ];\n    }\n}","///<reference path=\"../../IStrokeParameters.ts\"/>\n\nnamespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n\n    export function extendStartCap(box: IBoundingBox, sx: number, sy: number, metrics: any, pars: IStrokeParameters) {\n        //HTML5 doesn't support start *and* end cap individually\n        var cap = pars.strokeStartLineCap || pars.strokeEndLineCap || 0;\n        var func = cappers[cap] || cappers[PenLineCap.Flat];\n        func(box, sx, sy, metrics, pars.strokeThickness);\n    }\n\n    interface ICapper {\n        (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number);\n    }\n    var cappers: ICapper[] = [];\n    cappers[PenLineCap.Round] = function (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number) {\n        var hs = thickness / 2.0;\n        box.l = Math.min(box.l, sx - hs);\n        box.r = Math.max(box.r, sx + hs);\n        box.t = Math.min(box.t, sy - hs);\n        box.b = Math.max(box.b, sy + hs);\n    };\n    cappers[PenLineCap.Square] = function (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number) {\n        var sd = vec2.clone(metrics.startVector);\n        if (!sd || !sd[0] || !sd[1])\n            return;\n        vec2.reverse(vec2.normalize(sd));\n        var sdo = vec2.orthogonal(vec2.clone(sd));\n\n        var hs = thickness / 2.0;\n        var x1 = sx + hs * (sd[0] + sdo[0]);\n        var x2 = sx + hs * (sd[0] - sdo[0]);\n        var y1 = sy + hs * (sd[1] + sdo[1]);\n        var y2 = sy + hs * (sd[1] - sdo[1]);\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n    cappers[PenLineCap.Flat] = function (box: IBoundingBox, sx: number, sy: number, metrics: any, thickness: number) {\n        var sdo = vec2.clone(metrics.startVector);\n        if (!sdo || !sdo[0] || !sdo[1])\n            return;\n        vec2.orthogonal(vec2.normalize(sdo));\n\n        var hs = thickness / 2.0;\n        var x1 = sx + hs * sdo[0];\n        var x2 = sx + hs * -sdo[0];\n        var y1 = sy + hs * sdo[1];\n        var y2 = sy + hs * -sdo[1];\n\n        box.l = Math.min(box.l, x1, x2);\n        box.r = Math.max(box.r, x1, x2);\n        box.t = Math.min(box.t, y1, y2);\n        box.b = Math.max(box.b, y1, y2);\n    };\n}","namespace curve.bounds.stroke {\n    export class StartCapExtender {\n        extend() {\n\n        }\n    }\n}","namespace curve.bounds.stroke {\n    import vec2 = la.vec2;\n    import IBoundsExtender = curve.bounds.extenders.IBoundsExtender;\n    import ISegmentMetrics = curve.bounds.extenders.ISegmentMetrics;\n\n    export class StrokeBounds implements IBoundingBox {\n        path: Path;\n        pars: IStrokeParameters;\n        l: number = 0;\n        t: number = 0;\n        r: number = 0;\n        b: number = 0;\n\n        private $calc = false;\n\n        constructor(path: Path) {\n            Object.defineProperties(this, {\n                \"path\": {value: path, writable: false}\n            });\n        }\n\n        ensure(): this {\n            if (!this.$calc)\n                this.calculate();\n            return this;\n        }\n\n        calculate(): this {\n            this.$calc = false;\n            this.l = Number.POSITIVE_INFINITY;\n            this.t = Number.POSITIVE_INFINITY;\n            this.r = Number.NEGATIVE_INFINITY;\n            this.b = Number.NEGATIVE_INFINITY;\n\n            var sx: number,\n                sy: number,\n                last: IBoundsExtender,\n                lastMetrics: ISegmentMetrics;\n            var selector = new ExtenderSelector();\n            this.path.exec(selector, () => {\n                var cur = selector.current;\n                var metrics = cur.init(sx, sy, selector.args);\n\n                if (!cur.isMove && last.isMove) {\n                    extendStartCap(this, sx, sy, metrics, this.pars);\n                } else if (lastMetrics) {\n                    extendLineJoin(this, sx, sy, metrics, lastMetrics, this.pars);\n                }\n\n                cur.extendStrokeBox(this, sx, sy, selector.args, metrics, this.pars);\n\n                sx = metrics.endPoint[0];\n                sy = metrics.endPoint[1];\n                last = cur;\n                lastMetrics = metrics;\n            });\n\n            if (lastMetrics)\n                extendEndCap(this, lastMetrics, this.pars);\n\n            this.$calc = true;\n            return this;\n        }\n    }\n}","namespace curve.parse.buffer {\n    export class Parser implements IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array) {\n            var buffer = toBuffer(data);\n            //TODO: Implement\n            return undefined;\n        }\n    }\n\n    export function parseNumber(tracker: IParseTracker): number {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var len = data.length;\n        //NaN\n        if (isNaN(data, tracker.offset)) {\n            tracker.offset += 3;\n            return NaN;\n        }\n\n        //Check - or +\n        var negate = false;\n        if (data[tracker.offset] === 0x2D) {\n            negate = true;\n            tracker.offset++;\n        } else if (data[tracker.offset] === 0x2B) {\n            tracker.offset++;\n        }\n\n        //Infinity\n        if (isInfinity(data, tracker.offset)) {\n            tracker.offset += 8;\n            return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n        }\n\n        //(characteristic)[.(mantissa)][Ee[+-](significand)]\n        parseInteger(tracker);\n        var cur = data[tracker.offset];\n        if (cur === 0x2E) { // '.'\n            tracker.offset++;\n            if (!parseMantissa(tracker))\n                throw new Error(\"Invalid number\");\n        }\n\n        if (!parseSignificand(tracker))\n            throw new Error(\"Invalid number\");\n\n        return parseFloat(getSlice(data, start, tracker.offset - start));\n    }\n\n    function toBuffer(data: string|Uint8Array): Uint8Array {\n        if (data instanceof Uint8Array)\n            return data;\n        if (typeof TextEncoder === \"function\")\n            return new TextEncoder().encode(<string>data);\n    }\n\n    function isNaN(data: Uint8Array, i: number): boolean {\n        return data[i + 0] === 0x4E //N\n            && data[i + 1] === 0x61 //a\n            && data[i + 2] === 0x4E //N\n            ;\n    }\n\n    function isInfinity(data: Uint8Array, i: number): boolean {\n        return data[i + 0] === 0x49 //I\n            && data[i + 1] === 0x6E //n\n            && data[i + 2] === 0x66 //f\n            && data[i + 3] === 0x69 //i\n            && data[i + 4] === 0x6E //n\n            && data[i + 5] === 0x69 //i\n            && data[i + 6] === 0x74 //t\n            && data[i + 7] === 0x79 //y\n            ;\n    }\n\n    function parseInteger(tracker: IParseTracker): boolean {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var cur: number;\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n            tracker.offset++;\n        }\n        return tracker.offset !== start;\n    }\n\n    function parseMantissa(tracker: IParseTracker): boolean {\n        var start = tracker.offset;\n        var data = tracker.data;\n        var cur: number;\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\n            tracker.offset++;\n        }\n        return tracker.offset !== start;\n    }\n\n    function parseSignificand(tracker: IParseTracker): boolean {\n        var data = tracker.data;\n        if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\n            return true;\n        tracker.offset++;\n\n        var cur = data[tracker.offset];\n        if (cur === 0x2D || cur === 0x2B) // '-' '+'\n            tracker.offset++;\n        return parseInteger(tracker);\n    }\n\n    function getSlice(data: Uint8Array, offset: number, length: number): string {\n        var buf = new Array(length);\n        for (var i = 0; i < length; i++) {\n            buf[i] = data[offset + i];\n        }\n        return String.fromCharCode.apply(null, buf);\n    }\n}","namespace curve.parse.dom {\n    var domsvg = <SVGSVGElement>document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    var dompath = <SVGPathElement>document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n\n    export class Parser implements IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array) {\n            if (typeof data !== \"string\") {\n                console.warn(\"Input parse data was not a string.\", data);\n                return;\n            }\n            dompath.setAttribute(\"d\", <string>data);\n\n            var segments = dompath.pathSegList,\n                cur: number[] = [0, 0];\n            for (var i = 0, len = segments.numberOfItems; i < len; i++) {\n                parseSegment(runner, segments.getItem(i), cur);\n            }\n        }\n    }\n\n    function parseSegment(runner: ISegmentRunner, segment: SVGPathSeg, cur: number[]) {\n        switch (segment.pathSegType) {\n            case SVGPathSeg.PATHSEG_ARC_ABS:\n                let arc1 = <SVGPathSegArcAbs>segment;\n                ellipticalArc.genEllipse(runner, cur[0], cur[1], arc1.x, arc1.y, arc1.largeArcFlag ? 1 : 0, arc1.sweepFlag ? 1 : 0, arc1.r1, arc1.r2, arc1.angle);\n                cur[0] = arc1.x;\n                cur[1] = arc1.y;\n                break;\n            case SVGPathSeg.PATHSEG_ARC_REL:\n                let arc2 = <SVGPathSegArcRel>segment;\n                ellipticalArc.genEllipse(runner, cur[0], cur[1], cur[0] + arc2.x, cur[1] + arc2.y, arc2.largeArcFlag ? 1 : 0, arc2.sweepFlag ? 1 : 0, arc2.r1, arc2.r2, arc2.angle);\n                cur[0] += arc2.x;\n                cur[1] += arc2.y;\n                break;\n            case SVGPathSeg.PATHSEG_CLOSEPATH:\n                runner.closePath();\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                let curve1 = <SVGPathSegCurvetoCubicAbs>segment;\n                runner.bezierCurveTo(curve1.x1, curve1.y1, curve1.x2, curve1.y2, curve1.x, curve1.y);\n                cur[0] = curve1.x;\n                cur[1] = curve1.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                let curve2 = <SVGPathSegCurvetoCubicRel>segment;\n                runner.bezierCurveTo(cur[0] + curve2.x1, cur[1] + curve2.y1, cur[0] + curve2.x2, cur[1] + curve2.y2, cur[0] + curve2.x, cur[1] + curve2.y);\n                cur[0] += curve2.x;\n                cur[1] += curve2.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                let curve3 = <SVGPathSegCurvetoCubicSmoothAbs>segment;\n                smoothCubic(runner, curve3.x2, curve3.y2, curve3.x, curve3.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                let curve4 = <SVGPathSegCurvetoCubicSmoothRel>segment;\n                smoothCubic(runner, cur[0] + curve4.x2, cur[1] + curve4.y2, cur[0] + curve4.x, cur[1] + curve4.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                let curve5 = <SVGPathSegCurvetoQuadraticAbs>segment;\n                runner.quadraticCurveTo(curve5.x1, curve5.y1, curve5.x, curve5.y);\n                cur[0] = curve5.x;\n                cur[1] = curve5.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                let curve6 = <SVGPathSegCurvetoQuadraticRel>segment;\n                runner.quadraticCurveTo(cur[0] + curve6.x1, cur[1] + curve6.y1, cur[0] + curve6.x, cur[1] + curve6.y);\n                cur[0] += curve6.x;\n                cur[1] += curve6.y;\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                let curve7 = <SVGPathSegCurvetoQuadraticSmoothAbs>segment;\n                smoothQuadratic(runner, curve7.x, curve7.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                let curve8 = <SVGPathSegCurvetoQuadraticSmoothRel>segment;\n                smoothQuadratic(runner, cur[0] + curve8.x, cur[1] + curve8.y, cur);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_ABS:\n                let line1 = <SVGPathSegLinetoAbs>segment;\n                cur[0] = line1.x;\n                cur[1] = line1.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                let line2 = <SVGPathSegLinetoHorizontalAbs>segment;\n                cur[0] = line2.x;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                let line3 = <SVGPathSegLinetoHorizontalRel>segment;\n                cur[0] += line3.x;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_REL:\n                let line4 = <SVGPathSegLinetoRel>segment;\n                cur[0] += line4.x;\n                cur[1] += line4.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                let line5 = <SVGPathSegLinetoVerticalAbs>segment;\n                cur[1] = line5.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                let line6 = <SVGPathSegLinetoVerticalRel>segment;\n                cur[1] += line6.y;\n                runner.lineTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_MOVETO_ABS:\n                let move1 = <SVGPathSegMovetoAbs>segment;\n                cur[0] = move1.x;\n                cur[1] = move1.y;\n                runner.moveTo(cur[0], cur[1]);\n                break;\n            case SVGPathSeg.PATHSEG_MOVETO_REL:\n                let move2 = <SVGPathSegMovetoRel>segment;\n                cur[0] += move2.x;\n                cur[1] += move2.y;\n                runner.moveTo(cur[0], cur[1]);\n                break;\n            default:\n            case SVGPathSeg.PATHSEG_UNKNOWN:\n                console.warn(\"Unknown path segment.\");\n                break;\n        }\n    }\n\n    function smoothCubic(runner: ISegmentRunner, x2: number, y2: number, x: number, y: number, cur: number[]) {\n        var [cx, cy] = cur;\n        console.warn(\"Smooth cubic\", \"Not implemented\");\n    }\n\n    function smoothQuadratic(runner: ISegmentRunner, x: number, y: number, cur: number[]) {\n        var [cx, cy] = cur;\n        console.warn(\"Smooth quadratic\", \"Not implemented\");\n    }\n}","// Path Markup Syntax: http://msdn.microsoft.com/en-us/library/cc189041(v=vs.95).aspx\n\n//FigureDescription Syntax\n// MoveCommand DrawCommands [CloseCommand]\n\n//Double Syntax\n// digits\n// digits.digits\n// 'Infinity'\n// '-Infinity'\n// 'NaN'\n\n//Point Syntax\n// x,y\n// x y\n\n//Loop until exhausted\n//  Parse FigureDescription\n//      Find \"M\" or \"m\"? - Parse MoveCommand (start point)\n//          <point>\n//\n//      Find \"L\" or \"l\"? - Parse LineCommand (end point)\n//          <point>\n//      Find \"H\" or \"h\"? - Parse HorizontalLineCommand (x)\n//          <double>\n//      Find \"V\" or \"v\"? - Parse VerticalLineCommand (y)\n//          <double>\n//      Find \"C\" or \"c\"? - Parse CubicBezierCurveCommand (control point 1, control point 2, end point)\n//          <point> <point> <point>\n//      Find \"Q\" or \"q\"? - Parse QuadraticBezierCurveCommand (control point, end point)\n//          <point> <point>\n//      Find \"S\" or \"s\"? - Parse SmoothCubicBezierCurveCommand (control point 2, end point)\n//          <point> <point>\n//      Find \"T\" or \"t\"? - Parse SmoothQuadraticBezierCurveCommand (control point, end point)\n//          <point> <point>\n//      Find \"A\" or \"a\"? - Parse EllipticalArcCommand (size, rotationAngle, isLargeArcFlag, sweepDirectionFlag, endPoint)\n//          <point> <double> <1,0> <1,0> <point>\n//\n//      Find \"Z\" or \"z\"? - CloseCommand\n\nnamespace curve.parse.matching {\n    export class Parser implements IParser {\n        parse(runner: ISegmentRunner, data: string|Uint8Array) {\n            if (typeof data === \"string\")\n                parse(runner, data, data.length);\n            else\n                console.warn(\"Input parse data was not a string.\", data);\n        }\n    }\n\n    interface IPoint {\n        x: number;\n        y: number;\n    }\n\n    function parse(runner: ISegmentRunner, str: string, len: number) {\n        var index = 0;\n        go();\n\n        function go() {\n            var cp = {x: 0, y: 0};\n            var cp1: IPoint, cp2: IPoint, cp3: IPoint;\n            var start = {x: 0, y: 0};\n            var cbz = false; // last figure is a cubic bezier curve\n            var qbz = false; // last figure is a quadratic bezier curve\n            var cbzp = {x: 0, y: 0}; // points needed to create \"smooth\" beziers\n            var qbzp = {x: 0, y: 0}; // points needed to create \"smooth\" beziers\n\n            while (index < len) {\n                var c;\n                while (index < len && (c = str.charAt(index)) === ' ') {\n                    index++;\n                }\n                index++;\n                var relative = false;\n                switch (c) {\n                    case 'f':\n                    case 'F':\n                        c = str.charAt(index);\n                        if (c === '0')\n                            runner.setFillRule(FillRule.EvenOdd);\n                        else if (c === '1')\n                            runner.setFillRule(FillRule.NonZero);\n                        else\n                            return null;\n                        index++;\n                        c = str.charAt(index);\n                        break;\n                    case 'm':\n                        relative = true;\n                    case 'M':\n                        cp1 = parsePoint();\n                        if (cp1 == null)\n                            break;\n                        if (relative) {\n                            cp1.x += cp.x;\n                            cp1.y += cp.y;\n                        }\n                        runner.moveTo(cp1.x, cp1.y);\n                        start.x = cp.x = cp1.x;\n                        start.y = cp.y = cp1.y;\n                        advance();\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            runner.lineTo(cp1.x, cp1.y);\n                        }\n                        cp.x = cp1.x;\n                        cp.y = cp1.y;\n                        cbz = qbz = false;\n                        break;\n                    case 'l':\n                        relative = true;\n                    case 'L':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n\n                            runner.lineTo(cp1.x, cp1.y);\n\n                            cp.x = cp1.x;\n                            cp.y = cp1.y;\n                            advance();\n                        }\n                        cbz = qbz = false;\n                        break;\n                    case 'h':\n                        relative = true;\n                    case 'H':\n                        var x = parseDouble();\n                        if (x == null)\n                            break;\n\n                        if (relative)\n                            x += cp.x;\n                        cp = {x: x, y: cp.y};\n\n                        runner.lineTo(cp.x, cp.y);\n                        cbz = qbz = false;\n                        break;\n                    case 'v':\n                        relative = true;\n                    case 'V':\n                        var y = parseDouble();\n                        if (y == null)\n                            break;\n\n                        if (relative)\n                            y += cp.y;\n                        cp = {x: cp.x, y: y};\n\n                        runner.lineTo(cp.x, cp.y);\n                        cbz = qbz = false;\n                        break;\n                    case 'c':\n                        relative = true;\n                    case 'C':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            advance();\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n                            if ((cp3 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp3.x += cp.x;\n                                cp3.y += cp.y;\n                            }\n                            advance();\n\n                            runner.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n\n                            cp1.x = cp3.x;\n                            cp1.y = cp3.y;\n                        }\n                        cp.x = cp3.x;\n                        cp.y = cp3.y;\n                        cbz = true;\n                        cbzp.x = cp2.x;\n                        cbzp.y = cp2.y;\n                        qbz = false;\n                        break;\n                    case 's':\n                        relative = true;\n                    case 'S':\n                        while (morePointsAvailable()) {\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n                            if ((cp3 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp3.x += cp.x;\n                                cp3.y += cp.y;\n                            }\n\n                            if (cbz) {\n                                cp1.x = 2 * cp.x - cbzp.x;\n                                cp1.y = 2 * cp.y - cbzp.y;\n                            } else\n                                cp1 = cp;\n\n                            runner.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\n\n                            cbz = true;\n                            cbzp.x = cp2.x;\n                            cbzp.y = cp2.y;\n\n                            cp.x = cp3.x;\n                            cp.y = cp3.y;\n\n                            advance();\n                        }\n                        qbz = false;\n                        break;\n                    case 'q':\n                        relative = true;\n                    case 'Q':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp1.x += cp.x;\n                                cp1.y += cp.y;\n                            }\n                            advance();\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n                            advance();\n\n                            runner.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n                        }\n                        qbz = true;\n                        qbzp.x = cp1.x;\n                        qbzp.y = cp1.y;\n                        cbz = false;\n                        break;\n                    case 't':\n                        relative = true;\n                    case 'T':\n                        while (morePointsAvailable()) {\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n\n                            if (qbz) {\n                                cp1.x = 2 * cp.x - qbzp.x;\n                                cp1.y = 2 * cp.y - qbzp.y;\n                            } else\n                                cp1 = cp;\n\n                            runner.quadraticCurveTo(cp1.x, cp1.y, cp2.x, cp2.y);\n\n                            qbz = true;\n                            qbzp.x = cp1.x;\n                            qbzp.y = cp1.y;\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n\n                            advance();\n                        }\n                        cbz = false;\n                        break;\n                    case 'a':\n                        relative = true;\n                    case 'A':\n                        while (morePointsAvailable()) {\n                            if ((cp1 = parsePoint()) == null)\n                                break;\n\n                            var angle = parseDouble();\n                            var is_large = parseDouble() !== 0 ? 1 : 0;\n                            var sweep = SweepDirection.Counterclockwise;\n                            if (parseDouble() !== 0) sweep = SweepDirection.Clockwise;\n\n                            if ((cp2 = parsePoint()) == null)\n                                break;\n                            if (relative) {\n                                cp2.x += cp.x;\n                                cp2.y += cp.y;\n                            }\n\n                            var phi = angle * Math.PI / 180.0;\n                            ellipticalArc.genEllipse(runner, cp.x, cp.y, cp2.x, cp2.y, is_large, sweep, phi, cp1.x, cp1.y);\n\n                            cp.x = cp2.x;\n                            cp.y = cp2.y;\n\n                            advance();\n                        }\n                        cbz = qbz = false;\n                        break;\n                    case 'z':\n                    case 'Z':\n                        runner.closePath();\n\n                        cp.x = start.x;\n                        cp.y = start.y;\n                        cbz = qbz = false;\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        function parsePoint(): IPoint {\n            var x = parseDouble();\n            if (x == null)\n                return null;\n\n            var c;\n            while (index < len && ((c = str.charAt(index)) === ' ' || c === ',')) {\n                index++;\n            }\n            if (index >= len)\n                return null;\n\n            var y = parseDouble();\n            if (y == null)\n                return null;\n\n            return {x: x, y: y};\n        }\n\n        function parseDouble(): number {\n            advance();\n            var isNegative = false;\n            if (match('-')) {\n                isNegative = true;\n                index++;\n            } else if (match('+')) {\n                index++;\n            }\n            if (match('Infinity')) {\n                index += 8;\n                return isNegative ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n            }\n            if (match('NaN'))\n                return NaN;\n\n            var temp = '';\n            while (index < len) {\n                var code = str.charCodeAt(index);\n                var c = str[index];\n                //0-9, ., E, e, E-, e-\n                if (code >= 48 && code <= 57)\n                    temp += c;\n                else if (code === 46)\n                    temp += c;\n                else if (c === 'E' || c === 'e') {\n                    temp += c;\n                    if (str[index + 1] === '-') {\n                        temp += '-';\n                        index++;\n                    }\n                }\n                else\n                    break;\n                index++;\n            }\n            if (temp.length === 0)\n                return null;\n            var f = parseFloat(temp);\n            return isNegative ? -f : f;\n        }\n\n        function advance() {\n            var code: number;\n            var c: string;\n            while (index < len) {\n                code = str.charCodeAt(index);\n                //alphanum\n                if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122) || (code >= 48 && code <= 57))\n                    break;\n                c = String.fromCharCode(code);\n                if (c === '.')\n                    break;\n                if (c === '-')\n                    break;\n                if (c === '+')\n                    break;\n                index++;\n            }\n        }\n\n        function match(matchStr: string): boolean {\n            var c1: string;\n            var c2: string;\n            for (var i = 0; i < matchStr.length && (index + i) < len; i++) {\n                c1 = matchStr.charAt(i);\n                c2 = str.charAt(index + i);\n                if (c1 !== c2)\n                    return false;\n            }\n            return true;\n        }\n\n        function morePointsAvailable(): boolean {\n            var c;\n            while (index < len && ((c = str.charAt(index)) === ',' || c === ' ')) {\n                index++;\n            }\n            if (index >= len)\n                return false;\n            if (c === '.' || c === '-' || c === '+')\n                return true;\n            var code = str.charCodeAt(index);\n            return code >= 48 && code <= 57;\n        }\n    }\n}","interface ISegmentExecutor {\n    exec(runner: ISegmentRunner, step?: Function);\n}\n\ninterface ISegmentRunner {\n    setFillRule(fillRule: FillRule);\n    closePath();\n    moveTo(x: number, y: number);\n    lineTo(x: number, y: number);\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number);\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number);\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean);\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number);\n    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean);\n}\n\ninterface ISegment {\n    (runner: ISegmentRunner): void;\n}\n\nenum FillRule {\n    EvenOdd = 0,\n    NonZero = 1\n}\n\nenum SweepDirection {\n    Counterclockwise = 0,\n    Clockwise = 1,\n}\n\ninterface CanvasRenderingContext2D extends ISegmentRunner {\n}\n","namespace curve {\n    export class Path implements ISegmentRunner, ISegmentExecutor {\n        private $ops: ISegment[] = [];\n\n        constructor();\n        constructor(path: Path);\n        constructor(d: string);\n        constructor(compiled: ICompiledSegment[]);\n        constructor(arg0?: string|Path|ICompiledSegment[]) {\n            if (arg0 instanceof Path) {\n                arg0.exec(this);\n            } else if (Array.isArray(arg0)) {\n                new compiler.decompile(this, arg0);\n            } else if (typeof arg0 === \"string\") {\n                var parser = parse.getParser();\n                parser.parse(this, arg0);\n            }\n        }\n\n        exec(runner: ISegmentRunner, step?: Function) {\n            for (var ops = this.$ops, i = 0; ops && i < ops.length; i++) {\n                ops[i](runner);\n                step && step();\n            }\n        }\n\n        draw(ctx: CanvasRenderingContext2D) {\n            this.exec(ctx);\n        }\n\n        addPath(path: Path) {\n            path.exec(this);\n        }\n\n        setFillRule(fillRule: FillRule) {\n            this.$ops.push(exec => exec.setFillRule(fillRule));\n        }\n\n        closePath() {\n            this.$ops.push(exec => exec.closePath());\n        }\n\n        moveTo(x: number, y: number) {\n            this.$ops.push(exec => exec.moveTo(x, y));\n        }\n\n        lineTo(x: number, y: number) {\n            this.$ops.push(exec => exec.lineTo(x, y));\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.$ops.push(exec => exec.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.$ops.push(exec => exec.quadraticCurveTo(cpx, cpy, x, y));\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            this.$ops.push(exec => exec.arc(x, y, radius, startAngle, endAngle, anticlockwise));\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            this.$ops.push(exec => exec.arcTo(x1, y1, x2, y2, radius));\n        }\n\n        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            this.$ops.push(exec => exec.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise));\n        }\n\n        static parse(runner: ISegmentRunner, data: string) {\n            var parser = parse.getParser();\n            parser.parse(runner, data);\n        }\n    }\n}","namespace curve {\n    export function serialize(path: Path) {\n        var serializer = new Serializer();\n        path.exec(serializer);\n        return serializer.data;\n    }\n\n    class Serializer implements ISegmentRunner {\n        data: string = \"\";\n\n        setFillRule(fillRule: FillRule) {\n            this.prepend().data += `F${fillRule}`;\n        }\n\n        closePath() {\n            this.prepend().data += \"Z\";\n        }\n\n        moveTo(x: number, y: number) {\n            this.prepend().data += `M${x},${y}`;\n        }\n\n        lineTo(x: number, y: number) {\n            this.prepend().data += `L${x},${y}`;\n        }\n\n        bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\n            this.prepend().data += `C${cp1x},${cp1y},${cp2x},${cp2y},${x},${y}`;\n        }\n\n        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\n            this.prepend().data += `Q${cpx},${cpy},${x},${y}`;\n        }\n\n        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\n            // Not represented in svg\n        }\n\n        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number) {\n            // Not represented in svg\n        }\n\n        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, antiClockwise?: boolean) {\n            // Convert to ellipticalArc\n            console.warn(\"serialize.ellipse\", \"Not implemented\");\n        }\n\n        private prepend(): this {\n            if (this.data)\n                this.data += \" \";\n            return this;\n        }\n    }\n}"],"sourceRoot":"/source/"}