{"version":3,"sources":["_version.ts","polyfills/CanvasRenderingContext2D_drawPath.ts","polyfills/CanvasRenderingContext2D_ellipse.ts","polyfills/CanvasRenderingContext2D_exts.ts","polyfills/TextEncoder.ts","MediaParser.ts","Path2DEx.ts","Path2D_parse.ts","parseNumber.ts","parser.ts"],"names":["path2d","TextEncoder","encode","path2d.MediaParser","path2d.MediaParser.constructor","path2d.MediaParser.ParseDouble","path2d.MediaParser.Match","path2d.MediaParser.Advance","path2d.MediaParser.MorePointsAvailable","path2d.PathOpType","path2d.Path2DEx","path2d.Path2DEx.constructor","path2d.Path2DEx.addPath","path2d.Path2DEx.closePath","path2d.Path2DEx.moveTo","path2d.Path2DEx.lineTo","path2d.Path2DEx.bezierCurveTo","path2d.Path2DEx.quadraticCurveTo","path2d.Path2DEx.arc","path2d.Path2DEx.arcTo","path2d.Path2DEx.ellipse","path2d.Path2DEx.rect","path2d.Path2DEx.parse","path2d.parseNumber","path2d.isNaN","path2d.isInfinity","path2d.parseInteger","path2d.parseMantissa","path2d.parseSignificand","path2d.getSlice","path2d.doParse","path2d.toBuffer"],"mappings":"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","file":"path2d.js","sourcesContent":["namespace path2d {\r\n    export var version = '0.1.0';\r\n}",null,null,null,null,"// Path Markup Syntax: http://msdn.microsoft.com/en-us/library/cc189041(v=vs.95).aspx\r\n\r\n//FigureDescription Syntax\r\n// MoveCommand DrawCommands [CloseCommand]\r\n\r\n//Double Syntax\r\n// digits\r\n// digits.digits\r\n// 'Infinity'\r\n// '-Infinity'\r\n// 'NaN'\r\n\r\n//Point Syntax\r\n// x,y\r\n// x y\r\n\r\n//Loop until exhausted\r\n//  Parse FigureDescription\r\n//      Find \"M\" or \"m\"? - Parse MoveCommand (start point)\r\n//          <point>\r\n//\r\n//      Find \"L\" or \"l\"? - Parse LineCommand (end point)\r\n//          <point>\r\n//      Find \"H\" or \"h\"? - Parse HorizontalLineCommand (x)\r\n//          <double>\r\n//      Find \"V\" or \"v\"? - Parse VerticalLineCommand (y)\r\n//          <double>\r\n//      Find \"C\" or \"c\"? - Parse CubicBezierCurveCommand (control point 1, control point 2, end point)\r\n//          <point> <point> <point>\r\n//      Find \"Q\" or \"q\"? - Parse QuadraticBezierCurveCommand (control point, end point)\r\n//          <point> <point>\r\n//      Find \"S\" or \"s\"? - Parse SmoothCubicBezierCurveCommand (control point 2, end point)\r\n//          <point> <point>\r\n//      Find \"T\" or \"t\"? - Parse SmoothQuadraticBezierCurveCommand (control point, end point)\r\n//          <point> <point>\r\n//      Find \"A\" or \"a\"? - Parse EllipticalArcCommand (size, rotationAngle, isLargeArcFlag, sweepDirectionFlag, endPoint)\r\n//          <point> <double> <1,0> <1,0> <point>\r\n//\r\n//      Find \"Z\" or \"z\"? - CloseCommand\r\n\r\nmodule path2d {\r\n    export class MediaParser {\r\n        private str: string;\r\n        private len: number;\r\n        private index: number = 0;\r\n\r\n        constructor (str: string) {\r\n            this.str = str;\r\n            this.len = str.length;\r\n        }\r\n\r\n        /*\r\n        ParseGeometryImpl (): Geometry {\r\n            var cp = new Point();\r\n            var cp1: Point, cp2: Point, cp3: Point;\r\n            var start = new Point();\r\n            var fillRule = Shapes.FillRule.EvenOdd;\r\n            var cbz = false; // last figure is a cubic bezier curve\r\n            var qbz = false; // last figure is a quadratic bezier curve\r\n            var cbzp = new Point(); // points needed to create \"smooth\" beziers\r\n            var qbzp = new Point(); // points needed to create \"smooth\" beziers\r\n\r\n            var path = new minerva.path.Path();\r\n            while (this.index < this.len) {\r\n                var c;\r\n                while (this.index < this.len && (c = this.str.charAt(this.index)) === ' ') {\r\n                    this.index++;\r\n                }\r\n                this.index++;\r\n                var relative = false;\r\n                switch (c) {\r\n                    case 'f':\r\n                    case 'F':\r\n                        c = this.str.charAt(this.index);\r\n                        if (c === '0')\r\n                            fillRule = Shapes.FillRule.EvenOdd;\r\n                        else if (c === '1')\r\n                            fillRule = Shapes.FillRule.NonZero;\r\n                        else\r\n                            return null;\r\n                        this.index++;\r\n                        c = this.str.charAt(this.index);\r\n                        break;\r\n                    case 'm':\r\n                        relative = true;\r\n                    case 'M':\r\n                        cp1 = this.ParsePoint();\r\n                        if (cp1 == null)\r\n                            break;\r\n                        if (relative) {\r\n                            cp1.x += cp.x;\r\n                            cp1.y += cp.y;\r\n                        }\r\n                        path.move(cp1.x, cp1.y);\r\n                        start.x = cp.x = cp1.x;\r\n                        start.y = cp.y = cp1.y;\r\n                        this.Advance();\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n                            path.line(cp1.x, cp1.y);\r\n                        }\r\n                        cp.x = cp1.x;\r\n                        cp.y = cp1.y;\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'l':\r\n                        relative = true;\r\n                    case 'L':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n\r\n                            path.line(cp1.x, cp1.y);\r\n\r\n                            cp.x = cp1.x;\r\n                            cp.y = cp1.y;\r\n                            this.Advance();\r\n                        }\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'h':\r\n                        relative = true;\r\n                    case 'H':\r\n                        var x = this.ParseDouble();\r\n                        if (x == null)\r\n                            break;\r\n\r\n                        if (relative)\r\n                            x += cp.x;\r\n                        cp = new Point(x, cp.y);\r\n\r\n                        path.line(cp.x, cp.y);\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'v':\r\n                        relative = true;\r\n                    case 'V':\r\n                        var y = this.ParseDouble();\r\n                        if (y == null)\r\n                            break;\r\n\r\n                        if (relative)\r\n                            y += cp.y;\r\n                        cp = new Point(cp.x, y);\r\n\r\n                        path.line(cp.x, cp.y);\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'c':\r\n                        relative = true;\r\n                    case 'C':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp3 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp3.x += cp.x;\r\n                                cp3.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n\r\n                            path.cubicBezier(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\r\n\r\n                            cp1.x = cp3.x;\r\n                            cp1.y = cp3.y;\r\n                        }\r\n                        cp.x = cp3.x;\r\n                        cp.y = cp3.y;\r\n                        cbz = true;\r\n                        cbzp.x = cp2.x;\r\n                        cbzp.y = cp2.y;\r\n                        qbz = false;\r\n                        break;\r\n                    case 's':\r\n                        relative = true;\r\n                    case 'S':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp3 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp3.x += cp.x;\r\n                                cp3.y += cp.y;\r\n                            }\r\n\r\n                            if (cbz) {\r\n                                cp1.x = 2 * cp.x - cbzp.x;\r\n                                cp1.y = 2 * cp.y - cbzp.y;\r\n                            } else\r\n                                cp1 = cp;\r\n\r\n                            path.cubicBezier(cp1.x, cp1.y, cp2.x, cp2.y, cp3.x, cp3.y);\r\n\r\n                            cbz = true;\r\n                            cbzp.x = cp2.x;\r\n                            cbzp.y = cp2.y;\r\n\r\n                            cp.x = cp3.x;\r\n                            cp.y = cp3.y;\r\n\r\n                            this.Advance();\r\n                        }\r\n                        qbz = false;\r\n                        break;\r\n                    case 'q':\r\n                        relative = true;\r\n                    case 'Q':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp1.x += cp.x;\r\n                                cp1.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n                            this.Advance();\r\n\r\n                            path.quadraticBezier(cp1.x, cp1.y, cp2.x, cp2.y);\r\n\r\n                            cp.x = cp2.x;\r\n                            cp.y = cp2.y;\r\n                        }\r\n                        qbz = true;\r\n                        qbzp.x = cp1.x;\r\n                        qbzp.y = cp1.y;\r\n                        cbz = false;\r\n                        break;\r\n                    case 't':\r\n                        relative = true;\r\n                    case 'T':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n\r\n                            if (qbz) {\r\n                                cp1.x = 2 * cp.x - qbzp.x;\r\n                                cp1.y = 2 * cp.y - qbzp.y;\r\n                            } else\r\n                                cp1 = cp;\r\n\r\n                            path.quadraticBezier(cp1.x, cp1.y, cp2.x, cp2.y);\r\n\r\n                            qbz = true;\r\n                            qbzp.x = cp1.x;\r\n                            qbzp.y = cp1.y;\r\n\r\n                            cp.x = cp2.x;\r\n                            cp.y = cp2.y;\r\n\r\n                            this.Advance();\r\n                        }\r\n                        cbz = false;\r\n                        break;\r\n                    case 'a':\r\n                        relative = true;\r\n                    case 'A':\r\n                        while (this.MorePointsAvailable()) {\r\n                            if ((cp1 = this.ParsePoint()) == null)\r\n                                break;\r\n\r\n                            var angle = this.ParseDouble();\r\n                            var is_large = this.ParseDouble() !== 0;\r\n                            var sweep = minerva.SweepDirection.Counterclockwise;\r\n                            if (this.ParseDouble() !== 0) sweep = minerva.SweepDirection.Clockwise;\r\n\r\n                            if ((cp2 = this.ParsePoint()) == null)\r\n                                break;\r\n                            if (relative) {\r\n                                cp2.x += cp.x;\r\n                                cp2.y += cp.y;\r\n                            }\r\n\r\n                            path.ellipticalArc(cp1.x, cp1.y, angle, is_large, sweep, cp2.x, cp2.y);\r\n\r\n                            cp.x = cp2.x;\r\n                            cp.y = cp2.y;\r\n\r\n                            this.Advance();\r\n                        }\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    case 'z':\r\n                    case 'Z':\r\n                        //path.Line(start.x, start.y);\r\n                        path.close();\r\n                        //path.Move(start.x, start.y);\r\n\r\n                        cp.x = start.x;\r\n                        cp.y = start.y;\r\n                        cbz = qbz = false;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            var pg = new PathGeometry();\r\n            pg.OverridePath(path);\r\n            pg.FillRule = <Shapes.FillRule>fillRule;\r\n            return pg;\r\n        }\r\n        */\r\n\r\n        /*\r\n        private ParsePoint (): Point {\r\n            var x = this.ParseDouble();\r\n            if (x == null)\r\n                return null;\r\n\r\n            var c;\r\n            while (this.index < this.len && ((c = this.str.charAt(this.index)) === ' ' || c === ',')) {\r\n                this.index++;\r\n            }\r\n            if (this.index >= this.len)\r\n                return null;\r\n\r\n            var y = this.ParseDouble();\r\n            if (y == null)\r\n                return null;\r\n\r\n            return new Point(x, y);\r\n        }\r\n        */\r\n\r\n        ParseDouble (): number {\r\n            this.Advance();\r\n            var isNegative = false;\r\n            if (this.Match('-')) {\r\n                isNegative = true;\r\n                this.index++;\r\n            } else if (this.Match('+')) {\r\n                this.index++;\r\n            }\r\n            if (this.Match('Infinity')) {\r\n                this.index += 8;\r\n                return isNegative ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\r\n            }\r\n            if (this.Match('NaN'))\r\n                return NaN;\r\n\r\n            var temp = '';\r\n            while (this.index < this.len) {\r\n                var code = this.str.charCodeAt(this.index);\r\n                var c = this.str[this.index];\r\n                //0-9, ., E, e, E-, e-\r\n                if (code >= 48 && code <= 57)\r\n                    temp += c;\r\n                else if (code === 46)\r\n                    temp += c;\r\n                else if (c === 'E' || c === 'e') {\r\n                    temp += c;\r\n                    if (this.str[this.index + 1] === '-') {\r\n                        temp += '-';\r\n                        this.index++;\r\n                    }\r\n                }\r\n                else\r\n                    break;\r\n                this.index++;\r\n            }\r\n            if (temp.length === 0)\r\n                return null;\r\n            var f = parseFloat(temp);\r\n            return isNegative ? -f : f;\r\n        }\r\n\r\n        private Match (matchStr: string): boolean {\r\n            var c1: string;\r\n            var c2: string;\r\n            for (var i = 0; i < matchStr.length && (this.index + i) < this.len; i++) {\r\n                c1 = matchStr.charAt(i);\r\n                c2 = this.str.charAt(this.index + i);\r\n                if (c1 !== c2)\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        private Advance () {\r\n            var code: number;\r\n            var c: string;\r\n            while (this.index < this.len) {\r\n                code = this.str.charCodeAt(this.index);\r\n                //alphanum\r\n                if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122) || (code >= 48 && code <= 57))\r\n                    break;\r\n                c = String.fromCharCode(code);\r\n                if (c === '.')\r\n                    break;\r\n                if (c === '-')\r\n                    break;\r\n                if (c === '+')\r\n                    break;\r\n                this.index++;\r\n            }\r\n        }\r\n\r\n        private MorePointsAvailable (): boolean {\r\n            var c;\r\n            while (this.index < this.len && ((c = this.str.charAt(this.index)) === ',' || c === ' ')) {\r\n                this.index++;\r\n            }\r\n            if (this.index >= this.len)\r\n                return false;\r\n            if (c === '.' || c === '-' || c === '+')\r\n                return true;\r\n            var code = this.str.charCodeAt(this.index);\r\n            return code >= 48 && code <= 57;\r\n        }\r\n    }\r\n}","namespace path2d {\r\n    export interface IPathOp {\r\n        type: PathOpType;\r\n        args: any[];\r\n    }\r\n    export enum PathOpType {\r\n        closePath,\r\n        moveTo,\r\n        lineTo,\r\n        bezierCurveTo,\r\n        quadraticCurveTo,\r\n        arc,\r\n        arcTo,\r\n        ellipse,\r\n        rect,\r\n    }\r\n\r\n    export class Path2DEx implements Path2D {\r\n        private $ops: IPathOp[];\r\n\r\n        constructor ();\r\n        constructor (path: Path2D);\r\n        constructor (d: string);\r\n        constructor (arg0?: string|Path2D) {\r\n            if (arg0 instanceof <any>Path2D) {\r\n                this.$ops = JSON.parse(JSON.stringify(this.$ops));\r\n            } else if (typeof arg0 === \"string\") {\r\n                this.$ops = [];\r\n                Path2DEx.parse.call(this, arg0);\r\n            } else {\r\n                this.$ops = [];\r\n            }\r\n        }\r\n\r\n        addPath (path: Path2D, transform?: SVGMatrix) {\r\n\r\n        }\r\n\r\n        closePath () {\r\n            this.$ops.push({\r\n                type: PathOpType.closePath,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        moveTo (x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.moveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        lineTo (x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.lineTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        bezierCurveTo (cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.bezierCurveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        quadraticCurveTo (cpx: number, cpy: number, x: number, y: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.quadraticCurveTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        arc (x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n            this.$ops.push({\r\n                type: PathOpType.arc,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        arcTo (x1: number, y1: number, x2: number, y2: number, radius: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.arcTo,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        ellipse (x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean) {\r\n            this.$ops.push({\r\n                type: PathOpType.ellipse,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        rect (x: number, y: number, width: number, height: number) {\r\n            this.$ops.push({\r\n                type: PathOpType.rect,\r\n                args: Array.prototype.slice.call(arguments, 0)\r\n            });\r\n        }\r\n\r\n        static parse (d: string): Path2D {\r\n            throw new Error(\"Not implemented\");\r\n        }\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\n(function (global: any) {\r\n    if (typeof Path2D === \"function\") {\r\n        global.Path2D.parse = global.path2d.Path2DEx.parse;\r\n    } else {\r\n        global.Path2D = global.path2d.Path2DEx;\r\n    }\r\n})(this);","namespace path2d {\r\n    export function parseNumber(tracker: IParseTracker): number {\r\n        var start = tracker.offset;\r\n        var data = tracker.data;\r\n        var len = data.length;\r\n        //NaN\r\n        if (isNaN(data, tracker.offset)) {\r\n            tracker.offset += 3;\r\n            return NaN;\r\n        }\r\n\r\n        //Check - or +\r\n        var negate = false;\r\n        if (data[tracker.offset] === 0x2D) {\r\n            negate = true;\r\n            tracker.offset++;\r\n        } else if (data[tracker.offset] === 0x2B) {\r\n            tracker.offset++;\r\n        }\r\n\r\n        //Infinity\r\n        if (isInfinity(data, tracker.offset)) {\r\n            tracker.offset += 8;\r\n            return negate ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\r\n        }\r\n\r\n        //(characteristic)[.(mantissa)][Ee[+-](significand)]\r\n        parseInteger(tracker);\r\n        var cur = data[tracker.offset];\r\n        if (cur === 0x2E) { // '.'\r\n            tracker.offset++;\r\n            if (!parseMantissa(tracker))\r\n                throw new Error(\"Invalid number\");\r\n        }\r\n\r\n        if (!parseSignificand(tracker))\r\n            throw new Error(\"Invalid number\");\r\n\r\n        return parseFloat(getSlice(data, start, tracker.offset - start));\r\n    }\r\n\r\n    function isNaN(data: Uint8Array, i: number): boolean {\r\n        return data[i + 0] === 0x4E //N\r\n            && data[i + 1] === 0x61 //a\r\n            && data[i + 2] === 0x4E //N\r\n            ;\r\n    }\r\n\r\n    function isInfinity(data: Uint8Array, i: number): boolean {\r\n        return data[i + 0] === 0x49 //I\r\n            && data[i + 1] === 0x6E //n\r\n            && data[i + 2] === 0x66 //f\r\n            && data[i + 3] === 0x69 //i\r\n            && data[i + 4] === 0x6E //n\r\n            && data[i + 5] === 0x69 //i\r\n            && data[i + 6] === 0x74 //t\r\n            && data[i + 7] === 0x79 //y\r\n            ;\r\n    }\r\n\r\n    function parseInteger(tracker: IParseTracker): boolean {\r\n        var start = tracker.offset;\r\n        var data = tracker.data;\r\n        var cur: number;\r\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\r\n            tracker.offset++;\r\n        }\r\n        return tracker.offset !== start;\r\n    }\r\n\r\n    function parseMantissa(tracker: IParseTracker): boolean {\r\n        var start = tracker.offset;\r\n        var data = tracker.data;\r\n        var cur: number;\r\n        while ((cur = data[tracker.offset]) != null && cur >= 0x30 && cur <= 0x39) {\r\n            tracker.offset++;\r\n        }\r\n        return tracker.offset !== start;\r\n    }\r\n\r\n    function parseSignificand(tracker: IParseTracker): boolean {\r\n        var data = tracker.data;\r\n        if (data[tracker.offset] !== 0x45 && data[tracker.offset] !== 0x65)\r\n            return true;\r\n        tracker.offset++;\r\n\r\n        var cur = data[tracker.offset];\r\n        if (cur === 0x2D || cur === 0x2B) // '-' '+'\r\n            tracker.offset++;\r\n        return parseInteger(tracker);\r\n    }\r\n\r\n    function getSlice(data: Uint8Array, offset: number, length: number): string {\r\n        var buf = new Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            buf[i] = data[offset + i];\r\n        }\r\n        return String.fromCharCode.apply(null, buf);\r\n    }\r\n}","/// <reference path=\"Path2DEx\" />\r\n\r\nnamespace path2d {\r\n    Path2DEx.parse = function (d: string): Path2D {\r\n        if (this instanceof Path2D)\r\n            return doParse(this, d);\r\n        return doParse(new Path2DEx(), d);\r\n    };\r\n\r\n    export interface IParseTracker {\r\n        data: Uint8Array;\r\n        offset: number;\r\n    }\r\n    function doParse(path: Path2D, d: string): Path2D {\r\n        var data = toBuffer(d);\r\n        var i = 0;\r\n        var len = data.length;\r\n\r\n        //TODO: Implement\r\n\r\n        return path;\r\n    }\r\n\r\n    function toBuffer(d: string): Uint8Array {\r\n        if (typeof TextEncoder === \"function\") {\r\n            return new TextEncoder().encode(d);\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}